var tipuesearch = {"pages":[{"title":" fenvelopes ","text":"fenvelopes fenvelopes Fortran program to calculate phase envelopes. This is an ongoing project that intends te be a fully fledged generator of phase\nequilibria diagrams using Equations of State. Capabilities Right now fenvelopes calculates three kinds of phase-envelopes. [x] Two-phase PT envelopes [ ] Three-phase PT envelopes [x] Two-phase Px envelopes [ ] Three-phase Px envelopes [x] Px envelopes based on double saturation points. [ ] Isolated Px envelopes. [ ] Python wrappers to ease up scripting and plotting. Usage This program is intended to be used as a CLI software. The command used to\ncalculate phase diagrams is: fenvelopes --infile input_file.nml This will generate an fenvelopes_output directory. Which contains all the\ngenerated output files with the relevant data. Input files The input files ! input.nml ! ! Namelist based input file ! ========================= ! ! Units: !  - Pressure: bar !  - Temperature: K !  - Volume: L ! ========================= & nml_setup ! General settings nc = 5 , ! Number of components model = \"PR78\" , ! SRK PR76 PR78 mixrule = \"ClassicVdW\" ! only ClassicVdW for now / & nml_composition names = \"PC1\" \"PC2\" \"PC3\" \"PC4\" \"H2O\" spec = \"critical\" , ! critical or parameters specification z = 0.15 0.10 0.10 0.15 0.50 / & nml_classicvdw ! Classic VdW mixing rule parameters ! kij matrix kij ( 1 , :) = 0 0 0 0 0.7192 kij ( 2 , :) = 0 0 0 0 0.4598 kij ( 3 , :) = 0 0 0 0 0.2673 kij ( 4 , :) = 0 0 0 0 0.2417 kij ( 5 , :) = 0.7192 0.4598 0.2673 0.2417 0 ! lij matrix lij (:, :) = 0 / & nml_critical ! Critical constants ! Critical Temperature tc = 30 5.586 63 8.889 78 8.889 83 8.889 64 7.3 ! Critical Pressure pc = 4 8.82 1 9.65 1 0.2 7.72 22 0.89 ! Acentric Factor w = 0.098 0.535 0.891 1.085 0.344 / & nml_px ! Px envelopes relevant info ! Temperature T = 35 0.0 ! Initial composition, ussualy the same as the main fluid. z_0 = 0.15 0.10 0.10 0.15 0.50 ! Injection fluid composition z_injection = 1 0 0 0 0 ! Which kind of injection to realize injection_case = \"displace\" ! [dilute|displace] / Output All the output is directed to a generated folder fenvelopes_output . With the files env-<nphases>ph-<env_kind>_<envnumber>.dat Were all the envelope’s calculated points are written in a csv-like format,\ndelimited by spaces. Installation This program uses fpm as a builder. fpm handles all the needed dependencies and compiling procedures.\nIt is distributed in many ways, but we recommend the pip distribution. # using pipx pipx install fpm To install this program is as simple as: git clone https://www.github.com/fedebenelli/envelopes\ncd envelopes\nfpm install --profile release This will make fenvelopes accessible from any directory of your computer If you don’t want to install the program and just run it you can also run it\nwith fpm fpm run --profile release -- --infile <infile.nml PATH> Developer Info Federico Benelli PhD student with focus on reservoir PVT simulation.","tags":"home","loc":"index.html"},{"title":"critical_point – fenvelopes ","text":"type, public :: critical_point Inherited by type~~critical_point~~InheritedByGraph type~critical_point critical_point type~envelope envelope type~envelope->type~critical_point critical_points type~env3 env3 type~env3->type~critical_point ll_critical_points type~env3->type~envelope type~injelope injelope type~injelope->type~envelope Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables alpha p t Components Type Visibility Attributes Name Initial real(kind=pr), private :: alpha real(kind=pr), private :: p real(kind=pr), private :: t","tags":"","loc":"type/critical_point.html"},{"title":"env3 – fenvelopes ","text":"type, public, extends( envelope ) :: env3 Inherits type~~env3~~InheritsGraph type~env3 env3 type~critical_point critical_point type~env3->type~critical_point ll_critical_points type~envelope envelope type~env3->type~envelope type~envelope->type~critical_point critical_points Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables beta ll_critical_points logks w x y Type-Bound Procedures write Components Type Visibility Attributes Name Initial real(kind=pr), private, allocatable :: beta (:) type( critical_point ), private, allocatable :: ll_critical_points (:) real(kind=pr), private, allocatable :: logks (:,:) real(kind=pr), private, allocatable :: w (:,:) real(kind=pr), private, allocatable :: x (:,:) real(kind=pr), private, allocatable :: y (:,:) Type-Bound Procedures procedure, public :: write => write_envel_3 private subroutine write_envel_3 (self, file_name) Arguments Type Intent Optional Attributes Name class( env3 ), intent(in) :: self character(len=*), intent(in), optional :: file_name","tags":"","loc":"type/env3.html"},{"title":"envelope – fenvelopes ","text":"type, public :: envelope Inherits type~~envelope~~InheritsGraph type~envelope envelope type~critical_point critical_point type~envelope->type~critical_point critical_points Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~envelope~~InheritedByGraph type~envelope envelope type~env3 env3 type~env3->type~envelope type~injelope injelope type~injelope->type~envelope Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables critical_points logk logphi p t vars z Type-Bound Procedures write Components Type Visibility Attributes Name Initial type( critical_point ), private, allocatable :: critical_points (:) real(kind=pr), private, allocatable :: logk (:,:) real(kind=pr), private, allocatable :: logphi (:,:) real(kind=pr), private, allocatable :: p (:) real(kind=pr), private, allocatable :: t (:) real(kind=pr), private, allocatable :: vars (:,:) real(kind=pr), private, allocatable :: z (:) Type-Bound Procedures procedure, public :: write => write_envel_2 private subroutine write_envel_2 (self, file_name) Arguments Type Intent Optional Attributes Name class( envelope ), intent(in) :: self character(len=*), intent(in), optional :: file_name","tags":"","loc":"type/envelope.html"},{"title":"point – fenvelopes ","text":"type, public :: point Contents Variables i j x y Components Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=pr), public :: x real(kind=pr), public :: y","tags":"","loc":"type/point.html"},{"title":"injelope – fenvelopes ","text":"type, public, extends( envelope ) :: injelope Inherits type~~injelope~~InheritsGraph type~injelope injelope type~envelope envelope type~injelope->type~envelope type~critical_point critical_point type~envelope->type~critical_point critical_points Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables alpha z_inj z_mix Type-Bound Procedures write Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: alpha (:) real(kind=pr), public, allocatable :: z_inj (:) real(kind=pr), public, allocatable :: z_mix (:,:) Type-Bound Procedures procedure, public :: write => write_envel_2 private subroutine write_envel_2 (self, file_name) Arguments Type Intent Optional Attributes Name class( envelope ), intent(in) :: self character(len=*), intent(in), optional :: file_name","tags":"","loc":"type/injelope.html"},{"title":"print_header – fenvelopes","text":"public subroutine print_header(name) Arguments Type Intent Optional Attributes Name character(len=250), intent(in) :: name Contents None","tags":"","loc":"proc/print_header.html"},{"title":"write_critical_points – fenvelopes","text":"private subroutine write_critical_points(self, file_name) Arguments Type Intent Optional Attributes Name type( critical_point ), intent(in) :: self (:) character(len=*), intent(in), optional :: file_name Called by proc~~write_critical_points~~CalledByGraph proc~write_critical_points write_critical_points proc~write_envel_3 write_envel_3 proc~write_envel_3->proc~write_critical_points Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables file_unit filename i Variables Type Visibility Attributes Name Initial integer, private :: file_unit character(len=:), private, allocatable :: filename integer, private :: i","tags":"","loc":"proc/write_critical_points.html"},{"title":"write_envel_2 – fenvelopes","text":"private subroutine write_envel_2(self, file_name) Arguments Type Intent Optional Attributes Name class( envelope ), intent(in) :: self character(len=*), intent(in), optional :: file_name Calls proc~~write_envel_2~~CallsGraph proc~write_envel_2 write_envel_2 str str proc~write_envel_2->str logk logk proc~write_envel_2->logk p p proc~write_envel_2->p t t proc~write_envel_2->t Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables file_unit filename i n n_components Variables Type Visibility Attributes Name Initial integer, private :: file_unit character(len=:), private, allocatable :: filename integer, private :: i integer, private :: n integer, private :: n_components","tags":"","loc":"proc/write_envel_2.html"},{"title":"write_envel_3 – fenvelopes","text":"private subroutine write_envel_3(self, file_name) Arguments Type Intent Optional Attributes Name class( env3 ), intent(in) :: self character(len=*), intent(in), optional :: file_name Calls proc~~write_envel_3~~CallsGraph proc~write_envel_3 write_envel_3 logk logk proc~write_envel_3->logk w w proc~write_envel_3->w beta beta proc~write_envel_3->beta p p proc~write_envel_3->p x x proc~write_envel_3->x proc~write_critical_points write_critical_points proc~write_envel_3->proc~write_critical_points str str proc~write_envel_3->str t t proc~write_envel_3->t logks logks proc~write_envel_3->logks y y proc~write_envel_3->y Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables file_unit filename i n n_components Variables Type Visibility Attributes Name Initial integer, private :: file_unit character(len=:), private, allocatable :: filename integer, private :: i integer, private :: n integer, private :: n_components","tags":"","loc":"proc/write_envel_3.html"},{"title":"interpol – fenvelopes","text":"public elemental function interpol(x1, x2, y1, y2, x_obj) result(y) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x1 real(kind=pr), intent(in) :: x2 real(kind=pr), intent(in) :: y1 real(kind=pr), intent(in) :: y2 real(kind=pr), intent(in) :: x_obj Return Value real(kind=pr) Contents None","tags":"","loc":"proc/interpol.html"},{"title":"intersect_one_line – fenvelopes","text":"public function intersect_one_line(lx, ly) result(intersections) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lx (:) real(kind=pr), intent(in) :: ly (:) Return Value type( point ),allocatable,(:) Calls proc~~intersect_one_line~~CallsGraph proc~intersect_one_line intersect_one_line proc~intersects intersects proc~intersect_one_line->proc~intersects proc~solve_system solve_system proc~intersects->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~intersect_one_line~~CalledByGraph proc~intersect_one_line intersect_one_line interface~intersection intersection interface~intersection->proc~intersect_one_line Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j s t x xold y yold Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=pr), public :: s real(kind=pr), public :: t real(kind=pr), public :: x real(kind=pr), public :: xold = 9999 real(kind=pr), public :: y real(kind=pr), public :: yold = 9999","tags":"","loc":"proc/intersect_one_line.html"},{"title":"intersect_two_lines – fenvelopes","text":"public function intersect_two_lines(l1_x, l1_y, l2_x, l2_y) result(intersections) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: l1_x (:) real(kind=pr), intent(in) :: l1_y (:) real(kind=pr), intent(in) :: l2_x (:) real(kind=pr), intent(in) :: l2_y (:) Return Value type( point ),allocatable,(:) Calls proc~~intersect_two_lines~~CallsGraph proc~intersect_two_lines intersect_two_lines proc~intersects intersects proc~intersect_two_lines->proc~intersects proc~solve_system solve_system proc~intersects->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~intersect_two_lines~~CalledByGraph proc~intersect_two_lines intersect_two_lines interface~intersection intersection interface~intersection->proc~intersect_two_lines Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j s t x xold y yold Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=pr), public :: s real(kind=pr), public :: t real(kind=pr), public :: x real(kind=pr), public :: xold = 9999 real(kind=pr), public :: y real(kind=pr), public :: yold = 9999","tags":"","loc":"proc/intersect_two_lines.html"},{"title":"solve_system – fenvelopes","text":"public function solve_system(a, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: a (size(b),size(b)) real(kind=pr), intent(inout) :: b (:) Return Value real(kind=pr)(size(b)) Calls proc~~solve_system~~CallsGraph proc~solve_system solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~solve_system~~CalledByGraph proc~solve_system solve_system proc~full_newton full_newton proc~full_newton->proc~solve_system proc~envelope2 envelope2 proc~envelope2->proc~solve_system proc~update_specification update_specification proc~envelope2->proc~update_specification proc~intersects intersects proc~intersects->proc~solve_system proc~update_specification->proc~solve_system proc~injection_envelope injection_envelope proc~injection_envelope->proc~solve_system proc~injection_envelope->proc~full_newton proc~injection_envelope_three_phase injection_envelope_three_phase proc~injection_envelope_three_phase->proc~solve_system proc~injection_envelope_three_phase->proc~full_newton proc~intersect_one_line intersect_one_line proc~intersect_one_line->proc~intersects proc~intersect_two_lines intersect_two_lines proc~intersect_two_lines->proc~intersects interface~intersection intersection interface~intersection->proc~intersect_one_line interface~intersection->proc~intersect_two_lines Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables a_lapack b_lapack info ipiv lda ldb n nrhs Interfaces dgesv Variables Type Visibility Attributes Name Initial real(kind=8), public :: a_lapack (size(b),size(b)) real(kind=8), public :: b_lapack (size(b)) integer, public :: info integer, public :: ipiv (size(b)) integer, public :: lda integer, public :: ldb integer, public :: n integer, public :: nrhs Interfaces interface subroutine dgesv(n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name integer :: n integer :: nrhs real(kind=8) :: a (n,n) integer :: lda integer :: ipiv (n) real(kind=8) :: b (n) integer :: ldb integer :: info","tags":"","loc":"proc/solve_system.html"},{"title":"intersects – fenvelopes","text":"public subroutine intersects(x1, x2, x3, x4, y1, y2, y3, y4, s, t) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x1 real(kind=pr), intent(in) :: x2 real(kind=pr), intent(in) :: x3 real(kind=pr), intent(in) :: x4 real(kind=pr), intent(in) :: y1 real(kind=pr), intent(in) :: y2 real(kind=pr), intent(in) :: y3 real(kind=pr), intent(in) :: y4 real(kind=pr), intent(out) :: s real(kind=pr), intent(out) :: t Calls proc~~intersects~~CallsGraph proc~intersects intersects proc~solve_system solve_system proc~intersects->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~intersects~~CalledByGraph proc~intersects intersects proc~intersect_one_line intersect_one_line proc~intersect_one_line->proc~intersects proc~intersect_two_lines intersect_two_lines proc~intersect_two_lines->proc~intersects interface~intersection intersection interface~intersection->proc~intersect_one_line interface~intersection->proc~intersect_two_lines Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables A b tmp Variables Type Visibility Attributes Name Initial real(kind=pr), public :: A (2,2) real(kind=pr), public :: b (2) real(kind=pr), public :: tmp","tags":"","loc":"proc/intersects.html"},{"title":"intersection – fenvelopes","text":"public interface intersection Calls interface~~intersection~~CallsGraph interface~intersection intersection proc~intersect_two_lines intersect_two_lines interface~intersection->proc~intersect_two_lines proc~intersect_one_line intersect_one_line interface~intersection->proc~intersect_one_line proc~intersects intersects proc~intersect_two_lines->proc~intersects proc~intersect_one_line->proc~intersects proc~solve_system solve_system proc~intersects->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures intersect_two_lines intersect_one_line Module Procedures public function intersect_two_lines (l1_x, l1_y, l2_x, l2_y) result(intersections) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: l1_x (:) real(kind=pr), intent(in) :: l1_y (:) real(kind=pr), intent(in) :: l2_x (:) real(kind=pr), intent(in) :: l2_y (:) Return Value type( point ),allocatable, (:) public function intersect_one_line (lx, ly) result(intersections) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lx (:) real(kind=pr), intent(in) :: ly (:) Return Value type( point ),allocatable, (:)","tags":"","loc":"interface/intersection.html"},{"title":"betalimits – fenvelopes","text":"public subroutine betalimits(n, z, KFACT, bmin, bmax) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=8), intent(in), dimension(n) :: z real(kind=8), intent(in), dimension(n) :: KFACT real(kind=8), intent(out) :: bmin real(kind=8), intent(out) :: bmax Called by proc~~betalimits~~CalledByGraph proc~betalimits betalimits proc~flash flash proc~flash->proc~betalimits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i in ix vmax vmin Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: in integer, public :: ix real(kind=8), public, dimension(n) :: vmax real(kind=8), public, dimension(n) :: vmin","tags":"","loc":"proc/betalimits.html"},{"title":"betato01 – fenvelopes","text":"public subroutine betato01(n, z, KFACT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=8), intent(in), dimension(n) :: z real(kind=8), dimension(n) :: KFACT Called by proc~~betato01~~CalledByGraph proc~betato01 betato01 proc~flash flash proc~flash->proc~betato01 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables g0 g1 Variables Type Visibility Attributes Name Initial real(kind=8), public :: g0 real(kind=8), public :: g1","tags":"","loc":"proc/betato01.html"},{"title":"flash – fenvelopes","text":"public subroutine flash(spec, FIRST, z, t, p, v, x, y, rho_x, rho_y, beta, iter) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: spec logical, intent(inout) :: FIRST real(kind=8), intent(in) :: z (:) real(kind=8), intent(in) :: t real(kind=8) :: p real(kind=8) :: v real(kind=8), intent(out), dimension(size(z)) :: x real(kind=8), intent(out), dimension(size(z)) :: y real(kind=8), intent(out) :: rho_x real(kind=8), intent(out) :: rho_y real(kind=8), intent(out) :: beta integer, intent(out) :: iter Calls proc~~flash~~CallsGraph proc~flash flash ztvtermo ztvtermo proc~flash->ztvtermo proc~betalimits betalimits proc~flash->proc~betalimits termo termo proc~flash->termo proc~betato01 betato01 proc~flash->proc~betato01 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables AUXK DLPHIP DLPHIT DPVl FUGN KFACT LOG_K MTYP PHILOGx PHILOGy Vx Vy aux bij bmax bmin bx dVydVl denom dg dh dpv dpvv g g0 g1 h i iterv j logKold log_k2 nco pl pold pold2 pv savek step stepv stopflash told told2 varKold var_K Variables Type Visibility Attributes Name Initial real(kind=8), public, dimension(n) :: AUXK real(kind=8), public, dimension(n) :: DLPHIP real(kind=8), public, dimension(n) :: DLPHIT real(kind=8), public :: DPVl real(kind=8), public, dimension(n, n) :: FUGN real(kind=8), public, dimension(n) :: KFACT real(kind=8), public, dimension(n) :: LOG_K integer, public :: MTYP real(kind=8), public, dimension(n) :: PHILOGx real(kind=8), public, dimension(n) :: PHILOGy real(kind=8), public :: Vx real(kind=8), public :: Vy real(kind=8), public :: aux real(kind=8), public :: bij (n,n) real(kind=8), public :: bmax real(kind=8), public :: bmin real(kind=8), public :: bx real(kind=8), public :: dVydVl real(kind=8), public, dimension(n) :: denom real(kind=8), public :: dg real(kind=8), public :: dh real(kind=8), public :: dpv real(kind=8), public :: dpvv real(kind=8), public :: g real(kind=8), public :: g0 real(kind=8), public :: g1 real(kind=8), public :: h integer, public :: i integer, public :: iterv integer, public :: j real(kind=8), public, dimension(n) :: logKold real(kind=8), public :: log_k2 (n) integer, public :: nco real(kind=8), public :: pl real(kind=8), public :: pold real(kind=8), public :: pold2 real(kind=8), public :: pv real(kind=8), public :: savek (n) real(kind=8), public :: step real(kind=8), public :: stepv logical, public :: stopflash real(kind=8), public :: told real(kind=8), public :: told2 real(kind=8), public, dimension(n) :: varKold real(kind=8), public, dimension(n) :: var_K","tags":"","loc":"proc/flash.html"},{"title":"read_system – fenvelopes","text":"public subroutine read_system(filepath) Arguments Type Intent Optional Attributes Name character(len=*) :: filepath Calls proc~~read_system~~CallsGraph proc~read_system read_system proc~setup_input setup_input proc~read_system->proc~setup_input proc~read_model read_model proc~read_system->proc~read_model proc~read_components read_components proc~read_system->proc~read_components z z proc~read_model->z setup setup proc~read_model->setup proc~read_kij_lij read_kij_lij proc~read_components->proc~read_kij_lij proc~read_srk read_srk proc~read_components->proc~read_srk b b proc~read_components->b bij bij proc~read_components->bij proc~read_pr78 read_pr78 proc~read_components->proc~read_pr78 proc~read_pr76 read_pr76 proc~read_components->proc~read_pr76 lij lij proc~read_components->lij proc~read_kij_lij->lij kij kij proc~read_kij_lij->kij srk_factory srk_factory proc~read_srk->srk_factory pr78_factory pr78_factory proc~read_pr78->pr78_factory pr76_factory pr76_factory proc~read_pr76->pr76_factory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_system.html"},{"title":"setup_input – fenvelopes","text":"public subroutine setup_input(filepath) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filepath Setup input file to be used Called by proc~~setup_input~~CalledByGraph proc~setup_input setup_input proc~read_system read_system proc~read_system->proc~setup_input Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setup_input.html"},{"title":"write_system – fenvelopes","text":"public subroutine write_system(file_unit) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: file_unit Calls proc~~write_system~~CallsGraph proc~write_system write_system str str proc~write_system->str lij lij proc~write_system->lij kij kij proc~write_system->kij Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables fmt_names fmt_pure i Variables Type Visibility Attributes Name Initial character(len=20), private :: fmt_names character(len=20), private :: fmt_pure integer, private :: i","tags":"","loc":"proc/write_system.html"},{"title":"read_components – fenvelopes","text":"private subroutine read_components() Arguments None Calls proc~~read_components~~CallsGraph proc~read_components read_components proc~read_srk read_srk proc~read_components->proc~read_srk proc~read_kij_lij read_kij_lij proc~read_components->proc~read_kij_lij b b proc~read_components->b proc~read_pr78 read_pr78 proc~read_components->proc~read_pr78 bij bij proc~read_components->bij proc~read_pr76 read_pr76 proc~read_components->proc~read_pr76 lij lij proc~read_components->lij srk_factory srk_factory proc~read_srk->srk_factory proc~read_kij_lij->lij kij kij proc~read_kij_lij->kij pr78_factory pr78_factory proc~read_pr78->pr78_factory pr76_factory pr76_factory proc~read_pr76->pr76_factory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_components~~CalledByGraph proc~read_components read_components proc~read_system read_system proc~read_system->proc~read_components Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j","tags":"","loc":"proc/read_components.html"},{"title":"read_kij_lij – fenvelopes","text":"private subroutine read_kij_lij() Arguments None Calls proc~~read_kij_lij~~CallsGraph proc~read_kij_lij read_kij_lij kij kij proc~read_kij_lij->kij lij lij proc~read_kij_lij->lij Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_kij_lij~~CalledByGraph proc~read_kij_lij read_kij_lij proc~read_components read_components proc~read_components->proc~read_kij_lij proc~read_system read_system proc~read_system->proc~read_components Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j","tags":"","loc":"proc/read_kij_lij.html"},{"title":"read_model – fenvelopes","text":"private subroutine read_model() Reads the thermodynamic model to be used and sets up the selector Arguments None Calls proc~~read_model~~CallsGraph proc~read_model read_model setup setup proc~read_model->setup z z proc~read_model->z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_model~~CalledByGraph proc~read_model read_model proc~read_system read_system proc~read_system->proc~read_model Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j","tags":"","loc":"proc/read_model.html"},{"title":"read_pr76 – fenvelopes","text":"private subroutine read_pr76() Arguments None Calls proc~~read_pr76~~CallsGraph proc~read_pr76 read_pr76 pr76_factory pr76_factory proc~read_pr76->pr76_factory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_pr76~~CalledByGraph proc~read_pr76 read_pr76 proc~read_components read_components proc~read_components->proc~read_pr76 proc~read_system read_system proc~read_system->proc~read_components Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_pr76.html"},{"title":"read_pr78 – fenvelopes","text":"private subroutine read_pr78() Arguments None Calls proc~~read_pr78~~CallsGraph proc~read_pr78 read_pr78 pr78_factory pr78_factory proc~read_pr78->pr78_factory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_pr78~~CalledByGraph proc~read_pr78 read_pr78 proc~read_components read_components proc~read_components->proc~read_pr78 proc~read_system read_system proc~read_system->proc~read_components Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_pr78.html"},{"title":"read_srk – fenvelopes","text":"private subroutine read_srk() Read SRK model parameters Arguments None Calls proc~~read_srk~~CallsGraph proc~read_srk read_srk srk_factory srk_factory proc~read_srk->srk_factory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_srk~~CalledByGraph proc~read_srk read_srk proc~read_components read_components proc~read_components->proc~read_srk proc~read_system read_system proc~read_system->proc~read_components Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_srk.html"},{"title":"X2 – fenvelopes","text":"public function X2(kfact, P, T) result(X) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: kfact (nc) real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: T Return Value real(kind=pr)(nc+2) Contents Variables n Variables Type Visibility Attributes Name Initial integer, public :: n","tags":"","loc":"proc/x2.html"},{"title":"k_wilson – fenvelopes","text":"public function k_wilson(t, p) result(k) Uses legacy_ar_models proc~~k_wilson~~UsesGraph proc~k_wilson k_wilson legacy_ar_models legacy_ar_models proc~k_wilson->legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: p Return Value real(kind=pr)(size(pc)) Called by proc~~k_wilson~~CalledByGraph proc~k_wilson k_wilson proc~k_wilson_bubble k_wilson_bubble proc~k_wilson_bubble->proc~k_wilson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/k_wilson.html"},{"title":"p_wilson – fenvelopes","text":"public function p_wilson(z, t) result(p) Uses legacy_ar_models proc~~p_wilson~~UsesGraph proc~p_wilson p_wilson legacy_ar_models legacy_ar_models proc~p_wilson->legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: t Return Value real(kind=pr) Contents None","tags":"","loc":"proc/p_wilson.html"},{"title":"F2 – fenvelopes","text":"public subroutine F2(incipient, z, y, X, S, ns, F, dF) Arguments Type Intent Optional Attributes Name character(len=:), intent(in), allocatable :: incipient real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: y (nc) real(kind=pr), intent(in) :: X (nc+2) real(kind=pr), intent(in) :: S integer, intent(in) :: ns real(kind=pr), intent(out) :: F (nc+2) real(kind=pr), intent(out) :: dF (nc+2,nc+2) Calls proc~~f2~~CallsGraph proc~f2 F2 termo termo proc~f2->termo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~f2~~CalledByGraph proc~f2 F2 proc~envelope2 envelope2 proc~envelope2->proc~f2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables P T Vx Vy dlnphi_dn_x dlnphi_dn_y dlnphi_dp_x dlnphi_dp_y dlnphi_dt_x dlnphi_dt_y ix iy j lnfug_x lnfug_y n Variables Type Visibility Attributes Name Initial real(kind=pr), public :: P real(kind=pr), public :: T real(kind=pr), public :: Vx real(kind=pr), public :: Vy real(kind=pr), public :: dlnphi_dn_x (nc,nc) real(kind=pr), public :: dlnphi_dn_y (nc,nc) real(kind=pr), public :: dlnphi_dp_x (nc) real(kind=pr), public :: dlnphi_dp_y (nc) real(kind=pr), public :: dlnphi_dt_x (nc) real(kind=pr), public :: dlnphi_dt_y (nc) integer, public :: ix integer, public :: iy integer, public :: j real(kind=pr), public :: lnfug_x (nc) real(kind=pr), public :: lnfug_y (nc) integer, public :: n","tags":"","loc":"proc/f2.html"},{"title":"dFdS – fenvelopes","text":"public subroutine dFdS(dF_dS) Uses legacy_ar_models proc~~dfds~~UsesGraph proc~dfds dFdS legacy_ar_models legacy_ar_models proc~dfds->legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(out) :: dF_dS (nc+2) Called by proc~~dfds~~CalledByGraph proc~dfds dFdS proc~update_specification update_specification proc~update_specification->proc~dfds proc~envelope2 envelope2 proc~envelope2->proc~update_specification Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dfds.html"},{"title":"envelope2 – fenvelopes","text":"public subroutine envelope2(ichoice, n, z, T, P, KFACT, n_points, Tv, Pv, Dv, ncri, icri, Tcri, Pcri, Dcri, this_envelope) Uses dtypes linalg constants proc~~envelope2~~UsesGraph proc~envelope2 envelope2 module~dtypes dtypes proc~envelope2->module~dtypes module~linalg linalg proc~envelope2->module~linalg module~constants constants proc~envelope2->module~constants module~dtypes->module~constants io io module~dtypes->io module~linalg->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ichoice integer, intent(in) :: n real(kind=pr), intent(in) :: z (n) real(kind=pr) :: T real(kind=pr) :: P real(kind=pr), intent(inout) :: KFACT (n) integer, intent(out) :: n_points real(kind=pr), intent(out) :: Tv (max_points) real(kind=pr), intent(out) :: Pv (max_points) real(kind=pr), intent(out) :: Dv (max_points) integer, intent(out) :: ncri integer, intent(out), dimension(4) :: icri real(kind=pr), intent(out), dimension(4) :: Tcri (4) real(kind=pr), intent(out), dimension(4) :: Pcri (4) real(kind=pr), intent(out), dimension(4) :: Dcri (4) type( envelope ), intent(out) :: this_envelope Calls proc~~envelope2~~CallsGraph proc~envelope2 envelope2 delta_x delta_x proc~envelope2->delta_x m m proc~envelope2->m proc~f2 F2 proc~envelope2->proc~f2 proc~update_specification update_specification proc~envelope2->proc~update_specification proc~solve_system solve_system proc~envelope2->proc~solve_system proc~fix_delx fix_delx proc~envelope2->proc~fix_delx termo termo proc~f2->termo proc~update_specification->proc~solve_system proc~dfds dFdS proc~update_specification->proc~dfds none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables AJ F JAC S Told Told2 Vx X Xold Xold2 bd black_i critical_points dFdS dXdS delS delX delta_t extra_slope fname_env frac funit_output i incipient_phase iter ix iy lnK_extrapolated maxP max_iter minT minmaxT ns passingcri run stepx tmp_logk tmp_logphi y Variables Type Visibility Attributes Name Initial real(kind=pr), public, dimension(n + 2, n + 2) :: AJ real(kind=pr), public, dimension(n + 2) :: F real(kind=pr), public, dimension(n + 2, n + 2) :: JAC real(kind=pr), public :: S real(kind=pr), public :: Told real(kind=pr), public :: Told2 real(kind=pr), public :: Vx real(kind=pr), public, dimension(n + 2) :: X real(kind=pr), public, dimension(n + 2) :: Xold real(kind=pr), public, dimension(n + 2) :: Xold2 real(kind=pr), public, dimension(n + 2) :: bd integer, public :: black_i type( critical_point ), public, allocatable :: critical_points (:) real(kind=pr), public, dimension(n + 2) :: dFdS real(kind=pr), public, dimension(n + 2) :: dXdS real(kind=pr), public :: delS real(kind=pr), public, dimension(n + 2) :: delX real(kind=pr), public :: delta_t real(kind=pr), public :: extra_slope (n+2) character(len=254), public :: fname_env real(kind=pr), public :: frac integer, public :: funit_output integer, public :: i character(len=:), public, allocatable :: incipient_phase integer, public :: iter integer, public :: ix integer, public :: iy real(kind=pr), public :: lnK_extrapolated (n) real(kind=pr), public :: maxP integer, public :: max_iter logical, public :: minT logical, public :: minmaxT integer, public :: ns logical, public :: passingcri logical, public :: run real(kind=pr), public :: stepx real(kind=pr), public :: tmp_logk (max_points,n) real(kind=pr), public :: tmp_logphi (max_points,n) real(kind=pr), public, dimension(n) :: y","tags":"","loc":"proc/envelope2.html"},{"title":"fix_delx – fenvelopes","text":"public subroutine fix_delx(point, iterations, desired_iterations, first_tol, tol, delX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: point integer, intent(in) :: iterations integer, intent(in) :: desired_iterations real(kind=pr), intent(in) :: first_tol real(kind=pr), intent(in) :: tol real(kind=pr), intent(inout) :: delX (:) Called by proc~~fix_delx~~CalledByGraph proc~fix_delx fix_delx proc~envelope2 envelope2 proc~envelope2->proc~fix_delx Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fix_delx.html"},{"title":"k_wilson_bubble – fenvelopes","text":"public subroutine k_wilson_bubble(z, t, p, k) Uses legacy_ar_models proc~~k_wilson_bubble~~UsesGraph proc~k_wilson_bubble k_wilson_bubble legacy_ar_models legacy_ar_models proc~k_wilson_bubble->legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(inout) :: t real(kind=pr), intent(inout) :: p real(kind=pr), intent(out) :: k (size(z)) Calls proc~~k_wilson_bubble~~CallsGraph proc~k_wilson_bubble k_wilson_bubble proc~k_wilson k_wilson proc~k_wilson_bubble->proc~k_wilson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/k_wilson_bubble.html"},{"title":"update_specification – fenvelopes","text":"public subroutine update_specification(iter, passingcri, X, dF, ns, S, delS, dXdS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iter logical, intent(in) :: passingcri real(kind=pr), intent(in) :: X (nc+2) real(kind=pr), intent(in) :: dF (nc+2,nc+2) integer, intent(inout) :: ns real(kind=pr), intent(inout) :: S real(kind=pr), intent(inout) :: delS real(kind=pr), intent(inout) :: dXdS (nc+2) Calls proc~~update_specification~~CallsGraph proc~update_specification update_specification proc~dfds dFdS proc~update_specification->proc~dfds proc~solve_system solve_system proc~update_specification->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~update_specification~~CalledByGraph proc~update_specification update_specification proc~envelope2 envelope2 proc~envelope2->proc~update_specification Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables AJ bd dF_dS delmax nsold updel Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AJ (nc+2,nc+2) real(kind=pr), public :: bd (nc+2) real(kind=pr), public :: dF_dS (nc+2) real(kind=pr), public :: delmax integer, public :: nsold real(kind=pr), public :: updel","tags":"","loc":"proc/update_specification.html"},{"title":"F – fenvelopes","text":"interface public function F(X, ns, S) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S Return Value real(kind=pr)","tags":"","loc":"interface/f.html"},{"title":"break_conditions – fenvelopes","text":"public function break_conditions(X, ns, S) Arguments Type Intent Optional Attributes Name real(kind=pr) :: X (:) integer :: ns real(kind=pr) :: S Return Value logical,allocatable,(:) Called by proc~~break_conditions~~CalledByGraph proc~break_conditions break_conditions proc~injection_envelope injection_envelope proc~injection_envelope->proc~break_conditions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables alpha n p Variables Type Visibility Attributes Name Initial real(kind=pr), public :: alpha integer, public :: n real(kind=pr), public :: p","tags":"","loc":"proc/break_conditions.html"},{"title":"break_conditions_three_phases – fenvelopes","text":"public function break_conditions_three_phases(X, ns, S) Arguments Type Intent Optional Attributes Name real(kind=pr) :: X (:) integer :: ns real(kind=pr) :: S Return Value logical,allocatable,(:) Called by proc~~break_conditions_three_phases~~CalledByGraph proc~break_conditions_three_phases break_conditions_three_phases proc~injection_envelope_three_phase injection_envelope_three_phase proc~injection_envelope_three_phase->proc~break_conditions_three_phases Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables alpha n p Variables Type Visibility Attributes Name Initial real(kind=pr), public :: alpha integer, public :: n real(kind=pr), public :: p","tags":"","loc":"proc/break_conditions_three_phases.html"},{"title":"get_case – fenvelopes","text":"public function get_case(dew_envel, bub_envel) result(n_case) Arguments Type Intent Optional Attributes Name type( injelope ), intent(in) :: dew_envel type( injelope ), intent(in) :: bub_envel Return Value integer Contents None","tags":"","loc":"proc/get_case.html"},{"title":"F_injection – fenvelopes","text":"public subroutine F_injection(X, ns, S, F, df) Uses iso_fortran_env legacy_ar_models proc~~f_injection~~UsesGraph proc~f_injection F_injection iso_fortran_env iso_fortran_env proc~f_injection->iso_fortran_env legacy_ar_models legacy_ar_models proc~f_injection->legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (size(X)) real(kind=pr), intent(out) :: df (size(x),size(X)) Calls proc~~f_injection~~CallsGraph proc~f_injection F_injection proc~get_z get_z proc~f_injection->proc~get_z termo termo proc~f_injection->termo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables K P Vy Vz alpha dlnphi_dn_y dlnphi_dn_z dlnphi_dp_y dlnphi_dp_z dlnphi_dt_y dlnphi_dt_z dzda i j lnfug_y lnfug_z n y z Variables Type Visibility Attributes Name Initial real(kind=pr), public :: K (size(X)-2) real(kind=pr), public :: P real(kind=pr), public :: Vy real(kind=pr), public :: Vz real(kind=pr), public :: alpha real(kind=pr), public, dimension(size(X) - 2, size(X) - 2) :: dlnphi_dn_y real(kind=pr), public, dimension(size(X) - 2, size(X) - 2) :: dlnphi_dn_z real(kind=pr), public, dimension(size(X) - 2) :: dlnphi_dp_y real(kind=pr), public, dimension(size(X) - 2) :: dlnphi_dp_z real(kind=pr), public, dimension(size(X) - 2) :: dlnphi_dt_y real(kind=pr), public, dimension(size(X) - 2) :: dlnphi_dt_z real(kind=pr), public :: dzda (size(X)-2) integer, public :: i integer, public :: j real(kind=pr), public, dimension(size(X) - 2) :: lnfug_y real(kind=pr), public, dimension(size(X) - 2) :: lnfug_z integer, public :: n real(kind=pr), public, dimension(size(X) - 2) :: y real(kind=pr), public, dimension(size(X) - 2) :: z","tags":"","loc":"proc/f_injection.html"},{"title":"F_injection_three_phases – fenvelopes","text":"public subroutine F_injection_three_phases(Xvars, ns, S, F, df) Uses iso_fortran_env legacy_ar_models proc~~f_injection_three_phases~~UsesGraph proc~f_injection_three_phases F_injection_three_phases iso_fortran_env iso_fortran_env proc~f_injection_three_phases->iso_fortran_env legacy_ar_models legacy_ar_models proc~f_injection_three_phases->legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: Xvars (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (size(Xvars)) real(kind=pr), intent(out) :: df (size(Xvars),size(Xvars)) Calls proc~~f_injection_three_phases~~CallsGraph proc~f_injection_three_phases F_injection_three_phases proc~get_z get_z proc~f_injection_three_phases->proc~get_z termo termo proc~f_injection_three_phases->termo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables Kx Ky P Vw Vx Vy alpha beta dlnphi_dn_w dlnphi_dn_x dlnphi_dn_y dlnphi_dp_w dlnphi_dp_x dlnphi_dp_y dlnphi_dt_w dlnphi_dt_x dlnphi_dt_y dwdKx dwdKy dwda dwdb dxdKx dxdKy dydKx dydKy dzda i j lnfug_w lnfug_x lnfug_y n w x y z Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Kx (N) real(kind=pr), public :: Ky (N) real(kind=pr), public :: P real(kind=pr), public :: Vw real(kind=pr), public :: Vx real(kind=pr), public :: Vy real(kind=pr), public :: alpha real(kind=pr), public :: beta real(kind=pr), public, dimension(N, N) :: dlnphi_dn_w real(kind=pr), public, dimension(N, N) :: dlnphi_dn_x real(kind=pr), public, dimension(N, N) :: dlnphi_dn_y real(kind=pr), public, dimension(N) :: dlnphi_dp_w real(kind=pr), public, dimension(N) :: dlnphi_dp_x real(kind=pr), public, dimension(N) :: dlnphi_dp_y real(kind=pr), public, dimension(N) :: dlnphi_dt_w real(kind=pr), public, dimension(N) :: dlnphi_dt_x real(kind=pr), public, dimension(N) :: dlnphi_dt_y real(kind=pr), public :: dwdKx (N) real(kind=pr), public :: dwdKy (N) real(kind=pr), public :: dwda (N) real(kind=pr), public :: dwdb (N) real(kind=pr), public :: dxdKx (N) real(kind=pr), public :: dxdKy (N) real(kind=pr), public :: dydKx (N) real(kind=pr), public :: dydKy (N) real(kind=pr), public :: dzda (N) integer, public :: i integer, public :: j real(kind=pr), public, dimension(N) :: lnfug_w real(kind=pr), public, dimension(N) :: lnfug_x real(kind=pr), public, dimension(N) :: lnfug_y integer, public :: n real(kind=pr), public, dimension(N) :: w real(kind=pr), public, dimension(N) :: x real(kind=pr), public, dimension(N) :: y real(kind=pr), public :: z (N)","tags":"","loc":"proc/f_injection_three_phases.html"},{"title":"from_nml – fenvelopes","text":"public subroutine from_nml(filepath) Uses legacy_ar_models proc~~from_nml~~UsesGraph proc~from_nml from_nml legacy_ar_models legacy_ar_models proc~from_nml->legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filepath Contents Variables funit Variables Type Visibility Attributes Name Initial integer, public :: funit","tags":"","loc":"proc/from_nml.html"},{"title":"full_newton – fenvelopes","text":"public subroutine full_newton(fun, iters, X, ns, S, F, df) Arguments Type Intent Optional Attributes Name public subroutine fun(X, ns, S, F, dF) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (size(X)) real(kind=pr), intent(out) :: dF (size(X),size(X)) integer, intent(out) :: iters real(kind=pr), intent(inout) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (size(X)) real(kind=pr), intent(out) :: df (size(X),size(X)) Calls proc~~full_newton~~CallsGraph proc~full_newton full_newton proc~solve_system solve_system proc~full_newton->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~full_newton~~CalledByGraph proc~full_newton full_newton proc~injection_envelope injection_envelope proc~injection_envelope->proc~full_newton proc~injection_envelope_three_phase injection_envelope_three_phase proc~injection_envelope_three_phase->proc~full_newton Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables A b dX n tol Variables Type Visibility Attributes Name Initial real(kind=pr), public :: A (size(X),size(X)) real(kind=pr), public :: b (size(X)) real(kind=pr), public :: dX (size(X)) integer, public :: n real(kind=pr), public :: tol = 1e-5","tags":"","loc":"proc/full_newton.html"},{"title":"get_z – fenvelopes","text":"public subroutine get_z(alpha, z, dzda) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: alpha real(kind=pr), intent(out) :: z (size(z_0)) real(kind=pr), intent(out) :: dzda (size(z_0)) Called by proc~~get_z~~CalledByGraph proc~get_z get_z proc~f_injection F_injection proc~f_injection->proc~get_z proc~f_injection_three_phases F_injection_three_phases proc~f_injection_three_phases->proc~get_z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_z.html"},{"title":"injection_envelope – fenvelopes","text":"public subroutine injection_envelope(X0, spec_number, del_S0, envels) Uses constants proc~~injection_envelope~~UsesGraph proc~injection_envelope injection_envelope module~constants constants proc~injection_envelope->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X0 (:) integer, intent(in) :: spec_number real(kind=pr), intent(in) :: del_S0 type( injelope ), intent(out) :: envels Calls proc~~injection_envelope~~CallsGraph proc~injection_envelope injection_envelope proc~full_newton full_newton proc~injection_envelope->proc~full_newton xnew xnew proc~injection_envelope->xnew dfds dfds proc~injection_envelope->dfds knew knew proc~injection_envelope->knew proc~solve_system solve_system proc~injection_envelope->proc~solve_system proc~break_conditions break_conditions proc~injection_envelope->proc~break_conditions proc~full_newton->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables F S X XS cps dF dXdS fname_env funit_output i iters n ns point Variables Type Visibility Attributes Name Initial real(kind=pr), public :: F (size(X0)) real(kind=pr), public :: S real(kind=pr), public :: X (size(X0)) real(kind=pr), public :: XS (max_points,size(X0)) type( critical_point ), public, allocatable :: cps (:) real(kind=pr), public :: dF (size(X0),size(X0)) real(kind=pr), public :: dXdS (size(X0)) character(len=254), public :: fname_env integer, public :: funit_output integer, public :: i integer, public :: iters integer, public :: n integer, public :: ns integer, public :: point","tags":"","loc":"proc/injection_envelope.html"},{"title":"injection_envelope_three_phase – fenvelopes","text":"public subroutine injection_envelope_three_phase(X0, spec_number, del_S0, envels) Uses constants proc~~injection_envelope_three_phase~~UsesGraph proc~injection_envelope_three_phase injection_envelope_three_phase module~constants constants proc~injection_envelope_three_phase->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X0 (:) integer, intent(in) :: spec_number real(kind=pr), intent(in) :: del_S0 type( injelope ), intent(out) :: envels Calls proc~~injection_envelope_three_phase~~CallsGraph proc~injection_envelope_three_phase injection_envelope_three_phase proc~full_newton full_newton proc~injection_envelope_three_phase->proc~full_newton proc~break_conditions_three_phases break_conditions_three_phases proc~injection_envelope_three_phase->proc~break_conditions_three_phases xnew xnew proc~injection_envelope_three_phase->xnew dfds dfds proc~injection_envelope_three_phase->dfds knew knew proc~injection_envelope_three_phase->knew proc~solve_system solve_system proc~injection_envelope_three_phase->proc~solve_system dxds_in dxds_in proc~injection_envelope_three_phase->dxds_in proc~full_newton->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables F S X XS cps dF dXdS fname_env funit_output i iters n ns point Variables Type Visibility Attributes Name Initial real(kind=pr), public :: F (size(X0)) real(kind=pr), public :: S real(kind=pr), public :: X (size(X0)) real(kind=pr), public :: XS (max_points,size(X0)) type( critical_point ), public, allocatable :: cps (:) real(kind=pr), public :: dF (size(X0),size(X0)) real(kind=pr), public :: dXdS (size(X0)) character(len=254), public :: fname_env integer, public :: funit_output integer, public :: i integer, public :: iters integer, public :: n integer, public :: ns integer, public :: point","tags":"","loc":"proc/injection_envelope_three_phase.html"},{"title":"dtypes – fenvelopes","text":"Uses io constants module~~dtypes~~UsesGraph module~dtypes dtypes io io module~dtypes->io module~constants constants module~dtypes->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~dtypes~~UsedByGraph module~dtypes dtypes proc~envelope2 envelope2 proc~envelope2->module~dtypes module~inj_envelopes inj_envelopes module~inj_envelopes->module~dtypes module~envelopes envelopes module~envelopes->module~dtypes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types critical_point env3 envelope Subroutines print_header write_critical_points write_envel_2 write_envel_3 Derived Types type, public :: critical_point Components Type Visibility Attributes Name Initial real(kind=pr), private :: alpha real(kind=pr), private :: p real(kind=pr), private :: t type, public, extends( envelope ) :: env3 Components Type Visibility Attributes Name Initial real(kind=pr), private, allocatable :: beta (:) type( critical_point ), private, allocatable :: ll_critical_points (:) real(kind=pr), private, allocatable :: logks (:,:) real(kind=pr), private, allocatable :: w (:,:) real(kind=pr), private, allocatable :: x (:,:) real(kind=pr), private, allocatable :: y (:,:) Type-Bound Procedures procedure, public :: write => write_envel_3 type, public :: envelope Components Type Visibility Attributes Name Initial type( critical_point ), private, allocatable :: critical_points (:) real(kind=pr), private, allocatable :: logk (:,:) real(kind=pr), private, allocatable :: logphi (:,:) real(kind=pr), private, allocatable :: p (:) real(kind=pr), private, allocatable :: t (:) real(kind=pr), private, allocatable :: vars (:,:) real(kind=pr), private, allocatable :: z (:) Type-Bound Procedures procedure, public :: write => write_envel_2 Subroutines public subroutine print_header (name) Arguments Type Intent Optional Attributes Name character(len=250), intent(in) :: name private subroutine write_critical_points (self, file_name) Arguments Type Intent Optional Attributes Name type( critical_point ), intent(in) :: self (:) character(len=*), intent(in), optional :: file_name private subroutine write_envel_2 (self, file_name) Arguments Type Intent Optional Attributes Name class( envelope ), intent(in) :: self character(len=*), intent(in), optional :: file_name private subroutine write_envel_3 (self, file_name) Arguments Type Intent Optional Attributes Name class( env3 ), intent(in) :: self character(len=*), intent(in), optional :: file_name","tags":"","loc":"module/dtypes.html"},{"title":"linalg – fenvelopes","text":"Uses constants module~~linalg~~UsesGraph module~linalg linalg module~constants constants module~linalg->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~linalg~~UsedByGraph module~linalg linalg proc~envelope2 envelope2 proc~envelope2->module~linalg module~inj_envelopes inj_envelopes module~inj_envelopes->module~linalg module~envelopes envelopes module~envelopes->module~linalg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces intersection Derived Types point Functions interpol intersect_one_line intersect_two_lines solve_system Subroutines intersects Interfaces public interface intersection public function intersect_two_lines (l1_x, l1_y, l2_x, l2_y) result(intersections) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: l1_x (:) real(kind=pr), intent(in) :: l1_y (:) real(kind=pr), intent(in) :: l2_x (:) real(kind=pr), intent(in) :: l2_y (:) Return Value type( point ),allocatable, (:) public function intersect_one_line (lx, ly) result(intersections) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lx (:) real(kind=pr), intent(in) :: ly (:) Return Value type( point ),allocatable, (:) Derived Types type, public :: point Components Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=pr), public :: x real(kind=pr), public :: y Functions public elemental function interpol (x1, x2, y1, y2, x_obj) result(y) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x1 real(kind=pr), intent(in) :: x2 real(kind=pr), intent(in) :: y1 real(kind=pr), intent(in) :: y2 real(kind=pr), intent(in) :: x_obj Return Value real(kind=pr) public function intersect_one_line (lx, ly) result(intersections) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lx (:) real(kind=pr), intent(in) :: ly (:) Return Value type( point ),allocatable, (:) public function intersect_two_lines (l1_x, l1_y, l2_x, l2_y) result(intersections) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: l1_x (:) real(kind=pr), intent(in) :: l1_y (:) real(kind=pr), intent(in) :: l2_x (:) real(kind=pr), intent(in) :: l2_y (:) Return Value type( point ),allocatable, (:) public function solve_system (a, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: a (size(b),size(b)) real(kind=pr), intent(inout) :: b (:) Return Value real(kind=pr)(size(b)) Subroutines public subroutine intersects (x1, x2, x3, x4, y1, y2, y3, y4, s, t) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x1 real(kind=pr), intent(in) :: x2 real(kind=pr), intent(in) :: x3 real(kind=pr), intent(in) :: x4 real(kind=pr), intent(in) :: y1 real(kind=pr), intent(in) :: y2 real(kind=pr), intent(in) :: y3 real(kind=pr), intent(in) :: y4 real(kind=pr), intent(out) :: s real(kind=pr), intent(out) :: t","tags":"","loc":"module/linalg.html"},{"title":"phase_equilibria – fenvelopes","text":"Uses constants legacy_ar_models module~~phase_equilibria~~UsesGraph module~phase_equilibria phase_equilibria module~constants constants module~phase_equilibria->module~constants legacy_ar_models legacy_ar_models module~phase_equilibria->legacy_ar_models iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines betalimits betato01 flash Subroutines public subroutine betalimits (n, z, KFACT, bmin, bmax) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=8), intent(in), dimension(n) :: z real(kind=8), intent(in), dimension(n) :: KFACT real(kind=8), intent(out) :: bmin real(kind=8), intent(out) :: bmax public subroutine betato01 (n, z, KFACT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=8), intent(in), dimension(n) :: z real(kind=8), dimension(n) :: KFACT public subroutine flash (spec, FIRST, z, t, p, v, x, y, rho_x, rho_y, beta, iter) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: spec logical, intent(inout) :: FIRST real(kind=8), intent(in) :: z (:) real(kind=8), intent(in) :: t real(kind=8) :: p real(kind=8) :: v real(kind=8), intent(out), dimension(size(z)) :: x real(kind=8), intent(out), dimension(size(z)) :: y real(kind=8), intent(out) :: rho_x real(kind=8), intent(out) :: rho_y real(kind=8), intent(out) :: beta integer, intent(out) :: iter","tags":"","loc":"module/phase_equilibria.html"},{"title":"io_nml – fenvelopes","text":"Uses io constants legacy_ar_models module~~io_nml~~UsesGraph module~io_nml io_nml io io module~io_nml->io module~constants constants module~io_nml->module~constants legacy_ar_models legacy_ar_models module~io_nml->legacy_ar_models iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables mixrule model names nunit_input path_to_file spec Subroutines read_system setup_input write_system read_components read_kij_lij read_model read_pr76 read_pr78 read_srk Variables Type Visibility Attributes Name Initial character(len=50), public :: mixrule character(len=50), public :: model character(len=50), public, allocatable :: names (:) integer, public :: nunit_input character(len=254), public :: path_to_file character(len=50), public :: spec Subroutines public subroutine read_system (filepath) Arguments Type Intent Optional Attributes Name character(len=*) :: filepath public subroutine setup_input (filepath) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filepath Setup input file to be used public subroutine write_system (file_unit) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: file_unit private subroutine read_components () Arguments None private subroutine read_kij_lij () Arguments None private subroutine read_model () Reads the thermodynamic model to be used and sets up the selector Arguments None private subroutine read_pr76 () Arguments None private subroutine read_pr78 () Arguments None private subroutine read_srk () Read SRK model parameters Arguments None","tags":"","loc":"module/io_nml.html"},{"title":"constants – fenvelopes","text":"Uses iso_fortran_env module~~constants~~UsesGraph module~constants constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~constants~~UsedByGraph module~constants constants proc~envelope2 envelope2 proc~envelope2->module~constants module~linalg linalg proc~envelope2->module~linalg module~dtypes dtypes proc~envelope2->module~dtypes module~phase_equilibria phase_equilibria module~phase_equilibria->module~constants module~linalg->module~constants module~dtypes->module~constants proc~injection_envelope_three_phase injection_envelope_three_phase proc~injection_envelope_three_phase->module~constants proc~injection_envelope injection_envelope proc~injection_envelope->module~constants module~io_nml io_nml module~io_nml->module~constants module~envelopes envelopes module~envelopes->module~constants module~envelopes->module~linalg module~envelopes->module~dtypes module~inj_envelopes inj_envelopes module~inj_envelopes->module~constants module~inj_envelopes->module~linalg module~inj_envelopes->module~dtypes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables R database_path ouput_path path_sep pr Variables Type Visibility Attributes Name Initial real(kind=pr), public, parameter :: R = 0.08314472 character(len=254), public :: database_path = \"database/\" character(len=254), public :: ouput_path = \"fenvelopes_output/\" character(len=1), public :: path_sep = \"/\" integer, public, parameter :: pr = real64","tags":"","loc":"module/constants.html"},{"title":"envelopes – fenvelopes","text":"Uses dtypes linalg constants legacy_ar_models module~~envelopes~~UsesGraph module~envelopes envelopes module~dtypes dtypes module~envelopes->module~dtypes module~linalg linalg module~envelopes->module~linalg module~constants constants module~envelopes->module~constants legacy_ar_models legacy_ar_models module~envelopes->legacy_ar_models module~dtypes->module~constants io io module~dtypes->io module~linalg->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables env_number max_points Interfaces F Functions X2 k_wilson p_wilson Subroutines F2 dFdS envelope2 fix_delx k_wilson_bubble update_specification Variables Type Visibility Attributes Name Initial integer, public :: env_number = 0 integer, public, parameter :: max_points = 2000 Interfaces interface public function F(X, ns, S) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S Return Value real(kind=pr) Functions public function X2 (kfact, P, T) result(X) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: kfact (nc) real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: T Return Value real(kind=pr)(nc+2) public function k_wilson (t, p) result(k) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: p Return Value real(kind=pr)(size(pc)) public function p_wilson (z, t) result(p) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: t Return Value real(kind=pr) Subroutines public subroutine F2 (incipient, z, y, X, S, ns, F, dF) Arguments Type Intent Optional Attributes Name character(len=:), intent(in), allocatable :: incipient real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: y (nc) real(kind=pr), intent(in) :: X (nc+2) real(kind=pr), intent(in) :: S integer, intent(in) :: ns real(kind=pr), intent(out) :: F (nc+2) real(kind=pr), intent(out) :: dF (nc+2,nc+2) public subroutine dFdS (dF_dS) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(out) :: dF_dS (nc+2) public subroutine envelope2 (ichoice, n, z, T, P, KFACT, n_points, Tv, Pv, Dv, ncri, icri, Tcri, Pcri, Dcri, this_envelope) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ichoice integer, intent(in) :: n real(kind=pr), intent(in) :: z (n) real(kind=pr) :: T real(kind=pr) :: P real(kind=pr), intent(inout) :: KFACT (n) integer, intent(out) :: n_points real(kind=pr), intent(out) :: Tv (max_points) real(kind=pr), intent(out) :: Pv (max_points) real(kind=pr), intent(out) :: Dv (max_points) integer, intent(out) :: ncri integer, intent(out), dimension(4) :: icri real(kind=pr), intent(out), dimension(4) :: Tcri (4) real(kind=pr), intent(out), dimension(4) :: Pcri (4) real(kind=pr), intent(out), dimension(4) :: Dcri (4) type( envelope ), intent(out) :: this_envelope public subroutine fix_delx (point, iterations, desired_iterations, first_tol, tol, delX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: point integer, intent(in) :: iterations integer, intent(in) :: desired_iterations real(kind=pr), intent(in) :: first_tol real(kind=pr), intent(in) :: tol real(kind=pr), intent(inout) :: delX (:) public subroutine k_wilson_bubble (z, t, p, k) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(inout) :: t real(kind=pr), intent(inout) :: p real(kind=pr), intent(out) :: k (size(z)) public subroutine update_specification (iter, passingcri, X, dF, ns, S, delS, dXdS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iter logical, intent(in) :: passingcri real(kind=pr), intent(in) :: X (nc+2) real(kind=pr), intent(in) :: dF (nc+2,nc+2) integer, intent(inout) :: ns real(kind=pr), intent(inout) :: S real(kind=pr), intent(inout) :: delS real(kind=pr), intent(inout) :: dXdS (nc+2)","tags":"","loc":"module/envelopes.html"},{"title":"inj_envelopes – fenvelopes","text":"Uses dtypes linalg constants module~~inj_envelopes~~UsesGraph module~inj_envelopes inj_envelopes module~dtypes dtypes module~inj_envelopes->module~dtypes module~linalg linalg module~inj_envelopes->module~linalg module~constants constants module~inj_envelopes->module~constants module~dtypes->module~constants io io module~dtypes->io module~linalg->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables T del_S env_number injection_case max_iters max_points z_0 z_injection Derived Types injelope Functions break_conditions break_conditions_three_phases get_case Subroutines F_injection F_injection_three_phases from_nml full_newton get_z injection_envelope injection_envelope_three_phase Variables Type Visibility Attributes Name Initial real(kind=pr), public :: T real(kind=pr), public :: del_S = 0.1 integer, public :: env_number = 0 character(len=10), public :: injection_case integer, public :: max_iters = 500 integer, public, parameter :: max_points = 1000 real(kind=pr), public, allocatable :: z_0 (:) real(kind=pr), public, allocatable :: z_injection (:) Derived Types type, public, extends( envelope ) :: injelope Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: alpha (:) real(kind=pr), public, allocatable :: z_inj (:) real(kind=pr), public, allocatable :: z_mix (:,:) Type-Bound Procedures procedure, public :: write => write_envel_2 Functions public function break_conditions (X, ns, S) Arguments Type Intent Optional Attributes Name real(kind=pr) :: X (:) integer :: ns real(kind=pr) :: S Return Value logical,allocatable, (:) public function break_conditions_three_phases (X, ns, S) Arguments Type Intent Optional Attributes Name real(kind=pr) :: X (:) integer :: ns real(kind=pr) :: S Return Value logical,allocatable, (:) public function get_case (dew_envel, bub_envel) result(n_case) Arguments Type Intent Optional Attributes Name type( injelope ), intent(in) :: dew_envel type( injelope ), intent(in) :: bub_envel Return Value integer Subroutines public subroutine F_injection (X, ns, S, F, df) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (size(X)) real(kind=pr), intent(out) :: df (size(x),size(X)) public subroutine F_injection_three_phases (Xvars, ns, S, F, df) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: Xvars (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (size(Xvars)) real(kind=pr), intent(out) :: df (size(Xvars),size(Xvars)) public subroutine from_nml (filepath) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filepath public subroutine full_newton (fun, iters, X, ns, S, F, df) Arguments Type Intent Optional Attributes Name public subroutine fun(X, ns, S, F, dF) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (size(X)) real(kind=pr), intent(out) :: dF (size(X),size(X)) integer, intent(out) :: iters real(kind=pr), intent(inout) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (size(X)) real(kind=pr), intent(out) :: df (size(X),size(X)) public subroutine get_z (alpha, z, dzda) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: alpha real(kind=pr), intent(out) :: z (size(z_0)) real(kind=pr), intent(out) :: dzda (size(z_0)) public subroutine injection_envelope (X0, spec_number, del_S0, envels) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X0 (:) integer, intent(in) :: spec_number real(kind=pr), intent(in) :: del_S0 type( injelope ), intent(out) :: envels public subroutine injection_envelope_three_phase (X0, spec_number, del_S0, envels) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X0 (:) integer, intent(in) :: spec_number real(kind=pr), intent(in) :: del_S0 type( injelope ), intent(out) :: envels","tags":"","loc":"module/inj_envelopes.html"},{"title":"types.f90 – fenvelopes","text":"This file depends on sourcefile~~types.f90~~EfferentGraph sourcefile~types.f90 types.f90 sourcefile~constants.f90 constants.f90 sourcefile~types.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~types.f90~~AfferentGraph sourcefile~types.f90 types.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~envelopes.f90->sourcefile~types.f90 sourcefile~mod_inj_envelopes.f90 mod_inj_envelopes.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules dtypes Source Code types.f90 Source Code module dtypes use constants , only : pr use io implicit none private public :: envelope public :: env3 public :: print_header public :: critical_point type :: critical_point real ( pr ) :: t real ( pr ) :: p real ( pr ) :: alpha end type critical_point type :: envelope real ( pr ), allocatable :: vars (:, :) !! Value of the set of variables at each point real ( pr ), allocatable :: z (:) !! Global composition real ( pr ), allocatable :: t (:) !! Temperature points real ( pr ), allocatable :: p (:) !! Pressure points real ( pr ), allocatable :: logk (:, :) !! ln(K) for each point real ( pr ), allocatable :: logphi (:, :) !! lnphi for each point type ( critical_point ), allocatable :: critical_points (:) !! Critical points contains procedure :: write => write_envel_2 end type envelope type , extends ( envelope ) :: env3 real ( pr ), allocatable :: beta (:) !! Other phase fraction real ( pr ), allocatable :: x (:, :) !! real ( pr ), allocatable :: y (:, :) !! real ( pr ), allocatable :: w (:, :) !! real ( pr ), allocatable :: logks (:, :) !! ln(Ks) type ( critical_point ), allocatable :: ll_critical_points (:) contains procedure :: write => write_envel_3 end type env3 contains subroutine write_critical_points ( self , file_name ) type ( critical_point ), intent ( in ) :: self (:) character ( len =* ), optional , intent ( in ) :: file_name !! Ouptut file name character ( len = :), allocatable :: filename integer :: file_unit integer :: i if ( present ( file_name )) then filename = file_name else filename = \"CP\" end if open ( newunit = file_unit , file = filename ) write ( file_unit , \"(A)\" ) \"P            T\" do i = 1 , size ( self ) write ( file_unit , \"(2(E10.5,2x))\" ) self ( i )% t , self ( i )% p end do close ( file_unit ) end subroutine subroutine write_envel_2 ( self , file_name ) class ( envelope ), intent ( in ) :: self character ( len =* ), optional , intent ( in ) :: file_name !! Ouptut file name character ( len = :), allocatable :: filename integer :: i , n , file_unit , n_components if ( present ( file_name )) then filename = file_name else filename = \"envelout-2phase\" end if n = size ( self % t ) n_components = size ( self % z ) associate ( t => self % t , p => self % p , & logk => self % logk , & z => self % z & ) open ( newunit = file_unit , file = filename ) write ( file_unit , * ) & \"P \" , \"T \" , ( \"K\" // str ( i ), i = 1 , n_components ), & ( \"z\" // str ( i ), i = 1 , n_components ) do i = 1 , n write ( file_unit , * ) p ( i ), t ( i ), logk ( i , :), z end do close ( file_unit ) end associate ! Write Critical Points file ! filename = filename // \"-CP\" ! call write_critical_points(self%critical_points, filename) deallocate ( filename ) end subroutine write_envel_2 subroutine write_envel_3 ( self , file_name ) class ( env3 ), intent ( in ) :: self character ( len =* ), optional , intent ( in ) :: file_name character ( len = :), allocatable :: filename integer :: i , n , file_unit , n_components if ( present ( file_name )) then filename = file_name else filename = \"envelout-3phase\" end if n_components = size ( self % z ) associate ( t => self % t , p => self % p , & logk => self % logk , logks => self % logks , & x => self % x , y => self % y , w => self % w , beta => self % beta & ) n = size ( self % t ) open ( newunit = file_unit , file = filename ) write ( file_unit , * ) & \"P \" , \"T \" , \"beta \" , & ( \"K\" // str ( i ), i = 1 , n_components ), & ( \"KS\" // str ( i ), i = 1 , n_components ), & ( \"x\" // str ( i ), i = 1 , n_components ), & ( \"y\" // str ( i ), i = 1 , n_components ), & ( \"w\" // str ( i ), i = 1 , n_components ) do i = 1 , n write ( file_unit , * ) p ( i ), t ( i ), beta ( i ), logk ( i , :), logks ( i , :), x ( i , :), y ( i , :), w ( i , :) end do close ( file_unit ) end associate ! Write Critical Points file filename = filename // \"-CP\" call write_critical_points ( self % critical_points , filename ) deallocate ( filename ) end subroutine write_envel_3 subroutine print_header ( name ) character ( len = 250 ), intent ( in ) :: name print * , \"===================================\" print * , \"!\" , name print * , \"-----------------------------------\" end subroutine print_header end module dtypes","tags":"","loc":"sourcefile/types.f90.html"},{"title":"linalg.f90 – fenvelopes","text":"This file depends on sourcefile~~linalg.f90~~EfferentGraph sourcefile~linalg.f90 linalg.f90 sourcefile~constants.f90 constants.f90 sourcefile~linalg.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~linalg.f90~~AfferentGraph sourcefile~linalg.f90 linalg.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~envelopes.f90->sourcefile~linalg.f90 sourcefile~mod_inj_envelopes.f90 mod_inj_envelopes.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~linalg.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules linalg Source Code linalg.f90 Source Code module linalg !! Wrapper module around LAPACK's `dgesv` and lines intersections detector use constants , only : pr implicit none type :: point real ( pr ) :: x real ( pr ) :: y integer :: i integer :: j end type point interface intersection module procedure :: intersect_two_lines module procedure :: intersect_one_line end interface contains function solve_system ( a , b ) result ( x ) real ( pr ), intent ( in out ) :: b (:) real ( pr ), intent ( in out ) :: a ( size ( b ), size ( b )) real ( pr ) :: x ( size ( b )) real ( 8 ) :: a_lapack ( size ( b ), size ( b )), b_lapack ( size ( b )) integer :: n , nrhs , lda , ipiv ( size ( b )), ldb , info interface subroutine dgesv ( n , nrhs , a , lda , ipiv , b , ldb , info ) integer :: n integer :: nrhs real ( 8 ) :: a ( n , n ) integer :: lda integer :: ipiv ( n ) real ( 8 ) :: b ( n ) integer :: ldb integer :: info end subroutine end interface n = size ( a , dim = 1 ) nrhs = 1 lda = n ldb = n a_lapack = a b_lapack = b call dgesv ( n , nrhs , a_lapack , lda , ipiv , b_lapack , ldb , info ) x = b_lapack end function solve_system function intersect_two_lines ( l1_x , l1_y , l2_x , l2_y ) result ( intersections ) real ( pr ), intent ( in ) :: l1_x (:), l1_y (:), l2_x (:), l2_y (:) type ( point ), allocatable :: intersections (:) real ( pr ) :: s , t integer :: i , j real ( pr ) :: x , y , xold = 9999 , yold = 9999 allocate ( intersections ( 0 )) line1 : do i = 2 , size ( l1_x ) line2 : do j = 2 , size ( l2_x ) associate ( & x1 => l1_x ( i - 1 ), x2 => l1_x ( i ), & x3 => l2_x ( j - 1 ), x4 => l2_x ( j ), & y1 => l1_y ( i - 1 ), y2 => l1_y ( i ), & y3 => l2_y ( j - 1 ), y4 => l2_y ( j )) call intersects ( x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4 , s , t ) if ( 0 <= s . and . s <= 1 . and . 0 <= t . and . t <= 1 ) then x = s * ( x2 - x1 ) + x1 y = s * ( y2 - y1 ) + y1 if ( & abs (( x - xold )) > 1e-5_pr . and . abs (( y - yold )) > 1e-5_pr & ) then xold = x yold = y intersections = [ intersections , point ( x , y , i , j )] exit line2 end if end if end associate end do line2 end do line1 end function function intersect_one_line ( lx , ly ) result ( intersections ) real ( pr ), intent ( in ) :: lx (:), ly (:) type ( point ), allocatable :: intersections (:) real ( pr ) :: s , t integer :: i , j real ( pr ) :: x , y , xold = 9999 , yold = 9999 allocate ( intersections ( 0 )) line1 : do i = 2 , size ( lx ) - 1 line2 : do j = i + 15 , size ( lx ) associate ( & x1 => lx ( i - 1 ), x2 => lx ( i ), & x3 => lx ( j ), x4 => lx ( j - 1 ), & y1 => ly ( i - 1 ), y2 => ly ( i ), & y3 => ly ( j ), y4 => ly ( j - 1 )) call intersects ( x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4 , s , t ) if ( 0 <= s . and . s <= 1 . and . 0 <= t . and . t <= 1 ) then x = s * ( x2 - x1 ) + x1 y = s * ( y2 - y1 ) + y1 if ( abs ( x - xold ) > 1 . and . abs ( y - yold ) > 1 ) then xold = x yold = y ! Use earliest point for the \"other\" line intersections = [ intersections , point ( x , y , i , j - 1 )] end if end if end associate end do line2 end do line1 end function subroutine intersects ( x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4 , s , t ) real ( pr ), intent ( in ) :: x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4 real ( pr ), intent ( out ) :: s , t real ( pr ) :: A ( 2 , 2 ), b ( 2 ), tmp A ( 1 , :) = [ x2 - x1 , x3 - x4 ] A ( 2 , :) = [ y2 - y1 , y3 - y4 ] b = [ x3 - x1 , y3 - y1 ] b = solve_system ( a , b ) s = b ( 1 ) t = b ( 2 ) end subroutine elemental function interpol ( x1 , x2 , y1 , y2 , x_obj ) result ( y ) !! Linear interpolation. !! !! Calculates the linear interpolation between two points at a desired !! x value with the equation: !!  !!    y = \\frac{y_2 - y_1}{x_2 - x_1} \\cdot (x_{obj})  - x_1 + y_1 !!  !! !! Since this function is defined as `elemental` it will also interpolate !! a set of vectors. !! !! Examples of usage: !! !! ```fortran !! x1 = 2 !! x2 = 5 !! y1 = 2 !! y2 = 9 !! y = interpol(x1, x2, y1, y2, 2.3) !! ``` !! !! ```fortran !! x1 = 2 !! x2 = 5 !! y1 = [2, 6] !! y2 = [9, 15] !! y = interpol(x1, x2, y1, y2, 2.3) !! ``` real ( pr ), intent ( in ) :: x1 !! First point x value real ( pr ), intent ( in ) :: x2 !! Second point x value real ( pr ), intent ( in ) :: y1 !! First point y value real ( pr ), intent ( in ) :: y2 !! Second point y value real ( pr ), intent ( in ) :: x_obj !! Desired x value to interpolate real ( pr ) :: y !! y value at `x_obj` y = ( y2 - y1 ) / ( x2 - x1 ) * ( x_obj - x1 ) + y1 end function end module linalg","tags":"","loc":"sourcefile/linalg.f90.html"},{"title":"Flash.f90 – fenvelopes","text":"This file depends on sourcefile~~flash.f90~~EfferentGraph sourcefile~flash.f90 Flash.f90 sourcefile~constants.f90 constants.f90 sourcefile~flash.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules phase_equilibria Source Code Flash.f90 Source Code module phase_equilibria use constants , only : pr use legacy_ar_models , only : zTVTERMO , termo , n => nc , omg => w , tc , pc implicit none contains subroutine flash ( spec , FIRST , z , t , p , v , x , y , rho_x , rho_y , beta , iter ) ! Flash specification, eos id and  number of compounds in the system character ( len =* ), intent ( in ) :: spec !! Flash specification [PT | VT] logical , intent ( in out ) :: FIRST logical :: stopflash ! composition of the system real * 8 , intent ( in ) :: z (:) ! Temperature and Pressure for the flash real * 8 , intent ( in ) :: t ! Temperature for the flash (K) real * 8 :: p ! (bar) Pressure for the flash (TP) or resulting from (TV) real * 8 :: v ! (L/mol) Molar vol for the flash (TV) or resulting from (TP) ! Results from flash calculation real * 8 , dimension ( size ( z )), intent ( out ) :: x ! composition of liquid (molar fractions) real * 8 , dimension ( size ( z )), intent ( out ) :: y ! composition of vapour (molar fractions) real * 8 , intent ( out ) :: rho_x ! density of liquid (moles/L) real * 8 , intent ( out ) :: rho_y ! density of vapour (moles/L) real * 8 , intent ( out ) :: beta ! total fraction of vapour (molar base) integer , intent ( out ) :: iter ! number of iterations required to converge ! Intermediate variables during calculation process real * 8 , dimension ( n ) :: PHILOGy , PHILOGx , DLPHIT , DLPHIP real * 8 , dimension ( n ) :: KFACT , LOG_K , AUXK , var_K , denom , varKold , logKold real * 8 , dimension ( n , n ) :: FUGN real * 8 :: g0 , g1 ! function g valuated at beta=0 and 1, based on Wilson K factors real * 8 :: g , dg , bmin , bmax , Vy , Vx ! real*8, dimension(nco, nco) :: Kij_or_K0, Tstar ! real*8, dimension(nco) :: saveK, LOG_K2 real ( 8 ) :: aux , bx , savek ( n ), log_k2 ( n ) integer :: MTYP real ( 8 ) :: dh , dpv , DPVl , dpvv , dVydVl , h , pl , pold , pold2 , pv , step , stepv real ( 8 ) :: told , told2 , bij ( n , n ) integer :: i , j , iterv , nco ! do i = 1, n !    do j = i, n !       bij(i, j) = (1 - lij(i, j))*(b(i) + b(j))/2 !       bij(j, i) = bij(i, j) !    end do ! end do ! !----------------------------------------------------------- ! This algorithm assumes that the specified T and P correspond to ! vapor-liquid separation predicted by the provided model (0<beta<1) if ( spec == 'TV' . or . spec == 'isoV' ) then Vx = 0.0 if ( FIRST ) then ! the EoS one-phase pressure will be used to estimate Wilson K factors call zTVTERMO ( n , 0 , T , z , V , P , DPV , PHILOGy , DLPHIP , DLPHIT , FUGN ) if ( P < 0 ) P = 1.0 end if end if AUXK = log ( saveK ( 1 : n )) if ( FIRST ) then !  use Wilson to initiate the first flash KFACT = ( PC / P ) * exp ( 5.373 * ( 1 + omg ) * ( 1 - TC / T )) Pold2 = 0.d0 Pold = 0.d0 Told2 = 0.d0 Told = 0.d0 else !  for running the indirect \"Tv flash\" for comparisonn purposes !        else if(Pold2==0.d0.or.spec=='TV')then ! use the converged K's from the previous flash KFACT = saveK ( 1 : n ) !        else ! use extrapolation based on the last two points (not resolved yet for series of TV flashes) !            if(spec=='isoV')    LOG_K = AUXK + (AUXK - LOG_K2) !            if(spec=='TP'.and.P/=Pold)      LOG_K = AUXK + (AUXK - LOG_K2)*(P-Pold)/(Pold-Pold2) !            if(spec=='TP'.and.T/=Told)      LOG_K = AUXK + (AUXK - LOG_K2)*(T-Told)/(Told-Told2) !            KFACT = EXP(LOG_K) end if LOG_K2 (: n ) = AUXK Pold2 = Pold Pold = P Told2 = Told Told = T ! WRITE (2,3) (KFACT(i),i=1,N) call betato01 ( n , z , KFACT ) ! adapted 26/11/2014 LOG_K = log ( KFACT ) ! now we must have  g0>0 and g1<0 and therefore 0<beta<1 (M&M page 252) call betalimits ( n , z , KFACT , bmin , bmax ) beta = ( bmin + bmax ) / 2 ! first guess for beta ! Succesive sustitution loop starts here var_K = 1.0 iter = 0 do while ( maxval ( abs ( var_K )) > 1.d-6 ) if ( maxval ( abs ( var_K )) > 1.10 ) then ! 26/11/2014 g0 = sum ( z * KFACT ) - 1.D0 g1 = 1.D0 - sum ( z / KFACT ) if ( g0 < 0 . or . g1 > 0 ) then ! bring beta back to range, by touching KFACT call betato01 ( n , z , KFACT ) call betalimits ( n , z , KFACT , bmin , bmax ) beta = ( bmin + bmax ) / 2 ! new guess for beta end if end if iter = iter + 1 ! Newton starts here (Rachford-Rice) g = 1.0 step = 1.0 do while ( abs ( g ) > 1.d-5 . and . abs ( step ) > 1.d-10 ) denom = 1 + beta * ( KFACT - 1.D0 ) g = sum ( z * ( KFACT - 1.D0 ) / denom ) dg = - sum ( z * ( KFACT - 1.D0 ) ** 2 / denom ** 2 ) step = - g / dg beta = beta + step do while (( beta < bmin . or . bmax < beta ) . and . step > 1e-10 ) ! much better (GUARANTED!) 3/3/15 step = step / 2 beta = beta - step end do end do denom = 1 + beta * ( KFACT - 1.D0 ) y = z * KFACT / denom x = y / KFACT ! new for TV Flash if ( spec == 'TV' . or . spec == 'isoV' ) then ! find Vy,Vx (vV and vL) from V balance and P equality equations dVydVl = - ( 1 - beta ) / beta ! call Bcalc(n, x, T, Bx) ! TODO: Add this intiial volume if ( Vx < Bx ) Vx = 1.625 * Bx ! First evaluation will be with Vx = 1.5*Bx ! Pl = -1.0 call zTVTERMO ( n , 0 , T , x , Vx , Pl , DPVl , PHILOGy , DLPHIP , DLPHIT , FUGN ) ! 26/06/15 do while ( Pl < 0 . or . DPVl >= 0 ) Vx = Vx - 0.2 * ( Vx - Bx ) call zTVTERMO ( n , 0 , T , x , Vx , Pl , DPVl , PHILOGy , DLPHIP , DLPHIT , FUGN ) end do Vy = ( v - ( 1 - beta ) * Vx ) / beta h = 1.0 iterv = 0 stopflash = . false . do while ( abs ( h ) > 1.d-4 ) ! Newton for solving P equality, with Vx as independent variable iterv = iterv + 1 if ( iterv >= 100 ) then write ( 2 , * ) 'volume convergence problems' P = - 1.0 stopflash = . true . exit end if call zTVTERMO ( n , 0 , T , x , Vx , Pl , DPVl , PHILOGy , DLPHIP , DLPHIT , FUGN ) call zTVTERMO ( n , 0 , T , y , Vy , Pv , DPVv , PHILOGy , DLPHIP , DLPHIT , FUGN ) h = Pv - Pl dh = - DPVv * dVydVl - DPVl stepv = - h / dh if ( iterv >= 10 ) stepv = stepv / 2 Vx = Vx + stepv do while ( Vx < 1.001 * Bx ) stepv = stepv / 2 Vx = Vx - stepv end do Vy = ( v - ( 1 - beta ) * Vx ) / beta end do if ( stopflash . eqv . . true .) exit call zTVTERMO ( n , 1 , T , x , Vx , Pl , DPVl , PHILOGx , DLPHIP , DLPHIT , FUGN ) call zTVTERMO ( n , 1 , T , y , Vy , Pv , DPVv , PHILOGy , DLPHIP , DLPHIT , FUGN ) else ! for TP Flash ! nc,MTYP,INDIC,T,P,rn,V,PHILOG,DLPHI MTYP = 0 ! -1   (with 0, generalized also fo LL and not only VL) call TERMO ( n , MTYP , 1 , T , P , y , Vy , PHILOGy , DLPHIP , DLPHIT , FUGN ) MTYP = 1 call TERMO ( n , MTYP , 1 , T , P , x , Vx , PHILOGx , DLPHIP , DLPHIT , FUGN ) end if varKold = var_K logKold = LOG_K ! From previous iteration step var_K = PHILOGx - PHILOGy - LOG_K ! variation in LOG_K = new - old LOG_K = PHILOGx - PHILOGy aux = sum ( var_K + varKold ) if ( iter > 10 . and . abs ( aux ) < 0.05 ) then ! oscilation behavior detected (27/06/15) LOG_K = ( LOG_K + logKold ) / 2 end if KFACT = exp ( LOG_K ) call betalimits ( n , z , KFACT , bmin , bmax ) ! 26/06/15 if (( beta < bmin ) . or . ( bmax < beta )) then beta = ( bmin + bmax ) / 2 end if if ( iter > 500 ) then p = - 1 return end if end do !  WRITE (2,4) (KFACT(i),i=1,N) rho_x = 1 / Vx rho_y = 1 / Vy if ( spec == 'TP' ) v = beta * Vy + ( 1 - beta ) * Vx if ( spec == 'TV' . or . spec == 'isoV' ) write ( 4 , * ) T , P , Pv if ( spec == 'TV' . or . spec == 'isoV' ) P = Pv FIRST = . false . if ( maxval ( KFACT ) < 1.001 . and . minval ( KFACT ) > 0.999 ) then ! trivial solution P = - 1.0 return !go to 31 end if saveK ( 1 : n ) = KFACT ! 3  format('KWilson ', 15E12.4) ! 4  format('KFinal  ', 15E12.4) !----------------------------------------------------------- ! print *, x  ! Estos print son los que \"lee\" tanto Fluids como Sur ! print *, y ! print *, rho_x ! print *, rho_y ! print *, beta end subroutine flash subroutine betato01 ( n , z , KFACT ) implicit none integer , intent ( in ) :: n ! number of compounds in the system real * 8 , dimension ( n ), intent ( in ) :: z ! composition of the system real * 8 , dimension ( n ) :: KFACT ! K factors (modified in this routine) real * 8 :: g0 , g1 ! function g valuated at beta=0 and 1, based on K factors g1 = 1.0 do while ( g0 < 0 . or . g1 > 0 ) g0 = sum ( z * KFACT ) - 1.D0 g1 = 1.D0 - sum ( z / KFACT ) if ( g0 < 0 ) then KFACT = 1.1 * KFACT ! increased volatiliy will bring the solution from subcooled liquid into VLE else if ( g1 > 0 ) then KFACT = 0.9 * KFACT ! decreased volatiliy will bring the solution from superheated vapor into VLE end if end do end subroutine betato01 subroutine betalimits ( n , z , KFACT , bmin , bmax ) implicit none integer , intent ( in ) :: n ! number of compounds in the system real * 8 , dimension ( n ), intent ( in ) :: z , KFACT ! composition of the system and K factors real * 8 , intent ( out ) :: bmin , bmax real * 8 , dimension ( n ) :: vmin , vmax integer :: i , in , ix in = 0 ix = 0 vmin = 0.d0 ! max=1.001d0    ! modified  3/3/15 (not to generate false separations with beta 0.9999...) vmax = 1.00001d0 ! modified 28/6/15 (to prevent overshooting in the Newton for solving RR eq.) do i = 1 , n if ( KFACT ( i ) * z ( i ) > 1 ) then in = in + 1 vmin ( in ) = ( KFACT ( i ) * z ( i ) - 1.d0 ) / ( KFACT ( i ) - 1.d0 ) else if ( KFACT ( i ) < z ( i )) then ix = ix + 1 vmax ( ix ) = ( 1.d0 - z ( i )) / ( 1.d0 - KFACT ( i )) end if end do bmin = maxval ( vmin ) bmax = minval ( vmax ) end subroutine betalimits end module","tags":"","loc":"sourcefile/flash.f90.html"},{"title":"io_nml.f90 – fenvelopes","text":"This file depends on sourcefile~~io_nml.f90~~EfferentGraph sourcefile~io_nml.f90 io_nml.f90 sourcefile~constants.f90 constants.f90 sourcefile~io_nml.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules io_nml Source Code io_nml.f90 Source Code module io_nml !! Namelist I/O Module !! !! Module that holds all the I/O routines to read from a setup file !! and setup the models and parameters included included in the thermodynamic !! routines !! !! ```fortran !! !!  ! Namelist based input file !!  ! ========================= !!  ! !!  ! Units: !!  !  - Pressure: bar !!  !  - Temperature: K !!  !  - Volume: L !!  ! ========================= !! !! !!  &nml_setup !!      nc=3,                    ! Number of components !!      model=\"PR78\",            ! SRK PR76 PR78 RKPR !!      mixrule=\"ClassicVdW\"     ! ClassicVdW !!  / !! !!  &nml_composition !!      names=\"C4\" \"C20\" \"H2O\" !!      spec=\"critical\"          ! critical or parameters !!      z=0.16 0.04 0.8 !!  / !! !!  &nml_classicvdw !!      kij(1, :)=0   0   0.5 !!      kij(2, :)=0   0   0.5 !!      kij(3, :)=0.5 0.5 0 !!  / !! !!  &nml_critical !!      ! Critical constants !!      tc=425.2 782.0 647.3 !!      pc=38.0 14.6 220.89 !!      w=0.1928 0.816 0.344 !!  / !! use constants , only : pr use legacy_ar_models , only : nc , thermo_model , mixing_rule , tdep , & & z , & & tc , pc , w , & & ac , b , k , & & kij , lij , bij , & & setup , SRK_factory , PR76_factory , PR78_factory use io , only : str implicit none integer :: nunit_input character ( len = 50 ) :: model , mixrule character ( len = 254 ) :: path_to_file character ( len = 50 ) :: spec character ( len = 50 ), allocatable :: names (:) private public :: setup_input , read_system , write_system contains subroutine setup_input ( filepath ) !> Setup input file to be used character ( len =* ), intent ( in ) :: filepath !! Path to input file path_to_file = trim ( adjustl ( filepath )) end subroutine subroutine read_model () !> Reads the thermodynamic model to be used and sets up the selector ! variables used in the thermo routines namelist / nml_setup / nc , model , mixrule integer :: i , j ! Open file and get setup information open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_setup ) close ( nunit_input ) ! Setup the legacy model name select case ( model ) case ( \"SRK\" ) thermo_model = 1 case ( \"PR76\" ) thermo_model = 2 case ( \"PR78\" ) thermo_model = 3 case ( \"RKPR\" ) thermo_model = 4 end select ! This should be below, but to assure compatiblity with legacy the ! mixing rule should be setup first select case ( mixrule ) case ( \"ClassicVdW\" ) tdep = 0 mixing_rule = 0 end select ! Allocate in memory all the parameters call setup ( nc , thermo_model , tdep , mixing_rule ) allocate ( names ( nc )) allocate ( z ( nc )) end subroutine subroutine read_components () !! Read components namelist / nml_composition / names , spec , z integer :: i , j ! Open file and get the components to use, their composition and what ! kind of specification to use on their definition open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_composition ) close ( nunit_input ) ! Normalize compositions z = z / sum ( z ) select case ( model ) case ( \"SRK\" ) call read_srk () case ( \"PR76\" ) call read_pr76 () case ( \"PR78\" ) call read_pr78 () end select select case ( mixrule ) case ( \"ClassicVdW\" ) ! Read kij and lij matrixes ! Since in the ClassicVdW mixing rules the bij matrix is constant ! it's stored beforehand call read_kij_lij () do i = 1 , nc do j = i , nc bij ( i , j ) = 0.5_pr * ( b ( i ) + b ( j )) * ( 1.0_pr - lij ( i , j )) bij ( j , i ) = bij ( i , j ) end do end do end select end subroutine subroutine read_srk () !> Read SRK model parameters ! ! options: ! ! * spec=\"critical\" -> Use critical constants ! * spec=\"parameters\" -> Use EoS parameters ! namelist / nml_critical / tc , pc , w namelist / nml_parameters / ac , b , k select case ( spec ) case ( \"critical\" ) open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_critical ) close ( nunit_input ) call SRK_factory ( z , tc_in = tc , pc_in = pc , w_in = w ) case ( \"parameters\" ) open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_parameters ) close ( nunit_input ) call SRK_factory ( z , ac_in = ac , b_in = b , k_in = k ) end select end subroutine subroutine read_pr76 () ! Read PR76 model namelist / nml_critical / tc , pc , w namelist / nml_parameters / ac , b , k select case ( spec ) case ( \"critical\" ) open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_critical ) close ( nunit_input ) call PR76_factory ( z , tc_in = tc , pc_in = pc , w_in = w ) case ( \"parameters\" ) open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_parameters ) close ( nunit_input ) call PR76_factory ( z , ac_in = ac , b_in = b , k_in = k ) end select end subroutine subroutine read_pr78 () ! Read PR78 model namelist / nml_critical / tc , pc , w namelist / nml_parameters / ac , b , k select case ( spec ) case ( \"critical\" ) open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_critical ) close ( nunit_input ) call PR78_factory ( z , tc_in = tc , pc_in = pc , w_in = w ) case ( \"parameters\" ) open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_parameters ) close ( nunit_input ) call PR78_factory ( z , ac_in = ac , b_in = b , k_in = k ) end select end subroutine subroutine read_kij_lij () ! Read the Kij and Lij matrices namelist / nml_classicvdw / kij , lij integer :: i , j kij = 0 lij = 0 open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_classicvdw ) close ( nunit_input ) do i = 1 , nc do j = 1 , nc kij ( i , j ) = kij ( j , i ) lij ( i , j ) = lij ( j , i ) end do end do end subroutine subroutine read_system ( filepath ) character ( len =* ) :: filepath call setup_input ( filepath ) call read_model () call read_components () close ( nunit_input ) end subroutine subroutine write_system ( file_unit ) ! Write read system into a file integer , intent ( in ), optional :: file_unit integer :: i ! if (.not. present(file_unit)) file_unit= character ( len = 20 ) :: fmt_pure character ( len = 20 ) :: fmt_names fmt_pure = \"(xG,\" // adjustl ( trim ( str ( nc ))) // \"F8.2)\" fmt_names = \"(8x, \" // adjustl ( trim ( str ( nc ))) // \"(A8))\" write ( file_unit , * ) \"=====================\" write ( file_unit , * ) \"General System: \" write ( file_unit , * ) \"---------------------\" write ( file_unit , * ) \"Model: \" , model write ( file_unit , * ) \"MixingRule: \" , mixrule write ( file_unit , * ) \"Names: \" , ( trim ( names ( i )) // \" \" , i = 1 , nc ) write ( file_unit , fmt_pure ) \"Z: \" , z write ( file_unit , * ) \"====================\" write ( file_unit , * ) \"Critical Constants: \" write ( file_unit , * ) \"--------------------\" write ( file_unit , fmt_pure ) \"Tc: \" , tc write ( file_unit , fmt_pure ) \"Pc: \" , pc write ( file_unit , fmt_pure ) \"w : \" , w write ( file_unit , * ) \"====================\" write ( file_unit , * ) \"EoS Parameters: \" write ( file_unit , * ) \"--------------------\" write ( file_unit , fmt_pure ) \"ac: \" , ac write ( file_unit , fmt_pure ) \"b: \" , b write ( file_unit , fmt_pure ) \"k: \" , k write ( file_unit , * ) \"====================\" write ( file_unit , * ), \"Mixing Rules: \" write ( file_unit , * ), \"--------------------\" write ( file_unit , * ) \"Kij: \" write ( file_unit , fmt_names ) names do i = 1 , nc write ( file_unit , fmt_pure ) trim ( names ( i )), kij ( i , :) end do write ( file_unit , * ) \"lij: \" write ( file_unit , fmt_names ) names do i = 1 , nc write ( file_unit , fmt_pure ) trim ( names ( i )), lij ( i , :) end do end subroutine end module","tags":"","loc":"sourcefile/io_nml.f90.html"},{"title":"constants.f90 – fenvelopes","text":"Files dependent on this one sourcefile~~constants.f90~~AfferentGraph sourcefile~constants.f90 constants.f90 sourcefile~types.f90 types.f90 sourcefile~types.f90->sourcefile~constants.f90 sourcefile~io_nml.f90 io_nml.f90 sourcefile~io_nml.f90->sourcefile~constants.f90 sourcefile~mod_inj_envelopes.f90 mod_inj_envelopes.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~constants.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~types.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~linalg.f90 sourcefile~flash.f90 Flash.f90 sourcefile~flash.f90->sourcefile~constants.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~envelopes.f90->sourcefile~constants.f90 sourcefile~envelopes.f90->sourcefile~types.f90 sourcefile~envelopes.f90->sourcefile~linalg.f90 sourcefile~linalg.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules constants Source Code constants.f90 Source Code module constants use iso_fortran_env , only : real32 , real64 , real128 implicit none integer , parameter :: pr = real64 real ( pr ), parameter :: R = 0.08314472 character ( len = 254 ) :: database_path = \"database/\" character ( len = 254 ) :: ouput_path = \"fenvelopes_output/\" character ( len = 1 ) :: path_sep = \"/\" end module constants","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"envelopes.f90 – fenvelopes","text":"This file depends on sourcefile~~envelopes.f90~~EfferentGraph sourcefile~envelopes.f90 envelopes.f90 sourcefile~constants.f90 constants.f90 sourcefile~envelopes.f90->sourcefile~constants.f90 sourcefile~types.f90 types.f90 sourcefile~envelopes.f90->sourcefile~types.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~envelopes.f90->sourcefile~linalg.f90 sourcefile~types.f90->sourcefile~constants.f90 sourcefile~linalg.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules envelopes Source Code envelopes.f90 Source Code module envelopes !! Functions to be used in the different continuation methods to trace !! phase envelopes use constants , only : pr use linalg , only : solve_system ! use system, only: nc use dtypes , only : envelope use legacy_ar_models , only : nc , termo implicit none integer , parameter :: max_points = 2000 integer :: env_number = 0 interface function F ( X , ns , S ) import pr real ( pr ), intent ( in ) :: X (:) integer , intent ( in ) :: ns real ( pr ), intent ( in ) :: S real ( pr ) :: F end function end interface contains ! =========================================================================== !  Initializators ! --------------------------------------------------------------------------- subroutine k_wilson_bubble ( z , t , p , k ) !! Find the Wilson Kfactors at ~10 bar to initialize a bubble point ! use system, only: pc, tc, w use legacy_ar_models , only : pc , tc , w real ( pr ), intent ( in ) :: z (:) real ( pr ), intent ( in out ) :: p real ( pr ), intent ( in out ) :: t real ( pr ), intent ( out ) :: k ( size ( z )) P = 10 0.0 T = 20 0.0 do while ( P > 10 ) T = T - 5._pr P = 1.0_pr / sum ( z * pc * exp ( 5.373_pr * ( 1 + w ) * ( 1 - tc / T ))) end do k = k_wilson ( t , p ) end subroutine function k_wilson ( t , p ) result ( k ) ! use system, only: pc, tc, w use legacy_ar_models , only : pc , tc , w real ( pr ), intent ( in ) :: t , p real ( pr ) :: k ( size ( pc )) k = pc * exp ( 5.373_pr * ( 1.0_pr + w ) * ( 1.0_pr - tc / t )) / p end function function p_wilson ( z , t ) result ( p ) ! use system, only: pc, tc, w use legacy_ar_models , only : pc , tc , w real ( pr ), intent ( in ) :: t , z (:) real ( pr ) :: p P = 1.0_pr / sum ( z * pc * exp ( 5.373_pr * ( 1 + w ) * ( 1 - tc / T ))) end function ! =========================================================================== ! =========================================================================== ! General routines ! --------------------------------------------------------------------------- subroutine update_specification ( iter , passingcri , X , dF , ns , S , delS , dXdS ) integer , intent ( in ) :: iter logical , intent ( in ) :: passingcri real ( pr ), intent ( in ) :: X ( nc + 2 ) real ( pr ), intent ( in ) :: dF ( nc + 2 , nc + 2 ) integer , intent ( in out ) :: ns real ( pr ), intent ( in out ) :: S real ( pr ), intent ( in out ) :: delS real ( pr ), intent ( in out ) :: dXdS ( nc + 2 ) real ( pr ) :: dF_dS ( nc + 2 ) real ( pr ) :: bd ( nc + 2 ) real ( pr ) :: AJ ( nc + 2 , nc + 2 ) real ( pr ) :: delmax , updel integer :: nsold dF_dS = 0 call dFdS ( dF_dS ) bd = - dF_dS AJ = dF dXdS = solve_system ( AJ , bd ) ! Selection of (the most changing) variable to be specified for the next point nsold = ns ns = maxloc ( abs ( dXdS ), dim = 1 ) if ( maxval ( abs ( X (: nc ))) < 0.2 ) then ns = maxloc ( abs ( dXdS (: nc )), dim = 1 ) ! T and P not allowed to be chosen close to a critical point end if if ( ns /= nsold ) then delS = dXdS ( ns ) * delS ! translation of delS to the  new specification variable dXdS = dXdS / dXdS ( ns ) ! translation of sensitivities S = X ( ns ) ! update of S end if ! Setting step in S for the next point to be calculated delmax = max ( sqrt ( abs ( X ( ns ))) / 10 , 0.1 ) updel = delS * 3 / iter if ( passingcri ) updel = delS if ( delS > 0 ) then delS = min ( updel , delmax ) else delS = max ( updel , - delmax ) end if S = S + delS end subroutine ! =========================================================================== ! =========================================================================== ! Specification function derivatives ! --------------------------------------------------------------------------- subroutine dFdS ( dF_dS ) ! use system, only: nc use legacy_ar_models , only : nc real ( pr ), intent ( out ) :: dF_dS ( nc + 2 ) dF_dS = 0 dF_dS ( nc + 2 ) = - 1 end subroutine ! --------------------------------------------------------------------------- ! =========================================================================== ! Two Phase envelopes ! --------------------------------------------------------------------------- function X2 ( kfact , P , T ) result ( X ) real ( pr ), intent ( in ) :: kfact ( nc ) real ( pr ), intent ( in ) :: P real ( pr ), intent ( in ) :: T real ( pr ) :: X ( nc + 2 ) integer :: n n = size ( kfact ) X (: n ) = log ( kfact ) X ( n + 1 ) = log ( T ) X ( n + 2 ) = log ( P ) end function subroutine F2 ( incipient , z , y , X , S , ns , F , dF ) character ( len = :), allocatable , intent ( in ) :: incipient real ( pr ), intent ( in ) :: z (:) real ( pr ), intent ( in ) :: X ( nc + 2 ) real ( pr ), intent ( in ) :: y ( nc ) real ( pr ), intent ( in ) :: S integer , intent ( in ) :: ns real ( pr ), intent ( out ) :: F ( nc + 2 ) real ( pr ), intent ( out ) :: dF ( nc + 2 , nc + 2 ) real ( pr ) :: Vx , Vy , lnfug_x ( nc ), lnfug_y ( nc ) real ( pr ) :: dlnphi_dt_x ( nc ), dlnphi_dt_y ( nc ) real ( pr ) :: dlnphi_dp_x ( nc ), dlnphi_dp_y ( nc ) real ( pr ) :: dlnphi_dn_x ( nc , nc ), dlnphi_dn_y ( nc , nc ) real ( pr ) :: T , P integer :: ix , iy , n , j n = size ( z ) F = 0 dF = 0 T = exp ( X ( n + 1 )) P = exp ( X ( n + 2 )) select case ( incipient ) case ( \"liquid\" ) ix = - 1 iy = 1 case ( \"vapor\" ) ix = 1 iy = - 1 case ( \"2ndliquid\" ) ix = 1 iy = 1 end select call TERMO ( n , iy , 4 , T , P , y , Vy , lnfug_y , dlnphi_dp_y , dlnphi_dt_y , dlnphi_dn_y ) call TERMO ( n , ix , 2 , T , P , z , Vx , lnfug_x , dlnphi_dp_x , dlnphi_dt_x , dlnphi_dn_x ) F (: n ) = X (: n ) + lnfug_y - lnfug_x ! X(:n) are LOG_K F ( n + 1 ) = sum ( y - z ) F ( n + 2 ) = X ( ns ) - S ! Jacobian Matrix do j = 1 , n df (: n , j ) = dlnphi_dn_y (:, j ) * y ( j ) df ( j , j ) = dF ( j , j ) + 1 end do df (: n , n + 1 ) = T * ( dlnphi_dt_y - dlnphi_dt_x ) df (: n , n + 2 ) = P * ( dlnphi_dp_y - dlnphi_dp_x ) df ( n + 1 , : n ) = y df ( n + 2 , :) = 0 df ( n + 2 , ns ) = 1 end subroutine F2 subroutine fix_delx (& point , iterations , desired_iterations , first_tol , tol , delX & ) integer , intent ( in ) :: point integer , intent ( in ) :: iterations integer , intent ( in ) :: desired_iterations real ( pr ), intent ( in ) :: first_tol real ( pr ), intent ( in ) :: tol real ( pr ), intent ( in out ) :: delX (:) if ( point == 1 ) then do while ( maxval ( abs ( delX )) > first_tol ) ! Too large Newton step --> Reduce it delX = delX / 2 end do else do while ( maxval ( abs ( delX )) > tol ) ! Too large Newton step --> Reduce it delX = delX / 2 end do if ( iterations > desired_iterations ) then ! too many iterations (sometimes due to oscillatory behavior ! near critical point) --> Reduce it delX = delX / 2 endif end if end subroutine subroutine envelope2 ( ichoice , n , z , T , P , KFACT , & ! This will probably always exist n_points , Tv , Pv , Dv , ncri , icri , Tcri , Pcri , Dcri , & ! This shouldnt be here in the future this_envelope ) ! This output should encapsulate everything use dtypes , only : envelope , critical_point use linalg , only : point , solve_system use constants , only : ouput_path implicit none ! number of compounds in the system and starting point type integer , intent ( in ) :: n , ichoice ! estimated T and P for first point (then used for every point) real ( pr ) :: T , P ! Maximun pressure real ( pr ) :: maxP ! estimated K factors for first point (then used for every point) real ( pr ), intent ( in out ) :: KFACT ( n ) ! composition of the system real ( pr ), intent ( in ) :: z ( n ) ! T, P and Density of the calculated envelope real ( pr ), intent ( out ) :: Tv ( max_points ) real ( pr ), intent ( out ) :: Pv ( max_points ) real ( pr ), intent ( out ) :: Dv ( max_points ) ! number of valid elements in Tv, Pv and Dv arrays integer , intent ( out ) :: n_points ! positions of the last saturation points before each critical point integer , dimension ( 4 ), intent ( out ) :: icri ! T, P and Density of critical points real ( pr ), dimension ( 4 ), intent ( out ) :: Tcri ( 4 ), Pcri ( 4 ), Dcri ( 4 ) ! number of valid elements in icri, Tcri, Pcri and Dcri arrays integer , intent ( out ) :: ncri ! Intermediate variables during calculation process real ( pr ), dimension ( n ) :: y real ( pr ), dimension ( n + 2 ) :: X , Xold , Xold2 , delX , bd , F , dFdS , dXdS real ( pr ), dimension ( n + 2 , n + 2 ) :: JAC , AJ real ( pr ) :: Vx logical :: run , passingcri , minT , minmaxT character ( len = :), allocatable :: incipient_phase type ( envelope ), intent ( out ) :: this_envelope real ( pr ) :: tmp_logk ( max_points , n ) real ( pr ) :: tmp_logphi ( max_points , n ) ! Extrapolation of variables to detect critical points real ( pr ) :: extra_slope ( n + 2 ) real ( pr ) :: lnK_extrapolated ( n ) real ( pr ) :: delta_t integer :: i integer :: iy , ix ! Vapor or liquid selectors ! Specification value, delta and index real ( pr ) :: S , delS integer :: ns real ( pr ) :: Told2 , Told real ( pr ) :: frac ! Netwon method integer :: iter ! Iteration integer :: max_iter ! Critical Points type ( critical_point ), allocatable :: critical_points (:) integer :: black_i ! Number of steps while trying to escape the CP real ( pr ) :: stepx integer :: funit_output character ( len = 254 ) :: fname_env ! ======================================================================== !  OUTPUT file ! ------------------------------------------------------------------------ env_number = env_number + 1 write ( fname_env , * ) env_number fname_env = \"env-2ph-PT\" // \"_\" // trim ( adjustl ( fname_env )) fname_env = trim ( adjustl ( ouput_path )) // trim ( fname_env ) // \".dat\" open ( newunit = funit_output , file = fname_env ) ! ======================================================================== ! Initialize with zero Tv and Pv allocate ( this_envelope % vars ( max_points - 50 , n + 2 )) Tv = 0 Pv = 0 minT = . false . minmaxT = . false . passingcri = . false . Told2 = 0.0 Told = 1 0.0 maxP = 0.d0 !----------------------------------------------------------- ! Continuation method for tracing the envelope starts here run = . true . i = 0 ncri = 0 JAC ( n + 1 , :) = 0.d0 X (: n ) = log ( KFACT ) X ( n + 1 ) = log ( T ) X ( n + 2 ) = log ( P ) iy = 1 ix = 1 select case ( ichoice ) case ( 1 ) incipient_phase = \"vapor\" iy = - 1 case ( 2 ) incipient_phase = \"liquid\" ix = - 1 case ( 3 ) incipient_phase = \"2ndliquid\" end select write ( funit_output , * ) \"#\" , incipient_phase if ( ichoice <= 2 ) then ! low T bub (1) or dew (2) ! x will be vapor phase during the first part, ! and liquid after a critical point is crossed if ( ichoice == 1 ) iy = - 1 if ( ichoice == 2 ) ix = - 1 ns = n + 1 S = log ( T ) delS = 0.005 ! Wilson estimate for vapor (or liquid) composition y = KFACT * z else ! (ichoice==3) high P L-L sat ! PmaxDewC = maxval(PdewC(1:ilastDewC)) ns = n + 2 S = log ( P ) delS = - 0.005 y = 0.d0 y ( n ) = 1.d0 end if Xold = 0.d0 dFdS = 0.d0 dFdS ( n + 2 ) = - 1.d0 do while ( run ) i = i + 1 if ( i > max_points - 50 ) then exit end if ! Newton starts here delX = 1.0 iter = 0 max_iter = 500 do while ( maxval ( abs ( delX )) > 1.d-9 . and . iter <= max_iter ) ! Solve point with full Newton method call F2 ( incipient_phase , z , y , X , S , ns , F , JAC ) iter = iter + 1 bd = - F AJ = JAC delX = solve_system ( AJ , bd ) call fix_delX ( i , iter , 3 , 1 0.0_pr , 0.08_pr , delX ) X = X + delX if (. not . passingcri . and . i /= 1 & . and . iter > 10 & . and . maxval ( abs ( delX )) > 0.001 ) then ! Too many iterations --> Reduce step to new point delS = delS * 2.0 / 4.0 S = S - delS X = Xold + dXdS * delS end if KFACT = exp ( X (: n )) y = z * KFACT T = exp ( X ( n + 1 )) P = exp ( X ( n + 2 )) end do ! Point converged (unless it jumped out because of high number of iterations) if ( iter > max_iter ) run = . false . if ( P > maxP ) maxP = P if ( run ) write ( funit_output , * ) \"SOL\" , iter , ns , T , P , exp ( X (: n )) if ( incipient_phase == \"liquid\" . and . i > 1 ) then ! TODO: If this is the way the low p dew line finishes, ! I think this could be better, like using dPdT if ( P < Pv ( i - 1 ) . and . P < maxP / 5 . and . T > 300 ) then run = . true . ! to finish envelope going to low T bubble end if end if Tv ( i ) = T Pv ( i ) = P this_envelope % vars ( i , :) = X tmp_logk ( i , : n ) = X (: n ) if ( incipient_phase == \"2ndliquid\" . and . P < 0.1 ) then ! isolated LL line detected. ! Stop and start a new one from low T false bubble point run = . false . end if if ( i > max_points - 50 ) exit if ( sum ( X (: n ) * Xold (: n )) < 0 ) then ! critical point detected ncri = ncri + 1 icri ( ncri ) = i - 1 frac = - Xold ( ns ) / ( X ( ns ) - Xold ( ns )) Tcri ( ncri ) = Tv ( i - 1 ) + frac * ( T - Tv ( i - 1 )) Pcri ( ncri ) = Pv ( i - 1 ) + frac * ( P - Pv ( i - 1 )) Dcri ( ncri ) = Dv ( i - 1 ) + frac * ( Dv ( i ) - Dv ( i - 1 )) select case ( incipient_phase ) case ( \"liquid\" ) incipient_phase = \"vapor\" case ( \"vapor\" ) incipient_phase = \"liquid\" end select write ( funit_output , * ) \" \" write ( funit_output , * ) \" \" write ( funit_output , * ) \"#\" , incipient_phase end if if ( run ) then ! Calculation of sensitivities (dXdS) ! dgesv( n, nrhs, a, lda, ipiv, b, ldb, info ) call update_specification ( iter , passingcri , X , JAC , ns , S , delS , dXdS ) ! Generation of estimates for the next point Told2 = Told Told = T Xold2 = Xold Xold = X X = Xold + dXdS * delS critical_region : block black_i = 0 if ( passingcri ) passingcri = . false . if ( i > 10 ) then ! After the 10th step extrapolate the K factors in order ! to find a possible critical point (check if all lnK values ! change sign). extrapolation : block integer :: loc integer :: its real ( pr ) :: delta real ( pr ) :: m ( size ( X )) real ( pr ) :: max_lnK , max_lnK2 , delta_lnK real ( pr ) :: delta_X ( size ( x )) its = 0 delta = delS ! Variation of lnK based on deltaS m = 1 5.0_pr * ( X - Xold2 ) / ( delta ) lnK_extrapolated = ( delta ) * m (: n ) + X (: n ) if ( all (( X (: n ) * lnK_extrapolated < 0 ), dim = 1 )) then ! All lnK changed sign, so a CP is inminent ! aproach it enough to force the jumping algorithm do while ( & maxval ( abs ( X (: n ))) > 0.03 & . and . all ( X (: n ) * lnK_extrapolated > 0 , dim = 1 )& ) print * , its , \"Getting to critical\" , & exp ( X ( n + 1 )), exp ( X ( n + 2 )), maxval ( abs ( X (: n ))), & all ( X (: n ) * lnK_extrapolated > 0 , dim = 1 ) its = its + 1 delta_x = delta * m X = delta_x + X S = X ( ns ) if ( its > 10 ) exit end do passingcri = . true . end if end block extrapolation end if do while ( maxval ( abs ( X (: n ))) < 0.03 ) print * , \"Jumping critical\" ! approaching the black hole... get out of there! (0.03) black_i = black_i + 1 if ( black_i > 50 ) then print * , \"Stuck on the black hole\" if ( black_i > 100 ) stop end if stepX = maxval ( abs ( X (: n ) - Xold (: n ))) ! the step given by the most changing logK to fall into ! the black hole passingcri = . true . if ( stepX > 0.07 ) then !  half step back S = S - delS / 2 X = X - dXdS * delS / 2 else ! one more step to jump over the critical point S = S + delS X = X + dXdS * delS end if end do end block critical_region T = exp ( X ( n + 1 )) if (. not . passingcri . and . abs ( T - Told ) > 7 ) then ! Delta T estimations > 7K are not allowed delS = delS / 2 S = S - delS X = Xold + dXdS * delS T = exp ( X ( n + 1 )) end if P = exp ( X ( n + 2 )) KFACT = exp ( X (: n )) y = z * KFACT ! Finish conditions if (( dXdS ( n + 1 ) * delS < 0 . and . P < 0.1 . or . T < 12 0.0 ) & ! dew line stops when P<0.1 bar or T<150K . or . ( P > 1.0 . and . T < 15 0.0 ) & ! bubble line stops when T<150K . or . ( P > 1500 ) & . or . ( abs ( dels ) < 1.d-10 )) then run = . false . end if end if end do !----------------------------------------------------------- n_points = i write ( funit_output , * ) \" \" write ( funit_output , * ) \" \" write ( funit_output , * ) \"#critical\" if ( ncri == 0 ) write ( funit_output , * ) \"NaN NaN\" do i = 1 , ncri write ( funit_output , * ) Tcri ( i ), Pcri ( i ) end do ! Define envelope values, omit the last point to avoid not really ! converged cases close ( funit_output ) this_envelope % logk = tmp_logk (: n_points - 1 , :) this_envelope % logphi = tmp_logphi (: n_points - 1 , :) this_envelope % t = Tv (: n_points - 1 ) this_envelope % p = Pv (: n_points - 1 ) this_envelope % z = z allocate ( critical_points ( ncri )) critical_points % t = tcri (: ncri ) critical_points % p = pcri (: ncri ) this_envelope % critical_points = critical_points end subroutine envelope2 ! =========================================================================== end module envelopes","tags":"","loc":"sourcefile/envelopes.f90.html"},{"title":"mod_inj_envelopes.f90 – fenvelopes","text":"This file depends on sourcefile~~mod_inj_envelopes.f90~~EfferentGraph sourcefile~mod_inj_envelopes.f90 mod_inj_envelopes.f90 sourcefile~constants.f90 constants.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~constants.f90 sourcefile~types.f90 types.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~types.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~linalg.f90 sourcefile~types.f90->sourcefile~constants.f90 sourcefile~linalg.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules inj_envelopes Source Code mod_inj_envelopes.f90 Source Code module inj_envelopes !! Module to calculate Px phase envelopes use constants , only : pr , R use dtypes , only : envelope , critical_point use linalg , only : solve_system , interpol implicit none type , extends ( envelope ) :: injelope real ( pr ), allocatable :: alpha (:) !! Ammount of injected fluid real ( pr ), allocatable :: z_inj (:) !! Injected fluid composition real ( pr ), allocatable :: z_mix (:, :) !! Composition at each step end type ! ========================================================================== !  Parameters ! -------------------------------------------------------------------------- integer :: env_number = 0 !! Number of calculated envelope integer :: max_iters = 500 !! Maximum number of iterations for a newton step integer , parameter :: max_points = 1000 !! Maximum number of points for each envelope real ( pr ), allocatable :: z_0 (:) !! Original fluid composition real ( pr ), allocatable :: z_injection (:) !! Injection fluid composition real ( pr ) :: T !! Temperature of injection real ( pr ) :: del_S = 0.1 !! Specificiation variation character ( len = 10 ) :: injection_case !! Kind of injection displace|dilute ! ========================================================================== contains subroutine from_nml ( filepath ) use legacy_ar_models , only : nc character ( len =* ), intent ( in ) :: filepath integer :: funit namelist / nml_px / T , z_0 , z_injection , injection_case allocate ( z_0 ( nc ), z_injection ( nc )) open ( newunit = funit , file = filepath ) read ( funit , nml = nml_px ) close ( funit ) end subroutine subroutine F_injection ( X , ns , S , F , dF ) !! Function to solve at each point of the phase envelope. !! !! The vector of variables X corresponds to: !!  X = [lnK_i, lnP, \\alpha]  !! !! While the equations are: !! !!  F = [lnK_i - ln \\phi_i(y, P, T) + ln \\phi_i(z, P, T), !!         \\sum_{i=1}&#94;N, X_{ns} - S]  !! !! The injection can be considered as two kinds of injection: !! - Displacement:  z = \\alpha z_i + (1-\\alpha) z_0  !! - Addition:   z = \\frac{\\alpha z_i + (1-\\alpha) z_0}{\\sum_{i=1}&#94;N \\alpha z_i + (1-\\alpha) z_0}  !! use iso_fortran_env , only : error_unit use legacy_ar_models , only : TERMO real ( pr ), intent ( in ) :: X (:) !! Vector of variables integer , intent ( in ) :: ns !! Number of specification real ( pr ), intent ( in ) :: S !! Specification value real ( pr ), intent ( out ) :: F ( size ( X )) !! Vector of functions valuated real ( pr ), intent ( out ) :: df ( size ( x ), size ( X )) !! Jacobian matrix ! X variables real ( pr ) :: K ( size ( X ) - 2 ) real ( pr ) :: alpha real ( pr ) :: P ! Main phase variables real ( pr ) :: Vz real ( pr ), dimension ( size ( X ) - 2 ) :: z , lnfug_z , dlnphi_dt_z , dlnphi_dp_z real ( pr ), dimension ( size ( X ) - 2 , size ( X ) - 2 ) :: dlnphi_dn_z ! Incipient phase variables real ( pr ) :: Vy real ( pr ), dimension ( size ( X ) - 2 ) :: y , lnfug_y , dlnphi_dt_y , dlnphi_dp_y real ( pr ), dimension ( size ( X ) - 2 , size ( X ) - 2 ) :: dlnphi_dn_y ! Derivative of z wrt alpha real ( pr ) :: dzda ( size ( X ) - 2 ) integer :: i , j , n n = size ( X ) - 2 K = exp ( X ( 1 : n )) P = exp ( X ( n + 1 )) alpha = X ( n + 2 ) call get_z ( alpha , z , dzda ) if ( any ( z < 0 )) z = 0 y = K * z call TERMO ( & n , 0 , 4 , T , P , y , Vy , lnfug_y , dlnphi_dp_y , dlnphi_dt_y , dlnphi_dn_y & ) call TERMO ( & n , 0 , 4 , T , P , z , Vz , lnfug_z , dlnphi_dp_z , dlnphi_dt_z , dlnphi_dn_z & ) F ( 1 : n ) = X (: n ) + lnfug_y - lnfug_z F ( n + 1 ) = sum ( y - z ) F ( n + 2 ) = X ( ns ) - S df = 0 do i = 1 , n do j = 1 , n df ( i , j ) = y ( j ) * dlnphi_dn_y ( i , j ) end do df ( i , i ) = df ( i , i ) + 1 df ( i , n + 2 ) = sum ( K * dlnphi_dn_y ( i , :) * dzda - dlnphi_dn_z ( i , :) * dzda ) end do df (: n , n + 1 ) = P * ( dlnphi_dp_y - dlnphi_dp_z ) df ( n + 1 , : n ) = y df ( n + 1 , n + 2 ) = sum ( dzda * ( K - 1 )) df ( n + 2 , :) = 0 df ( n + 2 , ns ) = 1 end subroutine subroutine F_injection_three_phases ( Xvars , ns , S , F , dF ) !! Function to solve at each point of a three phase envelope. !! !! The vector of variables X corresponds to: !!  X = [lnKx_i, lnKy_i lnP, \\alpha, \\beta]  !! !! While the equations are: !! !!  F = [ !!        lnKx_i - ln \\phi_i(x, P, T) + ln \\phi_i(w, P, T), !!        lnKy_i - ln \\phi_i(y, P, T) + ln \\phi_i(w, P, T), !!        \\sum_{i=1}&#94;N (w_i) - 1, !!        \\sum_{i=1}&#94;N (x_i - y_i), !!        X_{ns} - S !! ]  use legacy_ar_models , only : TERMO use iso_fortran_env , only : error_unit real ( pr ), intent ( in ) :: Xvars (:) !! Vector of variables integer , intent ( in ) :: ns !! Number of specification real ( pr ), intent ( in ) :: S !! Specification value real ( pr ), intent ( out ) :: F ( size ( Xvars )) !! Vector of functions valuated real ( pr ), intent ( out ) :: df ( size ( Xvars ), size ( Xvars )) !! Jacobian matrix #define N (size(Xvars) - 3 )/2 ! Xvars variables real ( pr ) :: z ( N ) real ( pr ) :: Kx ( N ) real ( pr ) :: Ky ( N ) real ( pr ) :: P real ( pr ) :: beta real ( pr ) :: alpha ! Main phase 1 variables real ( pr ) :: Vx real ( pr ), dimension ( N ) :: x , lnfug_x , dlnphi_dt_x , dlnphi_dp_x real ( pr ), dimension ( N , N ) :: dlnphi_dn_x ! Main phase 2 variables real ( pr ) :: Vy real ( pr ), dimension ( N ) :: y , lnfug_y , dlnphi_dt_y , dlnphi_dp_y real ( pr ), dimension ( N , N ) :: dlnphi_dn_y ! Incipient phase variables real ( pr ) :: Vw real ( pr ), dimension ( N ) :: w , lnfug_w , dlnphi_dt_w , dlnphi_dp_w real ( pr ), dimension ( N , N ) :: dlnphi_dn_w ! Derivative of z wrt alpha real ( pr ) :: dzda ( N ), dwda ( N ) ! Derivative of w wrt beta real ( pr ) :: dwdb ( N ) real ( pr ) :: dwdKx ( N ), dxdKx ( N ), dydKx ( N ) real ( pr ) :: dwdKy ( N ), dxdKy ( N ), dydKy ( N ) integer :: i , j , n n = N #undef N Kx = exp ( Xvars ( 1 : n )) Ky = exp ( Xvars ( n + 1 : 2 * n )) P = exp ( Xvars ( 2 * n + 1 )) alpha = Xvars ( 2 * n + 2 ) beta = Xvars ( 2 * n + 3 ) call get_z ( alpha , z , dzda ) if ( any ( z < 0 )) z = 0 w = z / ( beta * Ky + ( 1 - beta ) * Kx ) x = w * Kx y = w * Ky call TERMO ( & n , 0 , 4 , T , P , x , Vx , lnfug_x , dlnphi_dp_x , dlnphi_dt_x , dlnphi_dn_x & ) call TERMO ( & n , 0 , 4 , T , P , y , Vy , lnfug_y , dlnphi_dp_y , dlnphi_dt_y , dlnphi_dn_y & ) call TERMO ( & n , 0 , 4 , T , P , w , Vw , lnfug_w , dlnphi_dp_w , dlnphi_dt_w , dlnphi_dn_w & ) F ( 1 : n ) = Xvars ( 1 : n ) + lnfug_x - lnfug_w F ( n + 1 : 2 * n ) = Xvars ( n + 1 : 2 * n ) + lnfug_y - lnfug_w F ( 2 * n + 1 ) = sum ( w ) - 1 F ( 2 * n + 2 ) = sum ( x - y ) F ( 2 * n + 3 ) = Xvars ( ns ) - S df = 0 dwda = 1.0_pr / ( beta * Ky + ( 1 - beta ) * Kx ) * dzda dwdb = z * ( Kx - Ky ) / (( 1 - beta ) * Kx + beta * Ky ) ** 2 dwdKx = - z * ( 1 - beta ) / ( Ky * beta + ( 1 - beta ) * Kx ) ** 2 dxdKx = Kx * dwdKx + w dydKx = Ky * dwdKx dwdKy = - z * ( beta ) / ( Ky * beta + ( 1 - beta ) * Kx ) ** 2 dxdKy = Kx * dwdKy dydKy = Ky * dwdKy + w do i = 1 , n do j = 1 , n df ( i , j ) = Kx ( j ) * ( dlnphi_dn_x ( i , j ) * dxdKx ( j ) & - dlnphi_dn_w ( i , j ) * dwdKx ( j )) df ( i + n , j ) = Kx ( j ) * ( dlnphi_dn_y ( i , j ) * dydKx ( j ) & - dlnphi_dn_w ( i , j ) * dwdKx ( j )) df ( i , j + n ) = Ky ( j ) * ( dlnphi_dn_x ( i , j ) * dxdKy ( j ) & - dlnphi_dn_w ( i , j ) * dwdKy ( j )) df ( i + n , j + n ) = Ky ( j ) * ( dlnphi_dn_y ( i , j ) * dydKy ( j ) & - dlnphi_dn_w ( i , j ) * dwdKy ( j )) end do df ( i , i ) = df ( i , i ) + 1 df ( i + n , i + n ) = df ( i + n , i + n ) + 1 df ( i , 2 * n + 2 ) = sum ( & Kx * dlnphi_dn_x ( i , :) * dwda - dlnphi_dn_w ( i , :) * dwda & ) df ( i + n , 2 * n + 2 ) = sum ( Ky * dlnphi_dn_y ( i , :) * dwda & - dlnphi_dn_w ( i , :) * dwda ) df ( i , 2 * n + 3 ) = sum ( Kx * dlnphi_dn_x ( i , :) * dwdb & - dlnphi_dn_w ( i , :) * dwdb ) df ( i + n , 2 * n + 3 ) = sum ( Ky * dlnphi_dn_y ( i , :) * dwdb & - dlnphi_dn_w ( i , :) * dwdb ) df ( 2 * n + 1 , i ) = Kx ( i ) * dwdKx ( i ) df ( 2 * n + 1 , i + n ) = Ky ( i ) * dwdKy ( i ) df ( 2 * n + 2 , i ) = Kx ( i ) * dxdKx ( i ) - Kx ( i ) * dydKx ( i ) df ( 2 * n + 2 , i + n ) = Ky ( i ) * dxdKy ( i ) - Ky ( i ) * dydKy ( i ) end do ! Derivatives wrt P df (: n , 2 * n + 1 ) = P * ( dlnphi_dp_x - dlnphi_dp_w ) df ( n + 1 : 2 * n , 2 * n + 1 ) = P * ( dlnphi_dp_y - dlnphi_dp_w ) ! Derivatives wrt alpha df ( 2 * n + 1 , 2 * n + 2 ) = sum ( dwda ) df ( 2 * n + 2 , 2 * n + 2 ) = sum ( Kx * dwda - Ky * dwda ) ! Derivatives wrt beta df ( 2 * n + 1 , 2 * n + 3 ) = sum ( dwdb ) df ( 2 * n + 2 , 2 * n + 3 ) = sum ( Kx * dwdb - Ky * dwdb ) ! Derivatives wrt Xs df ( 2 * n + 3 , :) = 0 df ( 2 * n + 3 , ns ) = 1 end subroutine subroutine injection_envelope ( X0 , spec_number , del_S0 , envels ) use constants , only : ouput_path !! Subroutine to calculate Px phase envelopes via continuation method real ( pr ), intent ( in ) :: X0 (:) !! Vector of variables integer , intent ( in ) :: spec_number !! Number of specification real ( pr ), intent ( in ) :: del_S0 !! \\Delta S_0 type ( injelope ), intent ( out ) :: envels !! Calculated envelopes type ( critical_point ), allocatable :: cps (:) real ( pr ) :: X ( size ( X0 )) integer :: ns real ( pr ) :: S real ( pr ) :: XS ( max_points , size ( X0 )) real ( pr ) :: F ( size ( X0 )), dF ( size ( X0 ), size ( X0 )), dXdS ( size ( X0 )) integer :: point , iters , n integer :: i integer :: funit_output character ( len = 254 ) :: fname_env allocate ( cps ( 0 )) X = X0 n = size ( X0 ) - 2 ns = spec_number S = X ( ns ) del_S = del_S0 ! ====================================================================== !  Output file ! ---------------------------------------------------------------------- env_number = env_number + 1 write ( fname_env , * ) env_number fname_env = \"env-2ph-PX\" // \"_\" // trim ( adjustl ( fname_env )) fname_env = trim ( adjustl ( ouput_path )) // trim ( fname_env ) // \".dat\" open ( funit_output , file = fname_env ) write ( funit_output , * ) \"#\" , T write ( funit_output , * ) \"X0\" , iters , ns , X ( n + 2 ), exp ( X ( n + 1 )), X (: n ) ! ====================================================================== enveloop : do point = 1 , max_points call full_newton ( f_injection , iters , X , ns , S , F , dF ) if ( iters >= max_iters ) then exit enveloop end if XS ( point , :) = X update_spec : block real ( pr ) :: dFdS ( size ( X0 )) integer :: ns_new dFdS = 0 dFdS ( n + 2 ) = 1 dXdS = solve_system ( dF , dFdS ) ns_new = maxloc ( abs ( dXdS ), dim = 1 ) if ( ns_new /= ns ) then ! translation of delS and dXdS to the  new specification variable del_S = dXdS ( ns_new ) * del_S dXdS = dXdS / dXdS ( ns_new ) ns = ns_new end if del_S = sign ( 1.0_pr , del_S ) * minval ([ & max ( sqrt ( abs ( X ( ns ))) / 10 , 0.1 ), & abs ( del_S ) * 3 / iters & ] & ) if ( injection_case == \"dilution\" ) del_S = 50 * del_S end block update_spec fix_step : block real ( pr ) :: Xnew ( size ( X0 )) real ( pr ) :: dP , dalpha Xnew = X + dXdS * del_S dP = exp ( Xnew ( n + 1 )) - exp ( X ( n + 1 )) dalpha = Xnew ( n + 2 ) - X ( n + 2 ) do while ( abs ( dP ) > 50 . or . abs ( dalpha ) > 0.03 ) dXdS = dXdS / 1 0.0_pr Xnew = X + dXdS * del_S dP = exp ( Xnew ( n + 1 )) - exp ( X ( n + 1 )) dalpha = Xnew ( n + 2 ) - X ( n + 2 ) end do end block fix_step detect_critical : block real ( pr ) :: K ( size ( X0 ) - 2 ), Knew ( size ( X0 ) - 2 ), & Xnew ( size ( X0 )), fact real ( pr ) :: pc , alpha_c , dS_c integer :: max_changing fact = 2.5 Xnew = X + fact * dXdS * del_S K = X (: n ) Knew = Xnew (: n ) if ( all ( K * Knew < 0 )) then max_changing = maxloc ( abs ( K - Knew ), dim = 1 ) dS_c = ( & - k ( max_changing ) * ( Xnew ( ns ) - X ( ns )) & / ( Knew ( max_changing ) - K ( max_changing )) & ) del_S = dS_c * 1.1 Xnew = X + dXdS * dS_c alpha_c = Xnew ( n + 2 ) pc = Xnew ( n + 1 ) cps = [ cps , critical_point ( t , pc , alpha_c )] write ( funit_output , * ) \"\" write ( funit_output , * ) \"\" end if end block detect_critical X = X + dXdS * del_S S = X ( ns ) if ( any ( break_conditions ( X , ns , S ))) exit enveloop write ( funit_output , * ) \"SOL\" , iters , ns , X ( n + 2 ), exp ( X ( n + 1 )), & X (: n ) end do enveloop point = point - 1 write ( funit_output , * ) \"\" write ( funit_output , * ) \"\" write ( funit_output , * ) \"#critical\" if ( size ( cps ) > 0 ) then do i = 1 , size ( cps ) write ( funit_output , * ) cps ( i )% t , cps ( i )% p end do else write ( funit_output , * ) \"NaN NaN\" end if close ( funit_output ) envels % z = z_0 envels % z_inj = z_injection envels % logk = XS (: point , : n ) envels % alpha = XS (: point , n + 2 ) envels % p = exp ( XS (: point , n + 1 )) envels % critical_points = cps end subroutine subroutine injection_envelope_three_phase ( X0 , spec_number , del_S0 , envels ) use constants , only : ouput_path !! Subroutine to calculate Px phase envelopes via continuation method. !! Three phases version. real ( pr ), intent ( in ) :: X0 (:) !! Vector of variables integer , intent ( in ) :: spec_number !! Number of specification real ( pr ), intent ( in ) :: del_S0 !! \\Delta S_0 type ( injelope ), intent ( out ) :: envels !! Calculated envelopes type ( critical_point ), allocatable :: cps (:) real ( pr ) :: X ( size ( X0 )) integer :: ns real ( pr ) :: S real ( pr ) :: XS ( max_points , size ( X0 )) real ( pr ) :: F ( size ( X0 )), dF ( size ( X0 ), size ( X0 )), dXdS ( size ( X0 )) integer :: point , iters , n integer :: i integer :: funit_output character ( len = 254 ) :: fname_env allocate ( cps ( 0 )) X = X0 n = ( size ( X0 ) - 3 ) / 2 ns = spec_number S = X ( ns ) del_S = del_S0 ! ====================================================================== !  Output file ! ---------------------------------------------------------------------- env_number = env_number + 1 write ( fname_env , * ) env_number fname_env = \"env-3ph-PX\" // \"_\" // trim ( adjustl ( fname_env )) fname_env = trim ( adjustl ( ouput_path )) // trim ( fname_env ) // \".dat\" open ( newunit = funit_output , file = fname_env ) write ( funit_output , * ) \"#\" , T write ( funit_output , * ) \"X0\" , iters , ns , X ( 2 * n + 2 ), exp ( X ( 2 * n + 1 )), & X ( 2 * n + 3 ), X (: 2 * n ) ! ====================================================================== enveloop : do point = 1 , max_points call full_newton ( F_injection_three_phases , iters , X , ns , S , F , dF ) if ( iters >= max_iters ) then exit enveloop end if write ( funit_output , * ) \"SOL\" , iters , ns , X ( 2 * n + 2 ), & exp ( X ( 2 * n + 1 )), X ( 2 * n + 3 ), X (: 2 * n ) XS ( point , :) = X update_spec : block real ( pr ) :: dFdS ( size ( X0 )) integer :: ns_new dFdS = 0 ! Actually it's -dFdS dFdS ( 2 * n + 3 ) = 1 dXdS = solve_system ( dF , dFdS ) if ( maxval ( abs ( X (: 2 * n ))) < 1 ) then ! T and P not allowed to be chosen close to a critical point ns_new = maxloc ( abs ( dXdS (: 2 * n )), dim = 1 ) else ns_new = maxloc ( abs ( dXdS ), dim = 1 ) end if if ( ns_new /= ns ) then del_S = dXdS ( ns_new ) * del_S ! translation of delS to the  new specification variable dXdS = dXdS / dXdS ( ns_new ) ns = ns_new end if del_S = sign ( 1.0_pr , del_S ) * minval ([ & max ( sqrt ( abs ( X ( ns ))), 0.1 ), & abs ( del_S ) * 3 / iters & ] & ) if ( injection_case == \"dilution\" ) del_S = 50 * del_S end block update_spec fix_step : block real ( pr ) :: Xnew ( size ( X0 )) real ( pr ) :: dP , dalpha Xnew = X + dXdS * del_S dP = exp ( Xnew ( 2 * n + 1 )) - exp ( X ( n + 1 )) dalpha = Xnew ( 2 * n + 2 ) - X ( n + 2 ) do while ( abs ( dP ) > 50 . or . abs ( dalpha ) > 0.03 ) dXdS = dXdS / 1 0.0_pr Xnew = X + dXdS * del_S dP = exp ( Xnew ( 2 * n + 1 )) - exp ( X ( 2 * n + 1 )) dalpha = Xnew ( 2 * n + 2 ) - X ( 2 * n + 2 ) end do end block fix_step detect_critical : block real ( pr ) :: K (( size ( X0 ) - 3 ) / 2 ), Knew (( size ( X0 ) - 3 ) / 2 ), & Xnew ( size ( X0 )), fact real ( pr ) :: pc , alpha_c , dS_c , dXdS_in ( size ( X0 )) integer :: max_changing , i fact = 1 5.0_pr Xnew = X + fact * dXdS * del_S do i = 0 , 1 K = X ( i * n + 1 :( i + 1 ) * n ) Knew = Xnew ( i * n + 1 :( i + 1 ) * n ) max_changing = minloc ( abs ( Knew - K ), dim = 1 ) if ( all ( K * Knew < 0 )) then dS_c = ( & - k ( max_changing ) * ( Xnew ( ns ) - X ( ns )) & / ( Knew ( max_changing ) - K ( max_changing )) & ) del_S = sign ( 1 5.0_pr , dS_c ) ! dS_c * 15_pr Xnew = X + dXdS * dS_c alpha_c = Xnew ( 2 * n + 2 ) pc = exp ( Xnew ( 2 * n + 1 )) cps = [ cps , critical_point ( t , pc , alpha_c )] write ( funit_output , * ) \"\" write ( funit_output , * ) \"\" end if end do end block detect_critical if ( x ( 2 * n + 3 ) > 1 ) exit enveloop X = X + dXdS * del_S S = X ( ns ) if ( any ( break_conditions_three_phases ( X , ns , S ))) exit enveloop end do enveloop point = point - 1 write ( funit_output , * ) \"\" write ( funit_output , * ) \"\" write ( funit_output , * ) \"#critical\" if ( size ( cps ) > 0 ) then do i = 1 , size ( cps ) write ( funit_output , * ) cps ( i )% alpha , cps ( i )% p end do else write ( funit_output , * ) \"NaN NaN\" end if close ( funit_output ) envels % z = z_0 envels % z_inj = z_injection envels % logk = XS (: point , : n ) envels % alpha = XS (: point , n + 2 ) envels % p = exp ( XS (: point , n + 1 )) envels % critical_points = cps end subroutine subroutine full_newton ( fun , iters , X , ns , S , F , dF ) !! Subroutine to solve a point in the envelope. !! !! Procedure that solves a point with the Newton-Raphson method. interface subroutine fun ( X , ns , S , F , dF ) !! Function to solve import pr real ( pr ), intent ( in ) :: X (:) integer , intent ( in ) :: ns real ( pr ), intent ( in ) :: S real ( pr ), intent ( out ) :: F ( size ( X )) real ( pr ), intent ( out ) :: dF ( size ( X ), size ( X )) end subroutine end interface !&< integer , intent ( out ) :: iters !! Number of iterations needed real ( pr ), intent ( in out ) :: X (:) !! Variables vector integer , intent ( in ) :: ns !! Number of specification real ( pr ), intent ( in ) :: S !! Specification value real ( pr ), intent ( out ) :: F ( size ( X )) !! Function values at solved point real ( pr ), intent ( out ) :: df ( size ( X ), size ( X )) !! Jacobian values !&> real ( pr ) :: b ( size ( X )), A ( size ( X ), size ( X )) real ( pr ) :: dX ( size ( X )), tol = 1e-5 integer :: n n = size ( X ) dX = 20 newton : do iters = 1 , max_iters * 10 if ( maxval ( abs ( dx )) < tol ) exit newton call fun ( X , ns , S , b , a ) b = - b dX = solve_system ( A , b ) do while ( maxval ( abs ( dx )) > 0.5 * maxval ( abs ( x ))) dX = dX / 2 end do X = X + dX end do newton F = - b dF = A end subroutine function break_conditions ( X , ns , S ) !! Set of conditions to break the tracing of a two phase line. real ( pr ) :: X (:) !! Vector of variables integer :: ns !! Number of specification real ( pr ) :: S !! Specification value integer :: n real ( pr ) :: p , alpha logical , allocatable :: break_conditions (:) n = size ( X ) - 2 p = exp ( X ( n + 1 )) alpha = X ( n + 2 ) break_conditions = [ & p < 10 . or . p > 2000 , & abs ( del_S ) < 1e-18 & ] end function function break_conditions_three_phases ( X , ns , S ) !! Set of conditions to break the tracing. real ( pr ) :: X (:) !! Variables vector integer :: ns !! Number of specification real ( pr ) :: S !! Value of specification integer :: n real ( pr ) :: p , alpha logical , allocatable :: break_conditions_three_phases (:) n = ( size ( X ) - 3 ) / 2 p = exp ( X ( 2 * n + 1 )) alpha = X ( 2 * n + 2 ) break_conditions_three_phases = [ & p < 10 . or . p > 3000 & ] end function subroutine get_z ( alpha , z , dzda ) !! Calculate the fluid composition based on an amount of addition !! of second fluid. !! !! The injection can be considered as two kinds of injection: !! - Displacement:  z = \\alpha z_i + (1-\\alpha) z_0  !! - Addition:   z = \\frac{\\alpha z_i + (1-\\alpha) z_0}{\\sum_{i=1}&#94;N \\alpha z_i + (1-\\alpha) z_0}  real ( pr ), intent ( in ) :: alpha !! Addition percentaje  \\alpha  real ( pr ), intent ( out ) :: z ( size ( z_0 )) !! New composition real ( pr ), intent ( out ) :: dzda ( size ( z_0 )) !! Derivative wrt \\alpha select case ( injection_case ) case ( \"displace\" ) z = ( z_injection * alpha + ( 1.0_pr - alpha ) * z_0 ) dzda = z_injection - z_0 case ( \"dilute\" ) z = ( z_injection * alpha + z_0 ) / sum ( z_injection * alpha + z_0 ) dzda = - ( alpha * z_injection + z_0 ) & * sum ( z_injection ) / sum ( alpha * z_injection + z_0 ) ** 2 & + z_injection / sum ( alpha * z_injection + z_0 ) case default z = ( z_injection * alpha + ( 1.0_pr - alpha ) * z_0 ) dzda = z_injection - z_0 end select end subroutine function get_case ( dew_envel , bub_envel ) result ( n_case ) type ( injelope ), intent ( in ) :: dew_envel type ( injelope ), intent ( in ) :: bub_envel integer :: n_case end function end module","tags":"","loc":"sourcefile/mod_inj_envelopes.f90.html"}]}