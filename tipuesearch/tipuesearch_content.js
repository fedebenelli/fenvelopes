var tipuesearch = {"pages":[{"title":" fenvelopes ","text":"fenvelopes fenvelopes Fortran program to calculate phase envelopes. This is an ongoing project that intends te be a fully fledged generator of phase\nequilibria diagrams using Equations of State. Capabilities Right now fenvelopes calculates three kinds of phase-envelopes. [x] Two-phase PT envelopes [o] Three-phase PT envelopes [x] PT envelopes based on double saturation points. [ ] Isolated PT envelopes [x] Two-phase Px envelopes [ ] Three-phase Px envelopes [x] Px envelopes based on double saturation points. [ ] Isolated Px envelopes. [ ] Python wrappers to ease up scripting and plotting. Usage This program is intended to be used as a CLI software. The command used to\ncalculate phase diagrams is: fenvelopes --infile input_file.nml This will generate an fenvelopes_output directory. Which contains all the\ngenerated output files with the relevant data. Input files The input files ! input.nml ! ! Namelist based input file ! ========================= ! ! Units: !  - Pressure: bar !  - Temperature: K !  - Volume: L ! ========================= & nml_setup ! General settings nc = 5 , ! Number of components model = \"PR78\" , ! SRK PR76 PR78 mixrule = \"ClassicVdW\" ! only ClassicVdW for now / & nml_composition names = \"PC1\" \"PC2\" \"PC3\" \"PC4\" \"H2O\" spec = \"critical\" , ! critical or parameters specification z = 0.15 0.10 0.10 0.15 0.50 / & nml_classicvdw ! Classic VdW mixing rule parameters ! kij matrix kij ( 1 , :) = 0 0 0 0 0.7192 kij ( 2 , :) = 0 0 0 0 0.4598 kij ( 3 , :) = 0 0 0 0 0.2673 kij ( 4 , :) = 0 0 0 0 0.2417 kij ( 5 , :) = 0.7192 0.4598 0.2673 0.2417 0 ! lij matrix lij (:, :) = 0 / & nml_critical ! Critical constants ! Critical Temperature tc = 30 5.586 63 8.889 78 8.889 83 8.889 64 7.3 ! Critical Pressure pc = 4 8.82 1 9.65 1 0.2 7.72 22 0.89 ! Acentric Factor w = 0.098 0.535 0.891 1.085 0.344 / & nml_px ! Px envelopes relevant info ! Temperature T = 35 0.0 ! Initial composition, ussualy the same as the main fluid. z_0 = 0.15 0.10 0.10 0.15 0.50 ! Injection fluid composition z_injection = 1 0 0 0 0 ! Which kind of injection to realize injection_case = \"displace\" ! [dilute|displace] / Output All the output is directed to a generated folder fenvelopes_output . With the files env-<nphases>ph-<env_kind>_<envnumber>.dat Were all the envelope’s calculated points are written in a csv-like format,\ndelimited by spaces. Installation This program uses fpm as a builder. fpm handles all the needed dependencies and compiling procedures.\nIt is distributed in many ways, but we recommend the pip distribution. # using pipx pipx install fpm To install this program is as simple as: git clone https://www.github.com/fedebenelli/envelopes\ncd envelopes\nfpm install --profile release This will make fenvelopes accessible from any directory of your computer If you don’t want to install the program and just run it you can also run it\nwith fpm fpm run --profile release -- --infile <infile.nml PATH> Developer Info Federico Benelli PhD student with focus on reservoir PVT simulation.","tags":"home","loc":"index.html"},{"title":"point – fenvelopes ","text":"type, public :: point Contents Variables i j x y Components Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=pr), public :: x real(kind=pr), public :: y","tags":"","loc":"type/point.html"},{"title":"AbsEnvel – fenvelopes ","text":"type, public, abstract :: AbsEnvel Inherited by type~~absenvel~~InheritedByGraph type~absenvel AbsEnvel type~ptenvel3 PTEnvel3 type~ptenvel3->type~absenvel Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents None","tags":"","loc":"type/absenvel.html"},{"title":"critical_point – fenvelopes ","text":"type, public :: critical_point Inherited by type~~critical_point~~InheritedByGraph type~critical_point critical_point type~envelope envelope type~envelope->type~critical_point critical_points type~ptenvel3 PTEnvel3 type~ptenvel3->type~critical_point critical_points type~env3 env3 type~env3->type~critical_point ll_critical_points type~env3->type~envelope type~injelope injelope type~injelope->type~envelope Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables alpha p t Components Type Visibility Attributes Name Initial real(kind=pr), private :: alpha real(kind=pr), private :: p real(kind=pr), private :: t","tags":"","loc":"type/critical_point.html"},{"title":"env3 – fenvelopes ","text":"type, public, extends( envelope ) :: env3 Inherits type~~env3~~InheritsGraph type~env3 env3 type~critical_point critical_point type~env3->type~critical_point ll_critical_points type~envelope envelope type~env3->type~envelope type~envelope->type~critical_point critical_points Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables beta ll_critical_points logks w x y Type-Bound Procedures write Components Type Visibility Attributes Name Initial real(kind=pr), private, allocatable :: beta (:) Other phase fraction type( critical_point ), private, allocatable :: ll_critical_points (:) real(kind=pr), private, allocatable :: logks (:,:) ln(Ks) real(kind=pr), private, allocatable :: w (:,:) real(kind=pr), private, allocatable :: x (:,:) real(kind=pr), private, allocatable :: y (:,:) Type-Bound Procedures procedure, public :: write => write_envel_3 private subroutine write_envel_3 (self, file_name) Arguments Type Intent Optional Attributes Name class( env3 ), intent(in) :: self character(len=*), intent(in), optional :: file_name","tags":"","loc":"type/env3.html"},{"title":"envelope – fenvelopes ","text":"type, public :: envelope Inherits type~~envelope~~InheritsGraph type~envelope envelope type~critical_point critical_point type~envelope->type~critical_point critical_points Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Inherited by type~~envelope~~InheritedByGraph type~envelope envelope type~env3 env3 type~env3->type~envelope type~injelope injelope type~injelope->type~envelope Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables critical_points logk logphi p t vars z Type-Bound Procedures write Components Type Visibility Attributes Name Initial type( critical_point ), private, allocatable :: critical_points (:) Critical points real(kind=pr), private, allocatable :: logk (:,:) ln(K) for each point real(kind=pr), private, allocatable :: logphi (:,:) lnphi for each point real(kind=pr), private, allocatable :: p (:) Pressure points real(kind=pr), private, allocatable :: t (:) Temperature points real(kind=pr), private, allocatable :: vars (:,:) Value of the set of variables at each point real(kind=pr), private, allocatable :: z (:) Global composition Type-Bound Procedures procedure, public :: write => write_envel_2 private subroutine write_envel_2 (self, file_name) Arguments Type Intent Optional Attributes Name class( envelope ), intent(in) :: self character(len=*), intent(in), optional :: file_name Ouptut file name","tags":"","loc":"type/envelope.html"},{"title":"PTEnvel3 – fenvelopes ","text":"type, public, extends( AbsEnvel ) :: PTEnvel3 Inherits type~~ptenvel3~~InheritsGraph type~ptenvel3 PTEnvel3 type~critical_point critical_point type~ptenvel3->type~critical_point critical_points type~absenvel AbsEnvel type~ptenvel3->type~absenvel Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables P T beta critical_points lnKx lnKy n Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: P (:) real(kind=pr), public, allocatable :: T (:) real(kind=pr), public, allocatable :: beta (:) type( critical_point ), public, allocatable :: critical_points (:) real(kind=pr), public, allocatable :: lnKx (:,:) real(kind=pr), public, allocatable :: lnKy (:,:) integer, public :: n","tags":"","loc":"type/ptenvel3.html"},{"title":"injelope – fenvelopes ","text":"type, public, extends( envelope ) :: injelope Inherits type~~injelope~~InheritsGraph type~injelope injelope type~envelope envelope type~injelope->type~envelope type~critical_point critical_point type~envelope->type~critical_point critical_points Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables alpha z_inj z_mix Type-Bound Procedures write Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: alpha (:) Ammount of injected fluid real(kind=pr), public, allocatable :: z_inj (:) Injected fluid composition real(kind=pr), public, allocatable :: z_mix (:,:) Composition at each step Type-Bound Procedures procedure, public :: write => write_envel_2 private subroutine write_envel_2 (self, file_name) Arguments Type Intent Optional Attributes Name class( envelope ), intent(in) :: self character(len=*), intent(in), optional :: file_name Ouptut file name","tags":"","loc":"type/injelope.html"},{"title":"betalimits – fenvelopes","text":"public subroutine betalimits(n, z, KFACT, bmin, bmax) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=8), intent(in), dimension(n) :: z real(kind=8), intent(in), dimension(n) :: KFACT real(kind=8), intent(out) :: bmin real(kind=8), intent(out) :: bmax Called by proc~~betalimits~~CalledByGraph proc~betalimits betalimits proc~flash flash proc~flash->proc~betalimits Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i in ix vmax vmin Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: in integer, public :: ix real(kind=8), public, dimension(n) :: vmax real(kind=8), public, dimension(n) :: vmin","tags":"","loc":"proc/betalimits.html"},{"title":"betato01 – fenvelopes","text":"public subroutine betato01(n, z, KFACT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=8), intent(in), dimension(n) :: z real(kind=8), dimension(n) :: KFACT Called by proc~~betato01~~CalledByGraph proc~betato01 betato01 proc~flash flash proc~flash->proc~betato01 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables g0 g1 Variables Type Visibility Attributes Name Initial real(kind=8), public :: g0 real(kind=8), public :: g1","tags":"","loc":"proc/betato01.html"},{"title":"flash – fenvelopes","text":"public subroutine flash(spec, FIRST, z, t, p, v, x, y, rho_x, rho_y, beta, iter) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: spec Flash specification [PT | VT] logical, intent(inout) :: FIRST real(kind=8), intent(in) :: z (:) real(kind=8), intent(in) :: t real(kind=8) :: p real(kind=8) :: v real(kind=8), intent(out), dimension(size(z)) :: x real(kind=8), intent(out), dimension(size(z)) :: y real(kind=8), intent(out) :: rho_x real(kind=8), intent(out) :: rho_y real(kind=8), intent(out) :: beta integer, intent(out) :: iter Calls proc~~flash~~CallsGraph proc~flash flash ztvtermo ztvtermo proc~flash->ztvtermo termo termo proc~flash->termo proc~betalimits betalimits proc~flash->proc~betalimits proc~betato01 betato01 proc~flash->proc~betato01 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables AUXK DLPHIP DLPHIT DPVl FUGN KFACT LOG_K MTYP PHILOGx PHILOGy Vx Vy aux bij bmax bmin bx dVydVl denom dg dh dpv dpvv g g0 g1 h i iterv j logKold log_k2 nco pl pold pold2 pv savek step stepv stopflash told told2 varKold var_K Variables Type Visibility Attributes Name Initial real(kind=8), public, dimension(n) :: AUXK real(kind=8), public, dimension(n) :: DLPHIP real(kind=8), public, dimension(n) :: DLPHIT real(kind=8), public :: DPVl real(kind=8), public, dimension(n, n) :: FUGN real(kind=8), public, dimension(n) :: KFACT real(kind=8), public, dimension(n) :: LOG_K integer, public :: MTYP real(kind=8), public, dimension(n) :: PHILOGx real(kind=8), public, dimension(n) :: PHILOGy real(kind=8), public :: Vx real(kind=8), public :: Vy real(kind=8), public :: aux real(kind=8), public :: bij (n,n) real(kind=8), public :: bmax real(kind=8), public :: bmin real(kind=8), public :: bx real(kind=8), public :: dVydVl real(kind=8), public, dimension(n) :: denom real(kind=8), public :: dg real(kind=8), public :: dh real(kind=8), public :: dpv real(kind=8), public :: dpvv real(kind=8), public :: g real(kind=8), public :: g0 real(kind=8), public :: g1 real(kind=8), public :: h integer, public :: i integer, public :: iterv integer, public :: j real(kind=8), public, dimension(n) :: logKold real(kind=8), public :: log_k2 (n) integer, public :: nco real(kind=8), public :: pl real(kind=8), public :: pold real(kind=8), public :: pold2 real(kind=8), public :: pv real(kind=8), public :: savek (n) real(kind=8), public :: step real(kind=8), public :: stepv logical, public :: stopflash real(kind=8), public :: told real(kind=8), public :: told2 real(kind=8), public, dimension(n) :: varKold real(kind=8), public, dimension(n) :: var_K","tags":"","loc":"proc/flash.html"},{"title":"flash_pt – fenvelopes","text":"public subroutine flash_pt(z, p, t, x, y, beta, its) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Feed phase molar fractions real(kind=pr), intent(in) :: p Pressure [bar] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out) :: x (size(z)) Phase X molar fractions real(kind=pr), intent(out) :: y (size(z)) Phase Y molar fractions real(kind=pr), intent(out) :: beta Molar Y fraction real(kind=pr), intent(out), optional :: its Number of iterations Contents Variables rho_x rho_y Variables Type Visibility Attributes Name Initial real(kind=pr), public :: rho_x real(kind=pr), public :: rho_y","tags":"","loc":"proc/flash_pt.html"},{"title":"interpol – fenvelopes","text":"public elemental function interpol(x1, x2, y1, y2, x_obj) result(y) Linear interpolation. Calculates the linear interpolation between two points at a desired\nx value with the equation: Since this function is defined as elemental it will also interpolate\na set of vectors. Examples of usage: x1 = 2 x2 = 5 y1 = 2 y2 = 9 y = interpol ( x1 , x2 , y1 , y2 , 2.3 ) x1 = 2 x2 = 5 y1 = [ 2 , 6 ] y2 = [ 9 , 15 ] y = interpol ( x1 , x2 , y1 , y2 , 2.3 ) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x1 First point x value real(kind=pr), intent(in) :: x2 Second point x value real(kind=pr), intent(in) :: y1 First point y value real(kind=pr), intent(in) :: y2 Second point y value real(kind=pr), intent(in) :: x_obj Desired x value to interpolate Return Value real(kind=pr) y value at x_obj Called by proc~~interpol~~CalledByGraph proc~interpol interpol proc~pt_three_phase_from_intersection pt_three_phase_from_intersection proc~pt_three_phase_from_intersection->proc~interpol proc~px_three_phase_from_pt px_three_phase_from_pt proc~px_three_phase_from_pt->proc~interpol proc~dsp_line_from_dsp dsp_line_from_dsp proc~dsp_line_from_dsp->proc~interpol proc~px_three_phase_from_inter px_three_phase_from_inter proc~px_three_phase_from_inter->proc~interpol proc~px_two_phase_from_pt px_two_phase_from_pt proc~px_two_phase_from_pt->proc~interpol proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~pt_three_phase_from_intersection proc~pt_envelopes->proc~dsp_line_from_dsp proc~px_envelopes px_envelopes proc~px_envelopes->proc~px_three_phase_from_pt proc~px_envelopes->proc~px_three_phase_from_inter proc~px_envelopes->proc~px_two_phase_from_pt program~main main program~main->proc~pt_envelopes program~main->proc~px_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/interpol.html"},{"title":"intersect_one_line – fenvelopes","text":"public function intersect_one_line(lx, ly) result(intersections) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lx (:) real(kind=pr), intent(in) :: ly (:) Return Value type( point ),allocatable,(:) Calls proc~~intersect_one_line~~CallsGraph proc~intersect_one_line intersect_one_line proc~intersects intersects proc~intersect_one_line->proc~intersects proc~solve_system solve_system proc~intersects->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~intersect_one_line~~CalledByGraph proc~intersect_one_line intersect_one_line interface~intersection intersection interface~intersection->proc~intersect_one_line proc~get_case get_case proc~get_case->interface~intersection proc~px_envelopes px_envelopes proc~px_envelopes->interface~intersection proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~get_case program~main main program~main->proc~px_envelopes program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j s t x xold y yold Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=pr), public :: s real(kind=pr), public :: t real(kind=pr), public :: x real(kind=pr), public :: xold = 9999 real(kind=pr), public :: y real(kind=pr), public :: yold = 9999","tags":"","loc":"proc/intersect_one_line.html"},{"title":"intersect_two_lines – fenvelopes","text":"public function intersect_two_lines(l1_x, l1_y, l2_x, l2_y) result(intersections) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: l1_x (:) real(kind=pr), intent(in) :: l1_y (:) real(kind=pr), intent(in) :: l2_x (:) real(kind=pr), intent(in) :: l2_y (:) Return Value type( point ),allocatable,(:) Calls proc~~intersect_two_lines~~CallsGraph proc~intersect_two_lines intersect_two_lines proc~intersects intersects proc~intersect_two_lines->proc~intersects proc~solve_system solve_system proc~intersects->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~intersect_two_lines~~CalledByGraph proc~intersect_two_lines intersect_two_lines interface~intersection intersection interface~intersection->proc~intersect_two_lines proc~get_case get_case proc~get_case->interface~intersection proc~px_envelopes px_envelopes proc~px_envelopes->interface~intersection proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~get_case program~main main program~main->proc~px_envelopes program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j s t x xold y yold Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=pr), public :: s real(kind=pr), public :: t real(kind=pr), public :: x real(kind=pr), public :: xold = 9999 real(kind=pr), public :: y real(kind=pr), public :: yold = 9999","tags":"","loc":"proc/intersect_two_lines.html"},{"title":"solve_system – fenvelopes","text":"public function solve_system(a, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: a (size(b),size(b)) real(kind=pr), intent(in) :: b (:) Return Value real(kind=pr)(size(b)) Calls proc~~solve_system~~CallsGraph proc~solve_system solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~solve_system~~CalledByGraph proc~solve_system solve_system proc~update_specification update_specification proc~update_specification->proc~solve_system proc~pt_envelope_three_phase pt_envelope_three_phase proc~pt_envelope_three_phase->proc~solve_system proc~full_newton full_newton proc~pt_envelope_three_phase->proc~full_newton proc~intersects intersects proc~intersects->proc~solve_system proc~full_newton->proc~solve_system proc~envelope2 envelope2 proc~envelope2->proc~solve_system proc~envelope2->proc~update_specification proc~update_spec update_spec proc~update_spec->proc~solve_system proc~pt_three_phase_from_intersection pt_three_phase_from_intersection proc~pt_three_phase_from_intersection->proc~pt_envelope_three_phase proc~intersect_two_lines intersect_two_lines proc~intersect_two_lines->proc~intersects proc~injection_envelope injection_envelope proc~injection_envelope->proc~full_newton proc~injection_envelope->proc~update_spec proc~dsp_line dsp_line proc~dsp_line->proc~full_newton proc~dsp_line->proc~update_spec proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~envelope2 proc~pt_envelopes->proc~pt_three_phase_from_intersection proc~dsp_line_from_dsp dsp_line_from_dsp proc~pt_envelopes->proc~dsp_line_from_dsp proc~get_case get_case proc~pt_envelopes->proc~get_case proc~intersect_one_line intersect_one_line proc~intersect_one_line->proc~intersects proc~injection_envelope_three_phase injection_envelope_three_phase proc~injection_envelope_three_phase->proc~full_newton proc~injection_envelope_three_phase->proc~update_spec interface~intersection intersection interface~intersection->proc~intersect_two_lines interface~intersection->proc~intersect_one_line program~main main program~main->proc~pt_envelopes proc~px_envelopes px_envelopes program~main->proc~px_envelopes proc~px_hpl_line px_hpl_line proc~px_hpl_line->proc~injection_envelope proc~px_three_phase_from_pt px_three_phase_from_pt proc~px_three_phase_from_pt->proc~injection_envelope_three_phase proc~dsp_line_from_dsp->proc~dsp_line proc~px_two_phase_from_pt px_two_phase_from_pt proc~px_two_phase_from_pt->proc~injection_envelope proc~px_three_phase_from_inter px_three_phase_from_inter proc~px_three_phase_from_inter->proc~injection_envelope_three_phase proc~get_case->interface~intersection proc~px_envelopes->interface~intersection proc~px_envelopes->proc~px_hpl_line proc~px_envelopes->proc~px_three_phase_from_pt proc~px_envelopes->proc~px_two_phase_from_pt proc~px_envelopes->proc~px_three_phase_from_inter Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables a_lapack b_lapack info ipiv lda ldb n nrhs Interfaces dgesv Variables Type Visibility Attributes Name Initial real(kind=8), public :: a_lapack (size(b),size(b)) real(kind=8), public :: b_lapack (size(b)) integer, public :: info integer, public :: ipiv (size(b)) integer, public :: lda integer, public :: ldb integer, public :: n integer, public :: nrhs Interfaces interface subroutine dgesv(n, nrhs, a, lda, ipiv, b, ldb, info) Arguments Type Intent Optional Attributes Name integer :: n integer :: nrhs real(kind=8) :: a (n,n) integer :: lda integer :: ipiv (n) real(kind=8) :: b (n) integer :: ldb integer :: info","tags":"","loc":"proc/solve_system.html"},{"title":"full_newton – fenvelopes","text":"public subroutine full_newton(fun, iters, X, ns, S, max_iters, F, df) Uses minpack_module constants proc~~full_newton~~UsesGraph proc~full_newton full_newton minpack_module minpack_module proc~full_newton->minpack_module module~constants constants proc~full_newton->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Subroutine to solve a point in the envelope. Procedure that solves a point with the Newton-Raphson method. Arguments Type Intent Optional Attributes Name public subroutine fun(X, ns, S, F, dF) Function to solve Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (size(X)) real(kind=pr), intent(out) :: dF (size(X),size(X)) integer, intent(out) :: iters Number of iterations needed real(kind=pr), intent(inout) :: X (:) Variables vector integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value integer, intent(in) :: max_iters Maximum iterations real(kind=pr), intent(out) :: F (size(X)) Function values at solved point real(kind=pr), intent(out) :: df (size(X),size(X)) Jacobian values Calls proc~~full_newton~~CallsGraph proc~full_newton full_newton proc~solve_system solve_system proc~full_newton->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~full_newton~~CalledByGraph proc~full_newton full_newton proc~pt_envelope_three_phase pt_envelope_three_phase proc~pt_envelope_three_phase->proc~full_newton proc~injection_envelope_three_phase injection_envelope_three_phase proc~injection_envelope_three_phase->proc~full_newton proc~injection_envelope injection_envelope proc~injection_envelope->proc~full_newton proc~dsp_line dsp_line proc~dsp_line->proc~full_newton proc~pt_three_phase_from_intersection pt_three_phase_from_intersection proc~pt_three_phase_from_intersection->proc~pt_envelope_three_phase proc~px_three_phase_from_pt px_three_phase_from_pt proc~px_three_phase_from_pt->proc~injection_envelope_three_phase proc~px_hpl_line px_hpl_line proc~px_hpl_line->proc~injection_envelope proc~px_three_phase_from_inter px_three_phase_from_inter proc~px_three_phase_from_inter->proc~injection_envelope_three_phase proc~px_two_phase_from_pt px_two_phase_from_pt proc~px_two_phase_from_pt->proc~injection_envelope proc~dsp_line_from_dsp dsp_line_from_dsp proc~dsp_line_from_dsp->proc~dsp_line proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~pt_three_phase_from_intersection proc~pt_envelopes->proc~dsp_line_from_dsp proc~px_envelopes px_envelopes proc~px_envelopes->proc~px_three_phase_from_pt proc~px_envelopes->proc~px_hpl_line proc~px_envelopes->proc~px_three_phase_from_inter proc~px_envelopes->proc~px_two_phase_from_pt program~main main program~main->proc~pt_envelopes program~main->proc~px_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables A b dX fjac funit fvec info ldfjac lwa n tol wa Subroutines fcn Variables Type Visibility Attributes Name Initial real(kind=pr), public :: A (size(X),size(X)) real(kind=pr), public :: b (size(X)) real(kind=pr), public :: dX (size(X)) real(kind=pr), public :: fjac (size(x),size(x)) integer, public :: funit real(kind=pr), public :: fvec (size(x)) integer, public :: info integer, public :: ldfjac integer, public :: lwa integer, public :: n real(kind=pr), public :: tol = 1e-6 real(kind=pr), public, allocatable :: wa (:) Subroutines subroutine fcn(N, x, fvec, fjac, ldfjac, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: N real(kind=pr), intent(in) :: x (n) real(kind=pr), intent(inout) :: fvec (n) real(kind=pr), intent(inout) :: fjac (ldfjac,n) integer, intent(in) :: ldfjac integer, intent(inout) :: iflag","tags":"","loc":"proc/full_newton.html"},{"title":"intersects – fenvelopes","text":"public subroutine intersects(x1, x2, x3, x4, y1, y2, y3, y4, s, t) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x1 real(kind=pr), intent(in) :: x2 real(kind=pr), intent(in) :: x3 real(kind=pr), intent(in) :: x4 real(kind=pr), intent(in) :: y1 real(kind=pr), intent(in) :: y2 real(kind=pr), intent(in) :: y3 real(kind=pr), intent(in) :: y4 real(kind=pr), intent(out) :: s real(kind=pr), intent(out) :: t Calls proc~~intersects~~CallsGraph proc~intersects intersects proc~solve_system solve_system proc~intersects->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~intersects~~CalledByGraph proc~intersects intersects proc~intersect_one_line intersect_one_line proc~intersect_one_line->proc~intersects proc~intersect_two_lines intersect_two_lines proc~intersect_two_lines->proc~intersects interface~intersection intersection interface~intersection->proc~intersect_one_line interface~intersection->proc~intersect_two_lines proc~get_case get_case proc~get_case->interface~intersection proc~px_envelopes px_envelopes proc~px_envelopes->interface~intersection proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~get_case program~main main program~main->proc~px_envelopes program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables A b tmp Variables Type Visibility Attributes Name Initial real(kind=pr), public :: A (2,2) real(kind=pr), public :: b (2) real(kind=pr), public :: tmp","tags":"","loc":"proc/intersects.html"},{"title":"intersection – fenvelopes","text":"public interface intersection Calls interface~~intersection~~CallsGraph interface~intersection intersection proc~intersect_two_lines intersect_two_lines interface~intersection->proc~intersect_two_lines proc~intersect_one_line intersect_one_line interface~intersection->proc~intersect_one_line proc~intersects intersects proc~intersect_two_lines->proc~intersects proc~intersect_one_line->proc~intersects proc~solve_system solve_system proc~intersects->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by interface~~intersection~~CalledByGraph interface~intersection intersection proc~get_case get_case proc~get_case->interface~intersection proc~px_envelopes px_envelopes proc~px_envelopes->interface~intersection proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~get_case program~main main program~main->proc~px_envelopes program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Module Procedures intersect_two_lines intersect_one_line Module Procedures public function intersect_two_lines (l1_x, l1_y, l2_x, l2_y) result(intersections) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: l1_x (:) real(kind=pr), intent(in) :: l1_y (:) real(kind=pr), intent(in) :: l2_x (:) real(kind=pr), intent(in) :: l2_y (:) Return Value type( point ),allocatable, (:) public function intersect_one_line (lx, ly) result(intersections) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lx (:) real(kind=pr), intent(in) :: ly (:) Return Value type( point ),allocatable, (:)","tags":"","loc":"interface/intersection.html"},{"title":"print_header – fenvelopes","text":"public subroutine print_header(name) Arguments Type Intent Optional Attributes Name character(len=250), intent(in) :: name Contents None","tags":"","loc":"proc/print_header.html"},{"title":"write_critical_points – fenvelopes","text":"private subroutine write_critical_points(self, file_name) Arguments Type Intent Optional Attributes Name type( critical_point ), intent(in) :: self (:) character(len=*), intent(in), optional :: file_name Ouptut file name Called by proc~~write_critical_points~~CalledByGraph proc~write_critical_points write_critical_points proc~write_envel_3 write_envel_3 proc~write_envel_3->proc~write_critical_points Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables file_unit filename i Variables Type Visibility Attributes Name Initial integer, private :: file_unit character(len=:), private, allocatable :: filename integer, private :: i","tags":"","loc":"proc/write_critical_points.html"},{"title":"write_envel_2 – fenvelopes","text":"private subroutine write_envel_2(self, file_name) Arguments Type Intent Optional Attributes Name class( envelope ), intent(in) :: self character(len=*), intent(in), optional :: file_name Ouptut file name Calls proc~~write_envel_2~~CallsGraph proc~write_envel_2 write_envel_2 str str proc~write_envel_2->str p p proc~write_envel_2->p t t proc~write_envel_2->t logk logk proc~write_envel_2->logk Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables file_unit filename i n n_components Variables Type Visibility Attributes Name Initial integer, private :: file_unit character(len=:), private, allocatable :: filename integer, private :: i integer, private :: n integer, private :: n_components","tags":"","loc":"proc/write_envel_2.html"},{"title":"write_envel_3 – fenvelopes","text":"private subroutine write_envel_3(self, file_name) Arguments Type Intent Optional Attributes Name class( env3 ), intent(in) :: self character(len=*), intent(in), optional :: file_name Calls proc~~write_envel_3~~CallsGraph proc~write_envel_3 write_envel_3 str str proc~write_envel_3->str proc~write_critical_points write_critical_points proc~write_envel_3->proc~write_critical_points x x proc~write_envel_3->x logks logks proc~write_envel_3->logks logk logk proc~write_envel_3->logk p p proc~write_envel_3->p t t proc~write_envel_3->t beta beta proc~write_envel_3->beta y y proc~write_envel_3->y w w proc~write_envel_3->w Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables file_unit filename i n n_components Variables Type Visibility Attributes Name Initial integer, private :: file_unit character(len=:), private, allocatable :: filename integer, private :: i integer, private :: n integer, private :: n_components","tags":"","loc":"proc/write_envel_3.html"},{"title":"nelmin – fenvelopes","text":"public subroutine nelmin(fn, n, start, xmin, ynewlo, reqmin, step, konvge, kcount, icount, numres, ifault) * * * * * * * * * * * *80 nelmin() minimizes a function using the Nelder-Mead algorithm. Arguments Type Intent Optional Attributes Name public function fn(x) Arguments Type Intent Optional Attributes Name real(kind=rk) :: x (:) Return Value real(kind=rk) integer :: n real(kind=rk) :: start (n) real(kind=rk) :: xmin (n) real(kind=rk) :: ynewlo real(kind=rk) :: reqmin real(kind=rk) :: step (n) integer :: konvge integer :: kcount integer :: icount integer :: numres integer :: ifault Called by proc~~nelmin~~CalledByGraph proc~nelmin nelmin proc~nm_opt nm_opt proc~nm_opt->proc~nelmin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ccoeff del ecoeff eps i ihi ilo j jcount l p p2star pbar pstar rcoeff rk rq x y y2star ylo ystar z Variables Type Visibility Attributes Name Initial real(kind=rk), public, parameter :: ccoeff = 0.5D+00 real(kind=rk), public :: del real(kind=rk), public, parameter :: ecoeff = 2.0D+00 real(kind=rk), public, parameter :: eps = 0.001D+00 integer, public :: i integer, public :: ihi integer, public :: ilo integer, public :: j integer, public :: jcount integer, public :: l real(kind=rk), public :: p (n,n+1) real(kind=rk), public :: p2star (n) real(kind=rk), public :: pbar (n) real(kind=rk), public :: pstar (n) real(kind=rk), public, parameter :: rcoeff = 1.0D+00 integer, public, parameter :: rk = kind(1.0D+00) real(kind=rk), public :: rq real(kind=rk), public :: x real(kind=rk), public :: y (n+1) real(kind=rk), public :: y2star real(kind=rk), public :: ylo real(kind=rk), public :: ystar real(kind=rk), public :: z","tags":"","loc":"proc/nelmin.html"},{"title":"nm_opt – fenvelopes","text":"public subroutine nm_opt(f, xguess, stat, step) Arguments Type Intent Optional Attributes Name public function f(x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x (:) Return Value real(kind=8) real(kind=8), intent(inout) :: xguess (:) integer :: stat real(kind=8) :: step (size(xguess)) Calls proc~~nm_opt~~CallsGraph proc~nm_opt nm_opt proc~nelmin nelmin proc~nm_opt->proc~nelmin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables n reqmin start xmin ynewlo Variables Type Visibility Attributes Name Initial integer, public :: n real(kind=8), public :: reqmin real(kind=8), public :: start (size(xguess)) real(kind=8), public :: xmin (size(xguess)) real(kind=8), public :: ynewlo","tags":"","loc":"proc/nm_opt.html"},{"title":"X2 – fenvelopes","text":"public function X2(kfact, P, T) result(X) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: kfact (nc) real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: T Return Value real(kind=pr)(nc+2) Contents Variables n Variables Type Visibility Attributes Name Initial integer, public :: n","tags":"","loc":"proc/x2.html"},{"title":"break_conditions_three_phases – fenvelopes","text":"public function break_conditions_three_phases(X, ns, S) Set of conditions to break the tracing. Arguments Type Intent Optional Attributes Name real(kind=pr) :: X (:) Variables vector integer :: ns Number of specification real(kind=pr) :: S Value of specification Return Value logical,allocatable,(:) Called by proc~~break_conditions_three_phases~~CalledByGraph proc~break_conditions_three_phases break_conditions_three_phases proc~pt_envelope_three_phase pt_envelope_three_phase proc~pt_envelope_three_phase->proc~break_conditions_three_phases proc~pt_three_phase_from_intersection pt_three_phase_from_intersection proc~pt_three_phase_from_intersection->proc~pt_envelope_three_phase proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~pt_three_phase_from_intersection program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables beta n p t Variables Type Visibility Attributes Name Initial real(kind=pr), public :: beta integer, public :: n real(kind=pr), public :: p real(kind=pr), public :: t","tags":"","loc":"proc/break_conditions_three_phases.html"},{"title":"k_wilson – fenvelopes","text":"public function k_wilson(t, p) result(k) Uses legacy_ar_models proc~~k_wilson~~UsesGraph proc~k_wilson k_wilson legacy_ar_models legacy_ar_models proc~k_wilson->legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: p Return Value real(kind=pr)(size(pc)) Called by proc~~k_wilson~~CalledByGraph proc~k_wilson k_wilson proc~k_wilson_bubble k_wilson_bubble proc~k_wilson_bubble->proc~k_wilson proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~k_wilson proc~pt_envelopes->proc~k_wilson_bubble program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/k_wilson.html"},{"title":"p_wilson – fenvelopes","text":"public function p_wilson(z, t) result(p) Uses legacy_ar_models proc~~p_wilson~~UsesGraph proc~p_wilson p_wilson legacy_ar_models legacy_ar_models proc~p_wilson->legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: t Return Value real(kind=pr) Called by proc~~p_wilson~~CalledByGraph proc~p_wilson p_wilson proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~p_wilson program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/p_wilson.html"},{"title":"F2 – fenvelopes","text":"public subroutine F2(incipient, z, y, X, S, ns, F, dF) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: incipient real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: y (nc) real(kind=pr), intent(in) :: X (nc+2) real(kind=pr), intent(in) :: S integer, intent(in) :: ns real(kind=pr), intent(out) :: F (nc+2) real(kind=pr), intent(out) :: dF (nc+2,nc+2) Calls proc~~f2~~CallsGraph proc~f2 F2 termo termo proc~f2->termo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~f2~~CalledByGraph proc~f2 F2 proc~envelope2 envelope2 proc~envelope2->proc~f2 proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~envelope2 program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables P T Vx Vy dlnphi_dn_x dlnphi_dn_y dlnphi_dp_x dlnphi_dp_y dlnphi_dt_x dlnphi_dt_y ix iy j lnfug_x lnfug_y n Variables Type Visibility Attributes Name Initial real(kind=pr), public :: P real(kind=pr), public :: T real(kind=pr), public :: Vx real(kind=pr), public :: Vy real(kind=pr), public :: dlnphi_dn_x (nc,nc) real(kind=pr), public :: dlnphi_dn_y (nc,nc) real(kind=pr), public :: dlnphi_dp_x (nc) real(kind=pr), public :: dlnphi_dp_y (nc) real(kind=pr), public :: dlnphi_dt_x (nc) real(kind=pr), public :: dlnphi_dt_y (nc) integer, public :: ix integer, public :: iy integer, public :: j real(kind=pr), public :: lnfug_x (nc) real(kind=pr), public :: lnfug_y (nc) integer, public :: n","tags":"","loc":"proc/f2.html"},{"title":"dFdS – fenvelopes","text":"public subroutine dFdS(dF_dS) Uses legacy_ar_models proc~~dfds~~UsesGraph proc~dfds dFdS legacy_ar_models legacy_ar_models proc~dfds->legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(out) :: dF_dS (nc+2) Called by proc~~dfds~~CalledByGraph proc~dfds dFdS proc~update_specification update_specification proc~update_specification->proc~dfds proc~envelope2 envelope2 proc~envelope2->proc~update_specification proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~envelope2 program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/dfds.html"},{"title":"envelope2 – fenvelopes","text":"public subroutine envelope2(ichoice, n, z, T, P, KFACT, n_points, Tv, Pv, Dv, ncri, icri, Tcri, Pcri, Dcri, this_envelope) Uses linalg dtypes constants io proc~~envelope2~~UsesGraph proc~envelope2 envelope2 module~linalg linalg proc~envelope2->module~linalg module~dtypes dtypes proc~envelope2->module~dtypes module~constants constants proc~envelope2->module~constants io io proc~envelope2->io module~linalg->module~constants module~dtypes->module~constants module~dtypes->io iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name integer, intent(in) :: ichoice integer, intent(in) :: n real(kind=pr), intent(in) :: z (n) real(kind=pr) :: T real(kind=pr) :: P real(kind=pr), intent(inout) :: KFACT (n) integer, intent(out) :: n_points real(kind=pr), intent(out) :: Tv (max_points) real(kind=pr), intent(out) :: Pv (max_points) real(kind=pr), intent(out) :: Dv (max_points) integer, intent(out) :: ncri integer, intent(out), dimension(4) :: icri real(kind=pr), intent(out), dimension(4) :: Tcri (4) real(kind=pr), intent(out), dimension(4) :: Pcri (4) real(kind=pr), intent(out), dimension(4) :: Dcri (4) type( envelope ), intent(out) :: this_envelope Calls proc~~envelope2~~CallsGraph proc~envelope2 envelope2 str str proc~envelope2->str proc~solve_system solve_system proc~envelope2->proc~solve_system proc~fix_delx fix_delx proc~envelope2->proc~fix_delx m m proc~envelope2->m proc~update_specification update_specification proc~envelope2->proc~update_specification delta_x delta_x proc~envelope2->delta_x proc~f2 F2 proc~envelope2->proc~f2 xin xin proc~envelope2->xin none~dgesv dgesv proc~solve_system->none~dgesv proc~update_specification->proc~solve_system proc~dfds dFdS proc~update_specification->proc~dfds termo termo proc~f2->termo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~envelope2~~CalledByGraph proc~envelope2 envelope2 proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~envelope2 program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables AJ F JAC S Told Told2 Vx X Xold Xold2 bd black_i critical_points dFdS dXdS delS delX delta_t extra_slope fname_env frac funit_output i incipient_phase iter ix iy lnK_extrapolated maxP max_iter minT minmaxT ns passingcri run stepx tmp_logk tmp_logphi y Variables Type Visibility Attributes Name Initial real(kind=pr), public, dimension(n + 2, n + 2) :: AJ real(kind=pr), public, dimension(n + 2) :: F real(kind=pr), public, dimension(n + 2, n + 2) :: JAC real(kind=pr), public :: S real(kind=pr), public :: Told real(kind=pr), public :: Told2 real(kind=pr), public :: Vx real(kind=pr), public, dimension(n + 2) :: X real(kind=pr), public, dimension(n + 2) :: Xold real(kind=pr), public, dimension(n + 2) :: Xold2 real(kind=pr), public, dimension(n + 2) :: bd integer, public :: black_i type( critical_point ), public, allocatable :: critical_points (:) real(kind=pr), public, dimension(n + 2) :: dFdS real(kind=pr), public, dimension(n + 2) :: dXdS real(kind=pr), public :: delS real(kind=pr), public, dimension(n + 2) :: delX real(kind=pr), public :: delta_t real(kind=pr), public :: extra_slope (n+2) character(len=254), public :: fname_env real(kind=pr), public :: frac integer, public :: funit_output integer, public :: i character(len=:), public, allocatable :: incipient_phase integer, public :: iter integer, public :: ix integer, public :: iy real(kind=pr), public :: lnK_extrapolated (n) real(kind=pr), public :: maxP integer, public :: max_iter logical, public :: minT logical, public :: minmaxT integer, public :: ns logical, public :: passingcri logical, public :: run real(kind=pr), public :: stepx real(kind=pr), public :: tmp_logk (max_points,n) real(kind=pr), public :: tmp_logphi (max_points,n) real(kind=pr), public, dimension(n) :: y","tags":"","loc":"proc/envelope2.html"},{"title":"find_hpl – fenvelopes","text":"public subroutine find_hpl(t, p, k) Uses legacy_ar_models proc~~find_hpl~~UsesGraph proc~find_hpl find_hpl legacy_ar_models legacy_ar_models proc~find_hpl->legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Find a HPLL initial point at a given pressure Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: t real(kind=pr), intent(in) :: p real(kind=pr), intent(out) :: k (nc) Calls proc~~find_hpl~~CallsGraph proc~find_hpl find_hpl termo termo proc~find_hpl->termo z z proc~find_hpl->z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~find_hpl~~CalledByGraph proc~find_hpl find_hpl proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~find_hpl program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables diff i lnfug_y lnfug_z ncomp v x y Variables Type Visibility Attributes Name Initial real(kind=pr), public :: diff integer, public :: i real(kind=pr), public :: lnfug_y (nc) real(kind=pr), public :: lnfug_z (nc) integer, public :: ncomp real(kind=pr), public :: v real(kind=pr), public :: x (nc) real(kind=pr), public :: y (nc)","tags":"","loc":"proc/find_hpl.html"},{"title":"fix_delx – fenvelopes","text":"public subroutine fix_delx(point, iterations, desired_iterations, first_tol, tol, delX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: point integer, intent(in) :: iterations integer, intent(in) :: desired_iterations real(kind=pr), intent(in) :: first_tol real(kind=pr), intent(in) :: tol real(kind=pr), intent(inout) :: delX (:) Called by proc~~fix_delx~~CalledByGraph proc~fix_delx fix_delx proc~envelope2 envelope2 proc~envelope2->proc~fix_delx proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~envelope2 program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/fix_delx.html"},{"title":"get_case – fenvelopes","text":"public subroutine get_case(dew, bub, hpl, intersections, self_intersections, this_case) Uses linalg proc~~get_case~~UsesGraph proc~get_case get_case module~linalg linalg proc~get_case->module~linalg module~constants constants module~linalg->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( envelope ), intent(in) :: dew type( envelope ), intent(in) :: bub type( envelope ), intent(in) :: hpl type( point ), intent(out), allocatable :: intersections (:) type( point ), intent(out), allocatable :: self_intersections (:) character(len=:), intent(out), allocatable :: this_case Calls proc~~get_case~~CallsGraph proc~get_case get_case interface~intersection intersection proc~get_case->interface~intersection proc~intersect_two_lines intersect_two_lines interface~intersection->proc~intersect_two_lines proc~intersect_one_line intersect_one_line interface~intersection->proc~intersect_one_line proc~intersects intersects proc~intersect_two_lines->proc~intersects proc~intersect_one_line->proc~intersects proc~solve_system solve_system proc~intersects->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~get_case~~CalledByGraph proc~get_case get_case proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~get_case program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables inter_dew_bub inter_hpl_bub inter_hpl_dew Variables Type Visibility Attributes Name Initial type( point ), public, allocatable :: inter_dew_bub (:) type( point ), public, allocatable :: inter_hpl_bub (:) type( point ), public, allocatable :: inter_hpl_dew (:)","tags":"","loc":"proc/get_case.html"},{"title":"k_wilson_bubble – fenvelopes","text":"public subroutine k_wilson_bubble(z, t_0, p_end, t, p, k) Uses legacy_ar_models proc~~k_wilson_bubble~~UsesGraph proc~k_wilson_bubble k_wilson_bubble legacy_ar_models legacy_ar_models proc~k_wilson_bubble->legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Find the Wilson Kfactors at ~10 bar to initialize a bubble point Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: t_0 real(kind=pr), intent(in) :: p_end real(kind=pr), intent(inout) :: t real(kind=pr), intent(inout) :: p real(kind=pr), intent(out) :: k (size(z)) Calls proc~~k_wilson_bubble~~CallsGraph proc~k_wilson_bubble k_wilson_bubble proc~k_wilson k_wilson proc~k_wilson_bubble->proc~k_wilson Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~k_wilson_bubble~~CalledByGraph proc~k_wilson_bubble k_wilson_bubble proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~k_wilson_bubble program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/k_wilson_bubble.html"},{"title":"pt_F_three_phases – fenvelopes","text":"public subroutine pt_F_three_phases(Xvars, ns, S, F, df) Uses iso_fortran_env legacy_ar_models proc~~pt_f_three_phases~~UsesGraph proc~pt_f_three_phases pt_F_three_phases iso_fortran_env iso_fortran_env proc~pt_f_three_phases->iso_fortran_env legacy_ar_models legacy_ar_models proc~pt_f_three_phases->legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Function to solve at each point of a three phase envelope. The vector of variables X corresponds to: While the equations are: Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: Xvars (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(out) :: F (size(Xvars)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(Xvars),size(Xvars)) Jacobian matrix Calls proc~~pt_f_three_phases~~CallsGraph proc~pt_f_three_phases pt_F_three_phases termo termo proc~pt_f_three_phases->termo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables Kx Ky P T Vw Vx Vy beta dlnphi_dn_w dlnphi_dn_x dlnphi_dn_y dlnphi_dp_w dlnphi_dp_x dlnphi_dp_y dlnphi_dt_w dlnphi_dt_x dlnphi_dt_y dwdKx dwdKy dwdb dxdKx dxdKy dydKx dydKy i j lnfug_w lnfug_x lnfug_y n w x y Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Kx ((Size(Xvars)-3)/2) real(kind=pr), public :: Ky ((Size(Xvars)-3)/2) real(kind=pr), public :: P real(kind=pr), public :: T real(kind=pr), public :: Vw real(kind=pr), public :: Vx real(kind=pr), public :: Vy real(kind=pr), public :: beta real(kind=pr), public, dimension((Size(Xvars)-3)/2, (Size(Xvars)-3)/2) :: dlnphi_dn_w real(kind=pr), public, dimension((Size(Xvars)-3)/2, (Size(Xvars)-3)/2) :: dlnphi_dn_x real(kind=pr), public, dimension((Size(Xvars)-3)/2, (Size(Xvars)-3)/2) :: dlnphi_dn_y real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dp_w real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dp_x real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dp_y real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dt_w real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dt_x real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dt_y real(kind=pr), public :: dwdKx ((Size(Xvars)-3)/2) real(kind=pr), public :: dwdKy ((Size(Xvars)-3)/2) real(kind=pr), public :: dwdb ((Size(Xvars)-3)/2) real(kind=pr), public :: dxdKx ((Size(Xvars)-3)/2) real(kind=pr), public :: dxdKy ((Size(Xvars)-3)/2) real(kind=pr), public :: dydKx ((Size(Xvars)-3)/2) real(kind=pr), public :: dydKy ((Size(Xvars)-3)/2) integer, public :: i integer, public :: j real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: lnfug_w real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: lnfug_x real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: lnfug_y integer, public :: n real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: w real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: x real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: y","tags":"","loc":"proc/pt_f_three_phases.html"},{"title":"pt_envelope_three_phase – fenvelopes","text":"public subroutine pt_envelope_three_phase(X0, spec_number, del_S0, envel) Uses constants io proc~~pt_envelope_three_phase~~UsesGraph proc~pt_envelope_three_phase pt_envelope_three_phase module~constants constants proc~pt_envelope_three_phase->module~constants io io proc~pt_envelope_three_phase->io iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Subroutine to calculate Px phase envelopes via continuation method.\nThree phases version. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X0 (:) Vector of variables integer, intent(in) :: spec_number Number of specification real(kind=pr), intent(in) :: del_S0 type( PTEnvel3 ), intent(out) :: envel Calculated envelopes Calls proc~~pt_envelope_three_phase~~CallsGraph proc~pt_envelope_three_phase pt_envelope_three_phase str str proc~pt_envelope_three_phase->str proc~solve_system solve_system proc~pt_envelope_three_phase->proc~solve_system progress_bar progress_bar proc~pt_envelope_three_phase->progress_bar k k proc~pt_envelope_three_phase->k knew knew proc~pt_envelope_three_phase->knew xnew xnew proc~pt_envelope_three_phase->xnew proc~full_newton full_newton proc~pt_envelope_three_phase->proc~full_newton dxds_in dxds_in proc~pt_envelope_three_phase->dxds_in proc~break_conditions_three_phases break_conditions_three_phases proc~pt_envelope_three_phase->proc~break_conditions_three_phases none~dgesv dgesv proc~solve_system->none~dgesv proc~full_newton->proc~solve_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pt_envelope_three_phase~~CalledByGraph proc~pt_envelope_three_phase pt_envelope_three_phase proc~pt_three_phase_from_intersection pt_three_phase_from_intersection proc~pt_three_phase_from_intersection->proc~pt_envelope_three_phase proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~pt_three_phase_from_intersection program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables F S X XS cps dF dXdS del_S fname_env funit_output i iters n ns point Variables Type Visibility Attributes Name Initial real(kind=pr), public :: F (size(X0)) real(kind=pr), public :: S real(kind=pr), public :: X (size(X0)) real(kind=pr), public :: XS (max_points,size(X0)) type( critical_point ), public, allocatable :: cps (:) real(kind=pr), public :: dF (size(X0),size(X0)) real(kind=pr), public :: dXdS (size(X0)) real(kind=pr), public :: del_S character(len=254), public :: fname_env integer, public :: funit_output integer, public :: i integer, public :: iters integer, public :: n integer, public :: ns integer, public :: point","tags":"","loc":"proc/pt_envelope_three_phase.html"},{"title":"pt_three_phase_from_intersection – fenvelopes","text":"public subroutine pt_three_phase_from_intersection(pt_x, pt_y, intersections, pt_x_3, pt_y_3) Uses linalg legacy_ar_models proc~~pt_three_phase_from_intersection~~UsesGraph proc~pt_three_phase_from_intersection pt_three_phase_from_intersection module~linalg linalg proc~pt_three_phase_from_intersection->module~linalg legacy_ar_models legacy_ar_models proc~pt_three_phase_from_intersection->legacy_ar_models module~constants constants module~linalg->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( envelope ), intent(in) :: pt_x type( envelope ), intent(in) :: pt_y type( point ), intent(in) :: intersections (:) type( PTEnvel3 ), intent(out) :: pt_x_3 (:) type( PTEnvel3 ), intent(out) :: pt_y_3 (:) Calls proc~~pt_three_phase_from_intersection~~CallsGraph proc~pt_three_phase_from_intersection pt_three_phase_from_intersection proc~interpol interpol proc~pt_three_phase_from_intersection->proc~interpol proc~pt_envelope_three_phase pt_envelope_three_phase proc~pt_three_phase_from_intersection->proc~pt_envelope_three_phase str str proc~pt_envelope_three_phase->str proc~solve_system solve_system proc~pt_envelope_three_phase->proc~solve_system progress_bar progress_bar proc~pt_envelope_three_phase->progress_bar k k proc~pt_envelope_three_phase->k knew knew proc~pt_envelope_three_phase->knew xnew xnew proc~pt_envelope_three_phase->xnew proc~full_newton full_newton proc~pt_envelope_three_phase->proc~full_newton dxds_in dxds_in proc~pt_envelope_three_phase->dxds_in proc~break_conditions_three_phases break_conditions_three_phases proc~pt_envelope_three_phase->proc~break_conditions_three_phases none~dgesv dgesv proc~solve_system->none~dgesv proc~full_newton->proc~solve_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pt_three_phase_from_intersection~~CalledByGraph proc~pt_three_phase_from_intersection pt_three_phase_from_intersection proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~pt_three_phase_from_intersection program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables X beta del_S0 i i_inter j lnKx lnKy ns p phase_x phase_y t Variables Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: X (:) real(kind=pr), public :: beta real(kind=pr), public :: del_S0 integer, public :: i integer, public :: i_inter = 1 integer, public :: j real(kind=pr), public, allocatable :: lnKx (:) real(kind=pr), public, allocatable :: lnKy (:) integer, public :: ns real(kind=pr), public :: p real(kind=pr), public, allocatable :: phase_x (:) real(kind=pr), public, allocatable :: phase_y (:) real(kind=pr), public :: t","tags":"","loc":"proc/pt_three_phase_from_intersection.html"},{"title":"update_specification – fenvelopes","text":"public subroutine update_specification(iter, passingcri, X, dF, ns, S, delS, dXdS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iter logical, intent(in) :: passingcri real(kind=pr), intent(in) :: X (nc+2) real(kind=pr), intent(in) :: dF (nc+2,nc+2) integer, intent(inout) :: ns real(kind=pr), intent(inout) :: S real(kind=pr), intent(inout) :: delS real(kind=pr), intent(inout) :: dXdS (nc+2) Calls proc~~update_specification~~CallsGraph proc~update_specification update_specification proc~dfds dFdS proc~update_specification->proc~dfds proc~solve_system solve_system proc~update_specification->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~update_specification~~CalledByGraph proc~update_specification update_specification proc~envelope2 envelope2 proc~envelope2->proc~update_specification proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~envelope2 program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables AJ bd dF_dS delmax nsold updel Variables Type Visibility Attributes Name Initial real(kind=pr), public :: AJ (nc+2,nc+2) real(kind=pr), public :: bd (nc+2) real(kind=pr), public :: dF_dS (nc+2) real(kind=pr), public :: delmax integer, public :: nsold real(kind=pr), public :: updel","tags":"","loc":"proc/update_specification.html"},{"title":"F – fenvelopes","text":"interface public function F(X, ns, S) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S Return Value real(kind=pr)","tags":"","loc":"interface/f.html"},{"title":"read_system – fenvelopes","text":"public subroutine read_system(filepath) Arguments Type Intent Optional Attributes Name character(len=*) :: filepath Calls proc~~read_system~~CallsGraph proc~read_system read_system proc~setup_input setup_input proc~read_system->proc~setup_input proc~read_components read_components proc~read_system->proc~read_components proc~read_model read_model proc~read_system->proc~read_model proc~read_srk read_srk proc~read_components->proc~read_srk lij lij proc~read_components->lij proc~read_pr76 read_pr76 proc~read_components->proc~read_pr76 proc~read_pr78 read_pr78 proc~read_components->proc~read_pr78 proc~read_kij_lij read_kij_lij proc~read_components->proc~read_kij_lij bij bij proc~read_components->bij b b proc~read_components->b setup setup proc~read_model->setup z z proc~read_model->z srk_factory srk_factory proc~read_srk->srk_factory pr76_factory pr76_factory proc~read_pr76->pr76_factory pr78_factory pr78_factory proc~read_pr78->pr78_factory proc~read_kij_lij->lij kij kij proc~read_kij_lij->kij Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_system~~CalledByGraph proc~read_system read_system proc~setup setup proc~setup->proc~read_system program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_system.html"},{"title":"setup_input – fenvelopes","text":"public subroutine setup_input(filepath) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filepath Setup input file to be used\nPath to input file Called by proc~~setup_input~~CalledByGraph proc~setup_input setup_input proc~read_system read_system proc~read_system->proc~setup_input proc~setup setup proc~setup->proc~read_system program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setup_input.html"},{"title":"write_system – fenvelopes","text":"public subroutine write_system(file_unit) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: file_unit Calls proc~~write_system~~CallsGraph proc~write_system write_system str str proc~write_system->str lij lij proc~write_system->lij kij kij proc~write_system->kij Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~write_system~~CalledByGraph proc~write_system write_system proc~setup setup proc~setup->proc~write_system program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables fmt_names fmt_pure i Variables Type Visibility Attributes Name Initial character(len=20), private :: fmt_names character(len=20), private :: fmt_pure integer, private :: i","tags":"","loc":"proc/write_system.html"},{"title":"read_components – fenvelopes","text":"private subroutine read_components() Read components\nRead kij and lij matrixes\nSince in the ClassicVdW mixing rules the bij matrix is constant\nit’s stored beforehand Arguments None Calls proc~~read_components~~CallsGraph proc~read_components read_components proc~read_srk read_srk proc~read_components->proc~read_srk lij lij proc~read_components->lij proc~read_pr76 read_pr76 proc~read_components->proc~read_pr76 proc~read_pr78 read_pr78 proc~read_components->proc~read_pr78 proc~read_kij_lij read_kij_lij proc~read_components->proc~read_kij_lij bij bij proc~read_components->bij b b proc~read_components->b srk_factory srk_factory proc~read_srk->srk_factory pr76_factory pr76_factory proc~read_pr76->pr76_factory pr78_factory pr78_factory proc~read_pr78->pr78_factory proc~read_kij_lij->lij kij kij proc~read_kij_lij->kij Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_components~~CalledByGraph proc~read_components read_components proc~read_system read_system proc~read_system->proc~read_components proc~setup setup proc~setup->proc~read_system program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j","tags":"","loc":"proc/read_components.html"},{"title":"read_kij_lij – fenvelopes","text":"private subroutine read_kij_lij() Arguments None Calls proc~~read_kij_lij~~CallsGraph proc~read_kij_lij read_kij_lij kij kij proc~read_kij_lij->kij lij lij proc~read_kij_lij->lij Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_kij_lij~~CalledByGraph proc~read_kij_lij read_kij_lij proc~read_components read_components proc~read_components->proc~read_kij_lij proc~read_system read_system proc~read_system->proc~read_components proc~setup setup proc~setup->proc~read_system program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j","tags":"","loc":"proc/read_kij_lij.html"},{"title":"read_model – fenvelopes","text":"private subroutine read_model() Reads the thermodynamic model to be used and sets up the selector Arguments None Calls proc~~read_model~~CallsGraph proc~read_model read_model setup setup proc~read_model->setup z z proc~read_model->z Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_model~~CalledByGraph proc~read_model read_model proc~read_system read_system proc~read_system->proc~read_model proc~setup setup proc~setup->proc~read_system program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables i j Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j","tags":"","loc":"proc/read_model.html"},{"title":"read_pr76 – fenvelopes","text":"private subroutine read_pr76() Read PR76 model Arguments None Calls proc~~read_pr76~~CallsGraph proc~read_pr76 read_pr76 pr76_factory pr76_factory proc~read_pr76->pr76_factory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_pr76~~CalledByGraph proc~read_pr76 read_pr76 proc~read_components read_components proc~read_components->proc~read_pr76 proc~read_system read_system proc~read_system->proc~read_components proc~setup setup proc~setup->proc~read_system program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_pr76.html"},{"title":"read_pr78 – fenvelopes","text":"private subroutine read_pr78() Arguments None Calls proc~~read_pr78~~CallsGraph proc~read_pr78 read_pr78 pr78_factory pr78_factory proc~read_pr78->pr78_factory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_pr78~~CalledByGraph proc~read_pr78 read_pr78 proc~read_components read_components proc~read_components->proc~read_pr78 proc~read_system read_system proc~read_system->proc~read_components proc~setup setup proc~setup->proc~read_system program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_pr78.html"},{"title":"read_srk – fenvelopes","text":"private subroutine read_srk() Read SRK model parameters options: spec= critical -> Use critical constants spec= parameters -> Use EoS parameters Critical constants\nEoS parameters Arguments None Calls proc~~read_srk~~CallsGraph proc~read_srk read_srk srk_factory srk_factory proc~read_srk->srk_factory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~read_srk~~CalledByGraph proc~read_srk read_srk proc~read_components read_components proc~read_components->proc~read_srk proc~read_system read_system proc~read_system->proc~read_components proc~setup setup proc~setup->proc~read_system program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/read_srk.html"},{"title":"break_conditions_dsp_line – fenvelopes","text":"public function break_conditions_dsp_line(X, ns, S, del_S) Set of conditions to break the tracing. Arguments Type Intent Optional Attributes Name real(kind=pr) :: X (:) Variables vector integer :: ns Number of specification real(kind=pr) :: S Value of specification real(kind=pr) :: del_S Return Value logical,allocatable,(:) Called by proc~~break_conditions_dsp_line~~CalledByGraph proc~break_conditions_dsp_line break_conditions_dsp_line proc~dsp_line dsp_line proc~dsp_line->proc~break_conditions_dsp_line proc~dsp_line_from_dsp dsp_line_from_dsp proc~dsp_line_from_dsp->proc~dsp_line proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~dsp_line_from_dsp program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables alpha n p Variables Type Visibility Attributes Name Initial real(kind=pr), public :: alpha integer, public :: n real(kind=pr), public :: p","tags":"","loc":"proc/break_conditions_dsp_line.html"},{"title":"dsp_line_from_dsp – fenvelopes","text":"public function dsp_line_from_dsp(inter, pt_1, pt_2, del_S0, alpha0) result(envels) Uses linalg legacy_ar_models stdlib_optval proc~~dsp_line_from_dsp~~UsesGraph proc~dsp_line_from_dsp dsp_line_from_dsp module~linalg linalg proc~dsp_line_from_dsp->module~linalg stdlib_optval stdlib_optval proc~dsp_line_from_dsp->stdlib_optval legacy_ar_models legacy_ar_models proc~dsp_line_from_dsp->legacy_ar_models module~constants constants module~linalg->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( point ), intent(in) :: inter type( envelope ), intent(in) :: pt_1 type( envelope ), intent(in) :: pt_2 real(kind=pr), optional :: del_S0 real(kind=pr), optional :: alpha0 Return Value type( injelope )(2) Calls proc~~dsp_line_from_dsp~~CallsGraph proc~dsp_line_from_dsp dsp_line_from_dsp optval optval proc~dsp_line_from_dsp->optval proc~interpol interpol proc~dsp_line_from_dsp->proc~interpol proc~get_z get_z proc~dsp_line_from_dsp->proc~get_z proc~dsp_line dsp_line proc~dsp_line_from_dsp->proc~dsp_line str str proc~dsp_line->str progress_bar progress_bar proc~dsp_line->progress_bar proc~break_conditions_dsp_line break_conditions_dsp_line proc~dsp_line->proc~break_conditions_dsp_line proc~full_newton full_newton proc~dsp_line->proc~full_newton proc~fix_step fix_step proc~dsp_line->proc~fix_step proc~update_spec update_spec proc~dsp_line->proc~update_spec proc~solve_system solve_system proc~full_newton->proc~solve_system proc~update_spec->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~dsp_line_from_dsp~~CalledByGraph proc~dsp_line_from_dsp dsp_line_from_dsp proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~dsp_line_from_dsp program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables X alpha del_S dzda i j lnKx lnKy ns p t z Variables Type Visibility Attributes Name Initial real(kind=pr), public :: X (2*nc+3) real(kind=pr), public :: alpha real(kind=pr), public :: del_S real(kind=pr), public :: dzda (nc) integer, public :: i integer, public :: j real(kind=pr), public :: lnKx (nc) real(kind=pr), public :: lnKy (nc) integer, public :: ns real(kind=pr), public :: p real(kind=pr), public :: t real(kind=pr), public :: z (nc)","tags":"","loc":"proc/dsp_line_from_dsp.html"},{"title":"dsp_line – fenvelopes","text":"public subroutine dsp_line(X0, spec_number, del_S0, envels) Uses constants io proc~~dsp_line~~UsesGraph proc~dsp_line dsp_line module~constants constants proc~dsp_line->module~constants io io proc~dsp_line->io iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Subroutine to calculate Px phase envelopes via continuation method.\nThree phases version. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X0 (:) Vector of variables integer, intent(in) :: spec_number Number of specification real(kind=pr), intent(in) :: del_S0 type( injelope ), intent(out) :: envels Calculated envelopes Calls proc~~dsp_line~~CallsGraph proc~dsp_line dsp_line str str proc~dsp_line->str progress_bar progress_bar proc~dsp_line->progress_bar proc~break_conditions_dsp_line break_conditions_dsp_line proc~dsp_line->proc~break_conditions_dsp_line proc~full_newton full_newton proc~dsp_line->proc~full_newton proc~fix_step fix_step proc~dsp_line->proc~fix_step proc~update_spec update_spec proc~dsp_line->proc~update_spec proc~solve_system solve_system proc~full_newton->proc~solve_system proc~update_spec->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~dsp_line~~CalledByGraph proc~dsp_line dsp_line proc~dsp_line_from_dsp dsp_line_from_dsp proc~dsp_line_from_dsp->proc~dsp_line proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~dsp_line_from_dsp program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables F S X XS cps dF dXdS del_S fname_env funit_output i iters n ns point Variables Type Visibility Attributes Name Initial real(kind=pr), public :: F (size(X0)) real(kind=pr), public :: S real(kind=pr), public :: X (size(X0)) real(kind=pr), public :: XS (max_points,size(X0)) type( critical_point ), public, allocatable :: cps (:) real(kind=pr), public :: dF (size(X0),size(X0)) real(kind=pr), public :: dXdS (size(X0)) real(kind=pr), public :: del_S character(len=254), public :: fname_env integer, public :: funit_output integer, public :: i integer, public :: iters integer, public :: n integer, public :: ns integer, public :: point","tags":"","loc":"proc/dsp_line.html"},{"title":"dsp_line_F – fenvelopes","text":"public subroutine dsp_line_F(Xvars, ns, S, F, df) Uses iso_fortran_env legacy_ar_models proc~~dsp_line_f~~UsesGraph proc~dsp_line_f dsp_line_F iso_fortran_env iso_fortran_env proc~dsp_line_f->iso_fortran_env legacy_ar_models legacy_ar_models proc~dsp_line_f->legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Function to solve at each point of a three phase envelope. The vector of variables X corresponds to: While the equations are: Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: Xvars (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(out) :: F (size(Xvars)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(Xvars),size(Xvars)) Jacobian matrix Calls proc~~dsp_line_f~~CallsGraph proc~dsp_line_f dsp_line_F proc~get_z get_z proc~dsp_line_f->proc~get_z termo termo proc~dsp_line_f->termo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables Kx Ky P T Vx Vy Vz alpha dlnphi_dn_x dlnphi_dn_y dlnphi_dn_z dlnphi_dp_x dlnphi_dp_y dlnphi_dp_z dlnphi_dt_x dlnphi_dt_y dlnphi_dt_z dxdKx dxdKy dydKx dydKy dzdKx dzdKy dzda i j lnfug_x lnfug_y lnfug_z n x y z Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Kx ((Size(Xvars)-3)/2) real(kind=pr), public :: Ky ((Size(Xvars)-3)/2) real(kind=pr), public :: P real(kind=pr), public :: T real(kind=pr), public :: Vx real(kind=pr), public :: Vy real(kind=pr), public :: Vz real(kind=pr), public :: alpha real(kind=pr), public, dimension((Size(Xvars)-3)/2, (Size(Xvars)-3)/2) :: dlnphi_dn_x real(kind=pr), public, dimension((Size(Xvars)-3)/2, (Size(Xvars)-3)/2) :: dlnphi_dn_y real(kind=pr), public, dimension((Size(Xvars)-3)/2, (Size(Xvars)-3)/2) :: dlnphi_dn_z real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dp_x real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dp_y real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dp_z real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dt_x real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dt_y real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dt_z real(kind=pr), public :: dxdKx ((Size(Xvars)-3)/2) real(kind=pr), public :: dxdKy ((Size(Xvars)-3)/2) real(kind=pr), public :: dydKx ((Size(Xvars)-3)/2) real(kind=pr), public :: dydKy ((Size(Xvars)-3)/2) real(kind=pr), public :: dzdKx ((Size(Xvars)-3)/2) real(kind=pr), public :: dzdKy ((Size(Xvars)-3)/2) real(kind=pr), public :: dzda ((Size(Xvars)-3)/2) integer, public :: i integer, public :: j real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: lnfug_x real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: lnfug_y real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: lnfug_z integer, public :: n real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: x real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: y real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: z","tags":"","loc":"proc/dsp_line_f.html"},{"title":"fix_step – fenvelopes","text":"public subroutine fix_step(iters, X, ns, S, del_S, dXdS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iters real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(inout) :: del_S real(kind=pr), intent(inout) :: dXdS (size(X)) Called by proc~~fix_step~~CalledByGraph proc~fix_step fix_step proc~dsp_line dsp_line proc~dsp_line->proc~fix_step proc~dsp_line_from_dsp dsp_line_from_dsp proc~dsp_line_from_dsp->proc~dsp_line proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~dsp_line_from_dsp program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables Xnew dP dT da n Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Xnew (size(X)) real(kind=pr), public :: dP real(kind=pr), public :: dT real(kind=pr), public :: da integer, public :: n","tags":"","loc":"proc/fix_step.html"},{"title":"break_conditions – fenvelopes","text":"public function break_conditions(X, ns, S, del_S) Set of conditions to break the tracing of a two phase line. Arguments Type Intent Optional Attributes Name real(kind=pr) :: X (:) Vector of variables integer :: ns Number of specification real(kind=pr) :: S Specification value real(kind=pr) :: del_S Return Value logical,allocatable,(:) Called by proc~~break_conditions~~CalledByGraph proc~break_conditions break_conditions proc~injection_envelope injection_envelope proc~injection_envelope->proc~break_conditions proc~px_hpl_line px_hpl_line proc~px_hpl_line->proc~injection_envelope proc~px_two_phase_from_pt px_two_phase_from_pt proc~px_two_phase_from_pt->proc~injection_envelope proc~px_envelopes px_envelopes proc~px_envelopes->proc~px_hpl_line proc~px_envelopes->proc~px_two_phase_from_pt program~main main program~main->proc~px_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables alpha n p Variables Type Visibility Attributes Name Initial real(kind=pr), public :: alpha integer, public :: n real(kind=pr), public :: p","tags":"","loc":"proc/break_conditions.html"},{"title":"break_conditions_three_phases – fenvelopes","text":"public function break_conditions_three_phases(X, ns, S, del_S) Set of conditions to break the tracing. Arguments Type Intent Optional Attributes Name real(kind=pr) :: X (:) Variables vector integer :: ns Number of specification real(kind=pr) :: S Value of specification real(kind=pr) :: del_S Return Value logical,allocatable,(:) Called by proc~~break_conditions_three_phases~2~~CalledByGraph proc~break_conditions_three_phases~2 break_conditions_three_phases proc~injection_envelope_three_phase injection_envelope_three_phase proc~injection_envelope_three_phase->proc~break_conditions_three_phases~2 proc~px_three_phase_from_inter px_three_phase_from_inter proc~px_three_phase_from_inter->proc~injection_envelope_three_phase proc~px_three_phase_from_pt px_three_phase_from_pt proc~px_three_phase_from_pt->proc~injection_envelope_three_phase proc~px_envelopes px_envelopes proc~px_envelopes->proc~px_three_phase_from_inter proc~px_envelopes->proc~px_three_phase_from_pt program~main main program~main->proc~px_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables alpha n p Variables Type Visibility Attributes Name Initial real(kind=pr), public :: alpha integer, public :: n real(kind=pr), public :: p","tags":"","loc":"proc/break_conditions_three_phases~2.html"},{"title":"get_case – fenvelopes","text":"public function get_case(dew_envel, bub_envel) result(n_case) Arguments Type Intent Optional Attributes Name type( injelope ), intent(in) :: dew_envel type( injelope ), intent(in) :: bub_envel Return Value integer Contents None","tags":"","loc":"proc/get_case~2.html"},{"title":"px_hpl_line – fenvelopes","text":"public function px_hpl_line(alpha_0, p) Uses linalg legacy_ar_models proc~~px_hpl_line~~UsesGraph proc~px_hpl_line px_hpl_line module~linalg linalg proc~px_hpl_line->module~linalg legacy_ar_models legacy_ar_models proc~px_hpl_line->legacy_ar_models module~constants constants module~linalg->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: alpha_0 Staring to search real(kind=pr), intent(in) :: p Pressure of HPLL Return Value type( injelope ) Resulting HPLL line Calls proc~~px_hpl_line~~CallsGraph proc~px_hpl_line px_hpl_line none~foo foo proc~px_hpl_line->none~foo proc~injection_envelope injection_envelope proc~px_hpl_line->proc~injection_envelope proc~get_z get_z none~foo->proc~get_z termo termo none~foo->termo proc~injection_envelope->proc~get_z progress_bar progress_bar proc~injection_envelope->progress_bar str str proc~injection_envelope->str proc~fix_step_two_phases fix_step_two_phases proc~injection_envelope->proc~fix_step_two_phases knew knew proc~injection_envelope->knew proc~full_newton full_newton proc~injection_envelope->proc~full_newton proc~update_spec update_spec proc~injection_envelope->proc~update_spec xnew xnew proc~injection_envelope->xnew proc~break_conditions break_conditions proc~injection_envelope->proc~break_conditions proc~solve_system solve_system proc~full_newton->proc~solve_system proc~update_spec->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~px_hpl_line~~CalledByGraph proc~px_hpl_line px_hpl_line proc~px_envelopes px_envelopes proc~px_envelopes->proc~px_hpl_line program~main main program~main->proc~px_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables alpha_in del_S0 diff dlnphi_dp_y dlnphi_dp_z dlnphi_dy dlnphi_dz k lnfug_y lnfug_z ncomp ns p_in v x y z Functions foo Subroutines optim Variables Type Visibility Attributes Name Initial real(kind=pr), public :: alpha_in real(kind=pr), public :: del_S0 real(kind=pr), public :: diff real(kind=pr), public :: dlnphi_dp_y (nc) real(kind=pr), public :: dlnphi_dp_z (nc) real(kind=pr), public :: dlnphi_dy (nc,nc) real(kind=pr), public :: dlnphi_dz (nc,nc) real(kind=pr), public :: k (nc) real(kind=pr), public :: lnfug_y (nc) real(kind=pr), public :: lnfug_z (nc) integer, public :: ncomp integer, public :: ns real(kind=pr), public :: p_in real(kind=pr), public :: v real(kind=pr), public, allocatable :: x (:) real(kind=pr), public :: y (nc) real(kind=pr), public :: z (nc) Functions function foo(x) result(f) Arguments Type Intent Optional Attributes Name real(kind=pr) :: x (:) Return Value real(kind=pr) Subroutines subroutine optim() Arguments None","tags":"","loc":"proc/px_hpl_line.html"},{"title":"px_three_phase_from_inter – fenvelopes","text":"public function px_three_phase_from_inter(inter, px_1, px_2, del_S0, beta0) result(envels) Uses linalg legacy_ar_models stdlib_optval proc~~px_three_phase_from_inter~~UsesGraph proc~px_three_phase_from_inter px_three_phase_from_inter module~linalg linalg proc~px_three_phase_from_inter->module~linalg stdlib_optval stdlib_optval proc~px_three_phase_from_inter->stdlib_optval legacy_ar_models legacy_ar_models proc~px_three_phase_from_inter->legacy_ar_models module~constants constants module~linalg->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name type( point ), intent(in) :: inter type( injelope ), intent(in) :: px_1 type( injelope ), intent(in) :: px_2 real(kind=pr), optional :: del_S0 real(kind=pr), optional :: beta0 Return Value type( injelope )(2) Calls proc~~px_three_phase_from_inter~~CallsGraph proc~px_three_phase_from_inter px_three_phase_from_inter optval optval proc~px_three_phase_from_inter->optval proc~interpol interpol proc~px_three_phase_from_inter->proc~interpol proc~injection_envelope_three_phase injection_envelope_three_phase proc~px_three_phase_from_inter->proc~injection_envelope_three_phase proc~get_z get_z proc~px_three_phase_from_inter->proc~get_z proc~injection_envelope_three_phase->proc~get_z progress_bar progress_bar proc~injection_envelope_three_phase->progress_bar str str proc~injection_envelope_three_phase->str knew knew proc~injection_envelope_three_phase->knew proc~update_spec update_spec proc~injection_envelope_three_phase->proc~update_spec proc~full_newton full_newton proc~injection_envelope_three_phase->proc~full_newton dxds_in dxds_in proc~injection_envelope_three_phase->dxds_in proc~break_conditions_three_phases~2 break_conditions_three_phases proc~injection_envelope_three_phase->proc~break_conditions_three_phases~2 proc~solve_system solve_system proc~update_spec->proc~solve_system proc~full_newton->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~px_three_phase_from_inter~~CalledByGraph proc~px_three_phase_from_inter px_three_phase_from_inter proc~px_envelopes px_envelopes proc~px_envelopes->proc~px_three_phase_from_inter program~main main program~main->proc~px_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables X alpha beta del_S dzda i j lnKx lnKy ns p phase_x phase_y z Variables Type Visibility Attributes Name Initial real(kind=pr), public :: X (2*nc+3) real(kind=pr), public :: alpha real(kind=pr), public :: beta real(kind=pr), public :: del_S real(kind=pr), public :: dzda (nc) integer, public :: i integer, public :: j real(kind=pr), public :: lnKx (nc) real(kind=pr), public :: lnKy (nc) integer, public :: ns real(kind=pr), public :: p real(kind=pr), public :: phase_x (nc) real(kind=pr), public :: phase_y (nc) real(kind=pr), public :: z (nc)","tags":"","loc":"proc/px_three_phase_from_inter.html"},{"title":"px_three_phase_from_pt – fenvelopes","text":"public function px_three_phase_from_pt(t_inj, pt_env_3, t_tol, del_S0) result(envel) Uses linalg envelopes stdlib_optval proc~~px_three_phase_from_pt~~UsesGraph proc~px_three_phase_from_pt px_three_phase_from_pt module~linalg linalg proc~px_three_phase_from_pt->module~linalg stdlib_optval stdlib_optval proc~px_three_phase_from_pt->stdlib_optval module~envelopes envelopes proc~px_three_phase_from_pt->module~envelopes module~constants constants module~linalg->module~constants module~envelopes->module~linalg module~envelopes->module~constants progress_bar_module progress_bar_module module~envelopes->progress_bar_module legacy_ar_models legacy_ar_models module~envelopes->legacy_ar_models module~dtypes dtypes module~envelopes->module~dtypes iso_fortran_env iso_fortran_env module~constants->iso_fortran_env module~dtypes->module~constants io io module~dtypes->io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calculate three phase Px envelopes at a given injection temperature. Given an injection temperature t_inj and a base PT envelope pt_env_3 , finds all the points on the PT envelope near t_inj , based\non an absolute tolerance t_tol . These points are used as \ninitialization for calculation of Px envelopes. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: t_inj Injection temperature [K] type( PTEnvel3 ), intent(in) :: pt_env_3 (:) Base PT envelopes real(kind=pr), intent(in) :: t_tol Absolute temperature tolerance real(kind=pr), intent(in), optional :: del_S0 First point Return Value type( injelope ) Output Px envelope Calls proc~~px_three_phase_from_pt~~CallsGraph proc~px_three_phase_from_pt px_three_phase_from_pt optval optval proc~px_three_phase_from_pt->optval proc~interpol interpol proc~px_three_phase_from_pt->proc~interpol proc~injection_envelope_three_phase injection_envelope_three_phase proc~px_three_phase_from_pt->proc~injection_envelope_three_phase proc~get_z get_z proc~injection_envelope_three_phase->proc~get_z progress_bar progress_bar proc~injection_envelope_three_phase->progress_bar str str proc~injection_envelope_three_phase->str knew knew proc~injection_envelope_three_phase->knew proc~full_newton full_newton proc~injection_envelope_three_phase->proc~full_newton proc~update_spec update_spec proc~injection_envelope_three_phase->proc~update_spec dxds_in dxds_in proc~injection_envelope_three_phase->dxds_in proc~break_conditions_three_phases~2 break_conditions_three_phases proc~injection_envelope_three_phase->proc~break_conditions_three_phases~2 proc~solve_system solve_system proc~full_newton->proc~solve_system proc~update_spec->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~px_three_phase_from_pt~~CalledByGraph proc~px_three_phase_from_pt px_three_phase_from_pt proc~px_envelopes px_envelopes proc~px_envelopes->proc~px_three_phase_from_pt program~main main program~main->proc~px_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables X alpha beta del_S i i_envel idx kx ky ns p pold ts_envel Variables Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: X (:) Vector of variables real(kind=pr), public :: alpha Amount of injection real(kind=pr), public :: beta Main phases molar fraction real(kind=pr), public :: del_S integer, public :: i integer, public :: i_envel integer, public :: idx real(kind=pr), public, allocatable :: kx (:) K values real(kind=pr), public, allocatable :: ky (:) K values integer, public :: ns real(kind=pr), public :: p Pressure of ocurrence real(kind=pr), public :: pold Old pressure, used to assure no repeats real(kind=pr), public, allocatable :: ts_envel (:) Temperatures under tolerance","tags":"","loc":"proc/px_three_phase_from_pt.html"},{"title":"px_two_phase_from_pt – fenvelopes","text":"public function px_two_phase_from_pt(t_inj, pt_env_2, t_tol, del_S0) result(envel) Uses linalg stdlib_optval proc~~px_two_phase_from_pt~~UsesGraph proc~px_two_phase_from_pt px_two_phase_from_pt module~linalg linalg proc~px_two_phase_from_pt->module~linalg stdlib_optval stdlib_optval proc~px_two_phase_from_pt->stdlib_optval module~constants constants module~linalg->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calculate two phase Px envelopes at a given injection temperature. Given an injection temperature t_inj and a base PT envelope pt_env_2 , finds all the points on the PT envelope near t_inj , based\non an absolute tolerance t_tol . These points are used as \ninitialization for calculation of Px envelopes. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: t_inj Injection temperature [K] type( envelope ), intent(in) :: pt_env_2 Base PT envelope real(kind=pr), intent(in) :: t_tol Absolute temperature tolerance real(kind=pr), intent(in), optional :: del_S0 First point Return Value type( injelope ) Output Px envelope Calls proc~~px_two_phase_from_pt~~CallsGraph proc~px_two_phase_from_pt px_two_phase_from_pt optval optval proc~px_two_phase_from_pt->optval proc~interpol interpol proc~px_two_phase_from_pt->proc~interpol proc~injection_envelope injection_envelope proc~px_two_phase_from_pt->proc~injection_envelope proc~get_z get_z proc~injection_envelope->proc~get_z progress_bar progress_bar proc~injection_envelope->progress_bar str str proc~injection_envelope->str proc~fix_step_two_phases fix_step_two_phases proc~injection_envelope->proc~fix_step_two_phases knew knew proc~injection_envelope->knew proc~full_newton full_newton proc~injection_envelope->proc~full_newton proc~update_spec update_spec proc~injection_envelope->proc~update_spec xnew xnew proc~injection_envelope->xnew proc~break_conditions break_conditions proc~injection_envelope->proc~break_conditions proc~solve_system solve_system proc~full_newton->proc~solve_system proc~update_spec->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~px_two_phase_from_pt~~CalledByGraph proc~px_two_phase_from_pt px_two_phase_from_pt proc~px_envelopes px_envelopes proc~px_envelopes->proc~px_two_phase_from_pt program~main main program~main->proc~px_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables X alpha del_S i idx k ns p pold ts_envel Variables Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: X (:) Vector of variables real(kind=pr), public :: alpha Amount of injection real(kind=pr), public :: del_S integer, public :: i integer, public :: idx real(kind=pr), public, allocatable :: k (:) K values integer, public :: ns real(kind=pr), public :: p Pressure of ocurrence real(kind=pr), public :: pold Old pressure, used to assure no repeats real(kind=pr), public, allocatable :: ts_envel (:) Temperatures under tolerance","tags":"","loc":"proc/px_two_phase_from_pt.html"},{"title":"remove_duplicates – fenvelopes","text":"public function remove_duplicates(envels) result(clean_envels) From a set of envelopes check if they are the same line Arguments Type Intent Optional Attributes Name class( injelope ) :: envels (:) Return Value type( injelope ),allocatable,(:) Contents None","tags":"","loc":"proc/remove_duplicates.html"},{"title":"same_line – fenvelopes","text":"public function same_line(env1, env2) Arguments Type Intent Optional Attributes Name class( injelope ), intent(in) :: env1 class( injelope ), intent(in) :: env2 Return Value logical Contents None","tags":"","loc":"proc/same_line.html"},{"title":"F_injection – fenvelopes","text":"public subroutine F_injection(X, ns, S, F, df) Uses iso_fortran_env legacy_ar_models proc~~f_injection~~UsesGraph proc~f_injection F_injection iso_fortran_env iso_fortran_env proc~f_injection->iso_fortran_env legacy_ar_models legacy_ar_models proc~f_injection->legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Function to solve at each point of the phase envelope. The vector of variables X corresponds to: While the equations are: The injection can be considered as two kinds of injection:\n- Displacement: - Addition: Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(out) :: F (size(X)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(x),size(X)) Jacobian matrix Calls proc~~f_injection~~CallsGraph proc~f_injection F_injection proc~get_z get_z proc~f_injection->proc~get_z termo termo proc~f_injection->termo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables K P Vy Vz alpha dlnphi_dn_y dlnphi_dn_z dlnphi_dp_y dlnphi_dp_z dlnphi_dt_y dlnphi_dt_z dzda i j lnfug_y lnfug_z n y z Variables Type Visibility Attributes Name Initial real(kind=pr), public :: K (size(X)-2) real(kind=pr), public :: P real(kind=pr), public :: Vy real(kind=pr), public :: Vz real(kind=pr), public :: alpha real(kind=pr), public, dimension(size(X) - 2, size(X) - 2) :: dlnphi_dn_y real(kind=pr), public, dimension(size(X) - 2, size(X) - 2) :: dlnphi_dn_z real(kind=pr), public, dimension(size(X) - 2) :: dlnphi_dp_y real(kind=pr), public, dimension(size(X) - 2) :: dlnphi_dp_z real(kind=pr), public, dimension(size(X) - 2) :: dlnphi_dt_y real(kind=pr), public, dimension(size(X) - 2) :: dlnphi_dt_z real(kind=pr), public :: dzda (size(X)-2) integer, public :: i integer, public :: j real(kind=pr), public, dimension(size(X) - 2) :: lnfug_y real(kind=pr), public, dimension(size(X) - 2) :: lnfug_z integer, public :: n real(kind=pr), public, dimension(size(X) - 2) :: y real(kind=pr), public, dimension(size(X) - 2) :: z","tags":"","loc":"proc/f_injection.html"},{"title":"F_injection_three_phases – fenvelopes","text":"public subroutine F_injection_three_phases(Xvars, ns, S, F, df) Uses iso_fortran_env legacy_ar_models proc~~f_injection_three_phases~~UsesGraph proc~f_injection_three_phases F_injection_three_phases iso_fortran_env iso_fortran_env proc~f_injection_three_phases->iso_fortran_env legacy_ar_models legacy_ar_models proc~f_injection_three_phases->legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Function to solve at each point of a three phase envelope. The vector of variables X corresponds to: While the equations are: Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: Xvars (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(out) :: F (size(Xvars)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(Xvars),size(Xvars)) Jacobian matrix Calls proc~~f_injection_three_phases~~CallsGraph proc~f_injection_three_phases F_injection_three_phases proc~get_z get_z proc~f_injection_three_phases->proc~get_z termo termo proc~f_injection_three_phases->termo Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables Kx Ky P Vw Vx Vy alpha beta dlnphi_dn_w dlnphi_dn_x dlnphi_dn_y dlnphi_dp_w dlnphi_dp_x dlnphi_dp_y dlnphi_dt_w dlnphi_dt_x dlnphi_dt_y dwdKx dwdKy dwda dwdb dxdKx dxdKy dydKx dydKy dzda i j lnfug_w lnfug_x lnfug_y n w x y z Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Kx ((Size(Xvars)-3)/2) real(kind=pr), public :: Ky ((Size(Xvars)-3)/2) real(kind=pr), public :: P real(kind=pr), public :: Vw real(kind=pr), public :: Vx real(kind=pr), public :: Vy real(kind=pr), public :: alpha real(kind=pr), public :: beta real(kind=pr), public, dimension((Size(Xvars)-3)/2, (Size(Xvars)-3)/2) :: dlnphi_dn_w real(kind=pr), public, dimension((Size(Xvars)-3)/2, (Size(Xvars)-3)/2) :: dlnphi_dn_x real(kind=pr), public, dimension((Size(Xvars)-3)/2, (Size(Xvars)-3)/2) :: dlnphi_dn_y real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dp_w real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dp_x real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dp_y real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dt_w real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dt_x real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: dlnphi_dt_y real(kind=pr), public :: dwdKx ((Size(Xvars)-3)/2) real(kind=pr), public :: dwdKy ((Size(Xvars)-3)/2) real(kind=pr), public :: dwda ((Size(Xvars)-3)/2) real(kind=pr), public :: dwdb ((Size(Xvars)-3)/2) real(kind=pr), public :: dxdKx ((Size(Xvars)-3)/2) real(kind=pr), public :: dxdKy ((Size(Xvars)-3)/2) real(kind=pr), public :: dydKx ((Size(Xvars)-3)/2) real(kind=pr), public :: dydKy ((Size(Xvars)-3)/2) real(kind=pr), public :: dzda ((Size(Xvars)-3)/2) integer, public :: i integer, public :: j real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: lnfug_w real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: lnfug_x real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: lnfug_y integer, public :: n real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: w real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: x real(kind=pr), public, dimension((Size(Xvars)-3)/2) :: y real(kind=pr), public :: z ((Size(Xvars)-3)/2)","tags":"","loc":"proc/f_injection_three_phases.html"},{"title":"fix_step_two_phases – fenvelopes","text":"public subroutine fix_step_two_phases(X, ns, S, solve_its, del_S, dXdS) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S integer, intent(in) :: solve_its real(kind=pr), intent(inout) :: del_S real(kind=pr), intent(inout) :: dXdS (size(X)) Called by proc~~fix_step_two_phases~~CalledByGraph proc~fix_step_two_phases fix_step_two_phases proc~injection_envelope injection_envelope proc~injection_envelope->proc~fix_step_two_phases proc~px_hpl_line px_hpl_line proc~px_hpl_line->proc~injection_envelope proc~px_two_phase_from_pt px_two_phase_from_pt proc~px_two_phase_from_pt->proc~injection_envelope proc~px_envelopes px_envelopes proc~px_envelopes->proc~px_hpl_line proc~px_envelopes->proc~px_two_phase_from_pt program~main main program~main->proc~px_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables Xnew dP dP_tol dalpha dalpha_tol n Variables Type Visibility Attributes Name Initial real(kind=pr), public :: Xnew (size(X-1)) real(kind=pr), public :: dP real(kind=pr), public :: dP_tol real(kind=pr), public :: dalpha real(kind=pr), public :: dalpha_tol integer, public :: n","tags":"","loc":"proc/fix_step_two_phases.html"},{"title":"from_nml – fenvelopes","text":"public subroutine from_nml(filepath) Uses legacy_ar_models proc~~from_nml~~UsesGraph proc~from_nml from_nml legacy_ar_models legacy_ar_models proc~from_nml->legacy_ar_models Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filepath Called by proc~~from_nml~~CalledByGraph proc~from_nml from_nml proc~setup setup proc~setup->proc~from_nml program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables funit Variables Type Visibility Attributes Name Initial integer, public :: funit","tags":"","loc":"proc/from_nml.html"},{"title":"get_z – fenvelopes","text":"public subroutine get_z(alpha, z, dzda) Calculate the fluid composition based on an amount of addition\nof second fluid. The injection can be considered as two kinds of injection:\n- Displacement: - Addition: Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: alpha Addition percentaje real(kind=pr), intent(out) :: z (size(z_0)) New composition real(kind=pr), intent(out), optional :: dzda (size(z_0)) Derivative wrt Called by proc~~get_z~~CalledByGraph proc~get_z get_z none~foo foo none~foo->proc~get_z program~main main program~main->proc~get_z proc~px_envelopes px_envelopes program~main->proc~px_envelopes proc~pt_envelopes pt_envelopes program~main->proc~pt_envelopes proc~injection_envelope injection_envelope proc~injection_envelope->proc~get_z proc~f_injection_three_phases F_injection_three_phases proc~f_injection_three_phases->proc~get_z proc~dsp_line_from_dsp dsp_line_from_dsp proc~dsp_line_from_dsp->proc~get_z proc~px_three_phase_from_inter px_three_phase_from_inter proc~px_three_phase_from_inter->proc~get_z proc~injection_envelope_three_phase injection_envelope_three_phase proc~px_three_phase_from_inter->proc~injection_envelope_three_phase proc~dsp_line_f dsp_line_F proc~dsp_line_f->proc~get_z proc~injection_envelope_three_phase->proc~get_z proc~f_injection F_injection proc~f_injection->proc~get_z proc~px_hpl_line px_hpl_line proc~px_hpl_line->none~foo proc~px_hpl_line->proc~injection_envelope proc~px_envelopes->proc~px_three_phase_from_inter proc~px_envelopes->proc~px_hpl_line proc~px_three_phase_from_pt px_three_phase_from_pt proc~px_envelopes->proc~px_three_phase_from_pt proc~px_two_phase_from_pt px_two_phase_from_pt proc~px_envelopes->proc~px_two_phase_from_pt proc~pt_envelopes->proc~dsp_line_from_dsp proc~px_three_phase_from_pt->proc~injection_envelope_three_phase proc~px_two_phase_from_pt->proc~injection_envelope Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/get_z.html"},{"title":"injection_envelope – fenvelopes","text":"public subroutine injection_envelope(X0, spec_number, del_S0, envels) Uses constants io proc~~injection_envelope~~UsesGraph proc~injection_envelope injection_envelope module~constants constants proc~injection_envelope->module~constants io io proc~injection_envelope->io iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Subroutine to calculate Px phase envelopes via continuation method Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X0 (:) Vector of variables integer, intent(in) :: spec_number Number of specification real(kind=pr), intent(in) :: del_S0 type( injelope ), intent(out) :: envels Calculated envelopes Calls proc~~injection_envelope~~CallsGraph proc~injection_envelope injection_envelope proc~get_z get_z proc~injection_envelope->proc~get_z progress_bar progress_bar proc~injection_envelope->progress_bar str str proc~injection_envelope->str proc~fix_step_two_phases fix_step_two_phases proc~injection_envelope->proc~fix_step_two_phases knew knew proc~injection_envelope->knew proc~full_newton full_newton proc~injection_envelope->proc~full_newton proc~update_spec update_spec proc~injection_envelope->proc~update_spec xnew xnew proc~injection_envelope->xnew proc~break_conditions break_conditions proc~injection_envelope->proc~break_conditions proc~solve_system solve_system proc~full_newton->proc~solve_system proc~update_spec->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~injection_envelope~~CalledByGraph proc~injection_envelope injection_envelope proc~px_hpl_line px_hpl_line proc~px_hpl_line->proc~injection_envelope proc~px_two_phase_from_pt px_two_phase_from_pt proc~px_two_phase_from_pt->proc~injection_envelope proc~px_envelopes px_envelopes proc~px_envelopes->proc~px_hpl_line proc~px_envelopes->proc~px_two_phase_from_pt program~main main program~main->proc~px_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables F S X XS cps dF dXdS del_S fname_env funit_output i iters n ns point z Variables Type Visibility Attributes Name Initial real(kind=pr), public :: F (size(X0)) real(kind=pr), public :: S real(kind=pr), public :: X (size(X0)) real(kind=pr), public :: XS (max_points,size(X0)) type( critical_point ), public, allocatable :: cps (:) real(kind=pr), public :: dF (size(X0),size(X0)) real(kind=pr), public :: dXdS (size(X0)) real(kind=pr), public :: del_S character(len=254), public :: fname_env integer, public :: funit_output integer, public :: i integer, public :: iters integer, public :: n integer, public :: ns integer, public :: point real(kind=pr), public :: z (size(X0)-2)","tags":"","loc":"proc/injection_envelope.html"},{"title":"injection_envelope_three_phase – fenvelopes","text":"public subroutine injection_envelope_three_phase(X0, spec_number, del_S0, envels) Uses constants io proc~~injection_envelope_three_phase~~UsesGraph proc~injection_envelope_three_phase injection_envelope_three_phase module~constants constants proc~injection_envelope_three_phase->module~constants io io proc~injection_envelope_three_phase->io iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Subroutine to calculate Px phase envelopes via continuation method.\nThree phases version. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X0 (:) Vector of variables integer, intent(in) :: spec_number Number of specification real(kind=pr), intent(in) :: del_S0 type( injelope ), intent(out) :: envels Calculated envelopes Calls proc~~injection_envelope_three_phase~~CallsGraph proc~injection_envelope_three_phase injection_envelope_three_phase proc~get_z get_z proc~injection_envelope_three_phase->proc~get_z progress_bar progress_bar proc~injection_envelope_three_phase->progress_bar str str proc~injection_envelope_three_phase->str knew knew proc~injection_envelope_three_phase->knew proc~full_newton full_newton proc~injection_envelope_three_phase->proc~full_newton proc~update_spec update_spec proc~injection_envelope_three_phase->proc~update_spec dxds_in dxds_in proc~injection_envelope_three_phase->dxds_in proc~break_conditions_three_phases~2 break_conditions_three_phases proc~injection_envelope_three_phase->proc~break_conditions_three_phases~2 proc~solve_system solve_system proc~full_newton->proc~solve_system proc~update_spec->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~injection_envelope_three_phase~~CalledByGraph proc~injection_envelope_three_phase injection_envelope_three_phase proc~px_three_phase_from_inter px_three_phase_from_inter proc~px_three_phase_from_inter->proc~injection_envelope_three_phase proc~px_three_phase_from_pt px_three_phase_from_pt proc~px_three_phase_from_pt->proc~injection_envelope_three_phase proc~px_envelopes px_envelopes proc~px_envelopes->proc~px_three_phase_from_inter proc~px_envelopes->proc~px_three_phase_from_pt program~main main program~main->proc~px_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables F S X XS alpha beta cps dF dXdS del_S fname_env funit_output i iters lnKx lnKy lnP n ns point z Variables Type Visibility Attributes Name Initial real(kind=pr), public :: F (size(X0)) real(kind=pr), public :: S real(kind=pr), public, target :: X (size(X0)) real(kind=pr), public :: XS (max_points,size(X0)) real(kind=pr), public, pointer :: alpha real(kind=pr), public, pointer :: beta type( critical_point ), public, allocatable :: cps (:) real(kind=pr), public :: dF (size(X0),size(X0)) real(kind=pr), public :: dXdS (size(X0)) real(kind=pr), public :: del_S character(len=254), public :: fname_env integer, public :: funit_output integer, public :: i integer, public :: iters real(kind=pr), public, pointer :: lnKx (:) real(kind=pr), public, pointer :: lnKy (:) real(kind=pr), public, pointer :: lnP integer, public :: n integer, public :: ns integer, public :: point real(kind=pr), public :: z (size(z_0))","tags":"","loc":"proc/injection_envelope_three_phase.html"},{"title":"update_spec – fenvelopes","text":"public subroutine update_spec(X, ns, del_S, dF, dXdS) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(inout) :: ns real(kind=pr), intent(inout) :: del_S real(kind=pr), intent(in) :: dF (size(X),size(X)) real(kind=pr), intent(inout) :: dXdS (size(X)) Calls proc~~update_spec~~CallsGraph proc~update_spec update_spec proc~solve_system solve_system proc~update_spec->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~update_spec~~CalledByGraph proc~update_spec update_spec proc~dsp_line dsp_line proc~dsp_line->proc~update_spec proc~injection_envelope_three_phase injection_envelope_three_phase proc~injection_envelope_three_phase->proc~update_spec proc~injection_envelope injection_envelope proc~injection_envelope->proc~update_spec proc~px_three_phase_from_pt px_three_phase_from_pt proc~px_three_phase_from_pt->proc~injection_envelope_three_phase proc~px_hpl_line px_hpl_line proc~px_hpl_line->proc~injection_envelope proc~dsp_line_from_dsp dsp_line_from_dsp proc~dsp_line_from_dsp->proc~dsp_line proc~px_three_phase_from_inter px_three_phase_from_inter proc~px_three_phase_from_inter->proc~injection_envelope_three_phase proc~px_two_phase_from_pt px_two_phase_from_pt proc~px_two_phase_from_pt->proc~injection_envelope proc~px_envelopes px_envelopes proc~px_envelopes->proc~px_three_phase_from_pt proc~px_envelopes->proc~px_hpl_line proc~px_envelopes->proc~px_three_phase_from_inter proc~px_envelopes->proc~px_two_phase_from_pt proc~pt_envelopes pt_envelopes proc~pt_envelopes->proc~dsp_line_from_dsp program~main main program~main->proc~px_envelopes program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables dFdS n ns_new Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dFdS (size(X)) integer, public :: n integer, public :: ns_new","tags":"","loc":"proc/update_spec.html"},{"title":"pt_envelopes – fenvelopes","text":"subroutine pt_envelopes() Uses linalg dsp_lines legacy_ar_models envelopes proc~~pt_envelopes~~UsesGraph proc~pt_envelopes pt_envelopes module~linalg linalg proc~pt_envelopes->module~linalg module~dsp_lines dsp_lines proc~pt_envelopes->module~dsp_lines legacy_ar_models legacy_ar_models proc~pt_envelopes->legacy_ar_models module~envelopes envelopes proc~pt_envelopes->module~envelopes module~constants constants module~linalg->module~constants module~dsp_lines->module~linalg module~dsp_lines->module~constants progress_bar_module progress_bar_module module~dsp_lines->progress_bar_module module~inj_envelopes inj_envelopes module~dsp_lines->module~inj_envelopes module~dtypes dtypes module~dsp_lines->module~dtypes module~envelopes->module~linalg module~envelopes->legacy_ar_models module~envelopes->module~constants module~envelopes->progress_bar_module module~envelopes->module~dtypes iso_fortran_env iso_fortran_env module~constants->iso_fortran_env module~inj_envelopes->module~linalg module~inj_envelopes->module~constants module~inj_envelopes->progress_bar_module module~inj_envelopes->module~dtypes module~dtypes->module~constants io io module~dtypes->io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calculation of PT envelopes of the main system. Arguments None Calls proc~~pt_envelopes~~CallsGraph proc~pt_envelopes pt_envelopes proc~k_wilson k_wilson proc~pt_envelopes->proc~k_wilson proc~p_wilson p_wilson proc~pt_envelopes->proc~p_wilson proc~pt_three_phase_from_intersection pt_three_phase_from_intersection proc~pt_envelopes->proc~pt_three_phase_from_intersection proc~find_hpl find_hpl proc~pt_envelopes->proc~find_hpl proc~k_wilson_bubble k_wilson_bubble proc~pt_envelopes->proc~k_wilson_bubble proc~envelope2 envelope2 proc~pt_envelopes->proc~envelope2 proc~get_case get_case proc~pt_envelopes->proc~get_case dsps dsps proc~pt_envelopes->dsps proc~dsp_line_from_dsp dsp_line_from_dsp proc~pt_envelopes->proc~dsp_line_from_dsp proc~pt_envelope_three_phase pt_envelope_three_phase proc~pt_three_phase_from_intersection->proc~pt_envelope_three_phase proc~interpol interpol proc~pt_three_phase_from_intersection->proc~interpol termo termo proc~find_hpl->termo z z proc~find_hpl->z proc~k_wilson_bubble->proc~k_wilson str str proc~envelope2->str proc~fix_delx fix_delx proc~envelope2->proc~fix_delx proc~solve_system solve_system proc~envelope2->proc~solve_system proc~update_specification update_specification proc~envelope2->proc~update_specification m m proc~envelope2->m delta_x delta_x proc~envelope2->delta_x proc~f2 F2 proc~envelope2->proc~f2 xin xin proc~envelope2->xin interface~intersection intersection proc~get_case->interface~intersection optval optval proc~dsp_line_from_dsp->optval proc~get_z get_z proc~dsp_line_from_dsp->proc~get_z proc~dsp_line_from_dsp->proc~interpol proc~dsp_line dsp_line proc~dsp_line_from_dsp->proc~dsp_line proc~pt_envelope_three_phase->str proc~pt_envelope_three_phase->proc~solve_system progress_bar progress_bar proc~pt_envelope_three_phase->progress_bar k k proc~pt_envelope_three_phase->k knew knew proc~pt_envelope_three_phase->knew xnew xnew proc~pt_envelope_three_phase->xnew proc~full_newton full_newton proc~pt_envelope_three_phase->proc~full_newton dxds_in dxds_in proc~pt_envelope_three_phase->dxds_in proc~break_conditions_three_phases break_conditions_three_phases proc~pt_envelope_three_phase->proc~break_conditions_three_phases none~dgesv dgesv proc~solve_system->none~dgesv proc~update_specification->proc~solve_system proc~dfds dFdS proc~update_specification->proc~dfds proc~intersect_two_lines intersect_two_lines interface~intersection->proc~intersect_two_lines proc~intersect_one_line intersect_one_line interface~intersection->proc~intersect_one_line proc~f2->termo proc~dsp_line->str proc~dsp_line->progress_bar proc~break_conditions_dsp_line break_conditions_dsp_line proc~dsp_line->proc~break_conditions_dsp_line proc~dsp_line->proc~full_newton proc~fix_step fix_step proc~dsp_line->proc~fix_step proc~update_spec update_spec proc~dsp_line->proc~update_spec proc~intersects intersects proc~intersect_two_lines->proc~intersects proc~full_newton->proc~solve_system proc~intersect_one_line->proc~intersects proc~update_spec->proc~solve_system proc~intersects->proc~solve_system Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~pt_envelopes~~CalledByGraph proc~pt_envelopes pt_envelopes program~main main program~main->proc~pt_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables dcri dv i icri intersections k n n_points ncri p pcri pt_case pv self_intersections t tcri tv Variables Type Visibility Attributes Name Initial real(kind=pr), public :: dcri (4) real(kind=pr), public, allocatable :: dv (:) integer, public :: i integer, public :: icri (4) type( point ), public, allocatable :: intersections (:) real(kind=pr), public, allocatable :: k (:) integer, public :: n integer, public :: n_points integer, public :: ncri real(kind=pr), public :: p real(kind=pr), public :: pcri (4) character(len=:), public, allocatable :: pt_case real(kind=pr), public, allocatable :: pv (:) type( point ), public, allocatable :: self_intersections (:) real(kind=pr), public :: t real(kind=pr), public :: tcri (4) real(kind=pr), public, allocatable :: tv (:)","tags":"","loc":"proc/pt_envelopes.html"},{"title":"px_envelopes – fenvelopes","text":"subroutine px_envelopes() Uses linalg inj_envelopes envelopes proc~~px_envelopes~~UsesGraph proc~px_envelopes px_envelopes module~linalg linalg proc~px_envelopes->module~linalg module~inj_envelopes inj_envelopes proc~px_envelopes->module~inj_envelopes module~envelopes envelopes proc~px_envelopes->module~envelopes module~constants constants module~linalg->module~constants module~inj_envelopes->module~linalg module~inj_envelopes->module~constants progress_bar_module progress_bar_module module~inj_envelopes->progress_bar_module module~dtypes dtypes module~inj_envelopes->module~dtypes module~envelopes->module~linalg module~envelopes->module~constants module~envelopes->progress_bar_module legacy_ar_models legacy_ar_models module~envelopes->legacy_ar_models module~envelopes->module~dtypes iso_fortran_env iso_fortran_env module~constants->iso_fortran_env module~dtypes->module~constants io io module~dtypes->io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calculation of Px envelopes at selected temperature. Arguments None Calls proc~~px_envelopes~~CallsGraph proc~px_envelopes px_envelopes interface~intersection intersection proc~px_envelopes->interface~intersection px_branch_3 px_branch_3 proc~px_envelopes->px_branch_3 proc~px_three_phase_from_pt px_three_phase_from_pt proc~px_envelopes->proc~px_three_phase_from_pt proc~px_hpl_line px_hpl_line proc~px_envelopes->proc~px_hpl_line proc~px_two_phase_from_pt px_two_phase_from_pt proc~px_envelopes->proc~px_two_phase_from_pt proc~px_three_phase_from_inter px_three_phase_from_inter proc~px_envelopes->proc~px_three_phase_from_inter proc~intersect_two_lines intersect_two_lines interface~intersection->proc~intersect_two_lines proc~intersect_one_line intersect_one_line interface~intersection->proc~intersect_one_line optval optval proc~px_three_phase_from_pt->optval proc~interpol interpol proc~px_three_phase_from_pt->proc~interpol proc~injection_envelope_three_phase injection_envelope_three_phase proc~px_three_phase_from_pt->proc~injection_envelope_three_phase none~foo foo proc~px_hpl_line->none~foo proc~injection_envelope injection_envelope proc~px_hpl_line->proc~injection_envelope proc~px_two_phase_from_pt->optval proc~px_two_phase_from_pt->proc~injection_envelope proc~px_two_phase_from_pt->proc~interpol proc~px_three_phase_from_inter->optval proc~get_z get_z proc~px_three_phase_from_inter->proc~get_z proc~px_three_phase_from_inter->proc~interpol proc~px_three_phase_from_inter->proc~injection_envelope_three_phase proc~intersects intersects proc~intersect_two_lines->proc~intersects none~foo->proc~get_z termo termo none~foo->termo proc~injection_envelope->proc~get_z progress_bar progress_bar proc~injection_envelope->progress_bar str str proc~injection_envelope->str proc~fix_step_two_phases fix_step_two_phases proc~injection_envelope->proc~fix_step_two_phases knew knew proc~injection_envelope->knew proc~full_newton full_newton proc~injection_envelope->proc~full_newton proc~update_spec update_spec proc~injection_envelope->proc~update_spec xnew xnew proc~injection_envelope->xnew proc~break_conditions break_conditions proc~injection_envelope->proc~break_conditions proc~intersect_one_line->proc~intersects proc~injection_envelope_three_phase->proc~get_z proc~injection_envelope_three_phase->progress_bar proc~injection_envelope_three_phase->str proc~injection_envelope_three_phase->knew proc~injection_envelope_three_phase->proc~full_newton proc~injection_envelope_three_phase->proc~update_spec dxds_in dxds_in proc~injection_envelope_three_phase->dxds_in proc~break_conditions_three_phases~2 break_conditions_three_phases proc~injection_envelope_three_phase->proc~break_conditions_three_phases~2 proc~solve_system solve_system proc~intersects->proc~solve_system proc~full_newton->proc~solve_system proc~update_spec->proc~solve_system none~dgesv dgesv proc~solve_system->none~dgesv Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~px_envelopes~~CalledByGraph proc~px_envelopes px_envelopes program~main main program~main->proc~px_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables del_S0 dzda i inter ns p self_inter t_tol Variables Type Visibility Attributes Name Initial real(kind=pr), public :: del_S0 real(kind=pr), public :: dzda (nc) integer, public :: i type( point ), public, allocatable :: inter (:) integer, public :: ns real(kind=pr), public :: p type( point ), public, allocatable :: self_inter (:) real(kind=pr), public :: t_tol = 2","tags":"","loc":"proc/px_envelopes.html"},{"title":"setup – fenvelopes","text":"subroutine setup() Uses inj_envelopes io_nml proc~~setup~~UsesGraph proc~setup setup module~inj_envelopes inj_envelopes proc~setup->module~inj_envelopes module~io_nml io_nml proc~setup->module~io_nml progress_bar_module progress_bar_module module~inj_envelopes->progress_bar_module module~linalg linalg module~inj_envelopes->module~linalg module~constants constants module~inj_envelopes->module~constants module~dtypes dtypes module~inj_envelopes->module~dtypes legacy_ar_models legacy_ar_models module~io_nml->legacy_ar_models io io module~io_nml->io module~io_nml->module~constants module~linalg->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env module~dtypes->io module~dtypes->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Setup system Make output folder (if necessary) and/or clean everyhing in an\nexisting one. Then read input files to setup needed parameters. Arguments None Calls proc~~setup~~CallsGraph proc~setup setup proc~setup_cli setup_cli proc~setup->proc~setup_cli proc~read_system read_system proc~setup->proc~read_system proc~from_nml from_nml proc~setup->proc~from_nml proc~write_system write_system proc~setup->proc~write_system proc~setup_input setup_input proc~read_system->proc~setup_input proc~read_components read_components proc~read_system->proc~read_components proc~read_model read_model proc~read_system->proc~read_model lij lij proc~write_system->lij str str proc~write_system->str kij kij proc~write_system->kij proc~read_components->lij proc~read_srk read_srk proc~read_components->proc~read_srk proc~read_pr76 read_pr76 proc~read_components->proc~read_pr76 proc~read_pr78 read_pr78 proc~read_components->proc~read_pr78 proc~read_kij_lij read_kij_lij proc~read_components->proc~read_kij_lij bij bij proc~read_components->bij b b proc~read_components->b setup setup proc~read_model->setup z z proc~read_model->z srk_factory srk_factory proc~read_srk->srk_factory pr76_factory pr76_factory proc~read_pr76->pr76_factory pr78_factory pr78_factory proc~read_pr78->pr78_factory proc~read_kij_lij->lij proc~read_kij_lij->kij Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~setup~~CalledByGraph proc~setup setup program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables funit_system infile Variables Type Visibility Attributes Name Initial integer, public :: funit_system character(len=500), public :: infile","tags":"","loc":"proc/setup.html"},{"title":"setup_cli – fenvelopes","text":"subroutine setup_cli() Setup CLI subroutine Setup the Command-Line-Interface processor Arguments None Called by proc~~setup_cli~~CalledByGraph proc~setup_cli setup_cli proc~setup setup proc~setup->proc~setup_cli program~main main program~main->proc~setup Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/setup_cli.html"},{"title":"phase_equilibria – fenvelopes","text":"Uses constants legacy_ar_models module~~phase_equilibria~~UsesGraph module~phase_equilibria phase_equilibria module~constants constants module~phase_equilibria->module~constants legacy_ar_models legacy_ar_models module~phase_equilibria->legacy_ar_models iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines betalimits betato01 flash flash_pt Subroutines public subroutine betalimits (n, z, KFACT, bmin, bmax) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=8), intent(in), dimension(n) :: z real(kind=8), intent(in), dimension(n) :: KFACT real(kind=8), intent(out) :: bmin real(kind=8), intent(out) :: bmax public subroutine betato01 (n, z, KFACT) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=8), intent(in), dimension(n) :: z real(kind=8), dimension(n) :: KFACT public subroutine flash (spec, FIRST, z, t, p, v, x, y, rho_x, rho_y, beta, iter) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: spec Flash specification [PT | VT] logical, intent(inout) :: FIRST real(kind=8), intent(in) :: z (:) real(kind=8), intent(in) :: t real(kind=8) :: p real(kind=8) :: v real(kind=8), intent(out), dimension(size(z)) :: x real(kind=8), intent(out), dimension(size(z)) :: y real(kind=8), intent(out) :: rho_x real(kind=8), intent(out) :: rho_y real(kind=8), intent(out) :: beta integer, intent(out) :: iter public subroutine flash_pt (z, p, t, x, y, beta, its) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) Feed phase molar fractions real(kind=pr), intent(in) :: p Pressure [bar] real(kind=pr), intent(in) :: t Temperature [K] real(kind=pr), intent(out) :: x (size(z)) Phase X molar fractions real(kind=pr), intent(out) :: y (size(z)) Phase Y molar fractions real(kind=pr), intent(out) :: beta Molar Y fraction real(kind=pr), intent(out), optional :: its Number of iterations","tags":"","loc":"module/phase_equilibria.html"},{"title":"linalg – fenvelopes","text":"Wrapper module around LAPACK’s dgesv and lines intersections detector Uses constants module~~linalg~~UsesGraph module~linalg linalg module~constants constants module~linalg->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~linalg~~UsedByGraph module~linalg linalg proc~px_hpl_line px_hpl_line proc~px_hpl_line->module~linalg proc~pt_envelopes pt_envelopes proc~pt_envelopes->module~linalg module~envelopes envelopes proc~pt_envelopes->module~envelopes module~dsp_lines dsp_lines proc~pt_envelopes->module~dsp_lines proc~px_three_phase_from_pt px_three_phase_from_pt proc~px_three_phase_from_pt->module~linalg proc~px_three_phase_from_pt->module~envelopes proc~pt_three_phase_from_intersection pt_three_phase_from_intersection proc~pt_three_phase_from_intersection->module~linalg module~envelopes->module~linalg module~inj_envelopes inj_envelopes module~inj_envelopes->module~linalg module~dsp_lines->module~linalg module~dsp_lines->module~inj_envelopes proc~px_envelopes px_envelopes proc~px_envelopes->module~linalg proc~px_envelopes->module~envelopes proc~px_envelopes->module~inj_envelopes proc~envelope2 envelope2 proc~envelope2->module~linalg proc~dsp_line_from_dsp dsp_line_from_dsp proc~dsp_line_from_dsp->module~linalg proc~get_case get_case proc~get_case->module~linalg proc~px_three_phase_from_inter px_three_phase_from_inter proc~px_three_phase_from_inter->module~linalg proc~px_two_phase_from_pt px_two_phase_from_pt proc~px_two_phase_from_pt->module~linalg program~main main program~main->module~envelopes program~main->module~inj_envelopes proc~setup setup proc~setup->module~inj_envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Interfaces intersection Derived Types point Functions interpol intersect_one_line intersect_two_lines solve_system Subroutines full_newton intersects Interfaces public interface intersection public function intersect_two_lines (l1_x, l1_y, l2_x, l2_y) result(intersections) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: l1_x (:) real(kind=pr), intent(in) :: l1_y (:) real(kind=pr), intent(in) :: l2_x (:) real(kind=pr), intent(in) :: l2_y (:) Return Value type( point ),allocatable, (:) public function intersect_one_line (lx, ly) result(intersections) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lx (:) real(kind=pr), intent(in) :: ly (:) Return Value type( point ),allocatable, (:) Derived Types type, public :: point Components Type Visibility Attributes Name Initial integer, public :: i integer, public :: j real(kind=pr), public :: x real(kind=pr), public :: y Functions public elemental function interpol (x1, x2, y1, y2, x_obj) result(y) Linear interpolation. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x1 First point x value real(kind=pr), intent(in) :: x2 Second point x value real(kind=pr), intent(in) :: y1 First point y value real(kind=pr), intent(in) :: y2 Second point y value real(kind=pr), intent(in) :: x_obj Desired x value to interpolate Return Value real(kind=pr) y value at x_obj public function intersect_one_line (lx, ly) result(intersections) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: lx (:) real(kind=pr), intent(in) :: ly (:) Return Value type( point ),allocatable, (:) public function intersect_two_lines (l1_x, l1_y, l2_x, l2_y) result(intersections) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: l1_x (:) real(kind=pr), intent(in) :: l1_y (:) real(kind=pr), intent(in) :: l2_x (:) real(kind=pr), intent(in) :: l2_y (:) Return Value type( point ),allocatable, (:) public function solve_system (a, b) result(x) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: a (size(b),size(b)) real(kind=pr), intent(in) :: b (:) Return Value real(kind=pr)(size(b)) Subroutines public subroutine full_newton (fun, iters, X, ns, S, max_iters, F, df) Subroutine to solve a point in the envelope. Read more… Arguments Type Intent Optional Attributes Name public subroutine fun(X, ns, S, F, dF) Function to solve Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(out) :: F (size(X)) real(kind=pr), intent(out) :: dF (size(X),size(X)) integer, intent(out) :: iters Number of iterations needed real(kind=pr), intent(inout) :: X (:) Variables vector integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value integer, intent(in) :: max_iters Maximum iterations real(kind=pr), intent(out) :: F (size(X)) Function values at solved point real(kind=pr), intent(out) :: df (size(X),size(X)) Jacobian values public subroutine intersects (x1, x2, x3, x4, y1, y2, y3, y4, s, t) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: x1 real(kind=pr), intent(in) :: x2 real(kind=pr), intent(in) :: x3 real(kind=pr), intent(in) :: x4 real(kind=pr), intent(in) :: y1 real(kind=pr), intent(in) :: y2 real(kind=pr), intent(in) :: y3 real(kind=pr), intent(in) :: y4 real(kind=pr), intent(out) :: s real(kind=pr), intent(out) :: t","tags":"","loc":"module/linalg.html"},{"title":"dtypes – fenvelopes","text":"Uses constants io module~~dtypes~~UsesGraph module~dtypes dtypes module~constants constants module~dtypes->module~constants io io module~dtypes->io iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~dtypes~~UsedByGraph module~dtypes dtypes module~dsp_lines dsp_lines module~dsp_lines->module~dtypes module~inj_envelopes inj_envelopes module~dsp_lines->module~inj_envelopes program~main main program~main->module~dtypes program~main->module~inj_envelopes module~envelopes envelopes program~main->module~envelopes module~inj_envelopes->module~dtypes module~envelopes->module~dtypes proc~envelope2 envelope2 proc~envelope2->module~dtypes proc~pt_envelopes pt_envelopes proc~pt_envelopes->module~dsp_lines proc~pt_envelopes->module~envelopes proc~px_envelopes px_envelopes proc~px_envelopes->module~inj_envelopes proc~px_envelopes->module~envelopes proc~setup setup proc~setup->module~inj_envelopes proc~px_three_phase_from_pt px_three_phase_from_pt proc~px_three_phase_from_pt->module~envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types AbsEnvel critical_point env3 envelope Subroutines print_header write_critical_points write_envel_2 write_envel_3 Derived Types type, public, abstract :: AbsEnvel type, public :: critical_point Components Type Visibility Attributes Name Initial real(kind=pr), private :: alpha real(kind=pr), private :: p real(kind=pr), private :: t type, public, extends( envelope ) :: env3 Components Type Visibility Attributes Name Initial real(kind=pr), private, allocatable :: beta (:) Other phase fraction type( critical_point ), private, allocatable :: ll_critical_points (:) real(kind=pr), private, allocatable :: logks (:,:) ln(Ks) real(kind=pr), private, allocatable :: w (:,:) real(kind=pr), private, allocatable :: x (:,:) real(kind=pr), private, allocatable :: y (:,:) Type-Bound Procedures procedure, public :: write => write_envel_3 type, public :: envelope Components Type Visibility Attributes Name Initial type( critical_point ), private, allocatable :: critical_points (:) Critical points real(kind=pr), private, allocatable :: logk (:,:) ln(K) for each point real(kind=pr), private, allocatable :: logphi (:,:) lnphi for each point real(kind=pr), private, allocatable :: p (:) Pressure points real(kind=pr), private, allocatable :: t (:) Temperature points real(kind=pr), private, allocatable :: vars (:,:) Value of the set of variables at each point real(kind=pr), private, allocatable :: z (:) Global composition Type-Bound Procedures procedure, public :: write => write_envel_2 Subroutines public subroutine print_header (name) Arguments Type Intent Optional Attributes Name character(len=250), intent(in) :: name private subroutine write_critical_points (self, file_name) Arguments Type Intent Optional Attributes Name type( critical_point ), intent(in) :: self (:) character(len=*), intent(in), optional :: file_name Ouptut file name private subroutine write_envel_2 (self, file_name) Arguments Type Intent Optional Attributes Name class( envelope ), intent(in) :: self character(len=*), intent(in), optional :: file_name Ouptut file name private subroutine write_envel_3 (self, file_name) Arguments Type Intent Optional Attributes Name class( env3 ), intent(in) :: self character(len=*), intent(in), optional :: file_name","tags":"","loc":"module/dtypes.html"},{"title":"nelder_mead – fenvelopes","text":"Used by module~~nelder_mead~~UsedByGraph module~nelder_mead nelder_mead module~optimization optimization module~optimization->module~nelder_mead Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines nelmin Subroutines public subroutine nelmin (fn, n, start, xmin, ynewlo, reqmin, step, konvge, kcount, icount, numres, ifault) * * * * * * * * * * * *80 Read more… Arguments Type Intent Optional Attributes Name public function fn(x) Arguments Type Intent Optional Attributes Name real(kind=rk) :: x (:) Return Value real(kind=rk) integer :: n real(kind=rk) :: start (n) real(kind=rk) :: xmin (n) real(kind=rk) :: ynewlo real(kind=rk) :: reqmin real(kind=rk) :: step (n) integer :: konvge integer :: kcount integer :: icount integer :: numres integer :: ifault","tags":"","loc":"module/nelder_mead.html"},{"title":"optimization – fenvelopes","text":"Uses nelder_mead module~~optimization~~UsesGraph module~optimization optimization module~nelder_mead nelder_mead module~optimization->module~nelder_mead Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables funit_settings icount ifault iostat kcount konvge numres Subroutines nm_opt Variables Type Visibility Attributes Name Initial integer, public :: funit_settings integer, public :: icount integer, public :: ifault integer, public :: iostat integer, public :: kcount = 1e5 integer, public :: konvge = 100 integer, public :: numres Subroutines public subroutine nm_opt (f, xguess, stat, step) Arguments Type Intent Optional Attributes Name public function f(x) Arguments Type Intent Optional Attributes Name real(kind=8) :: x (:) Return Value real(kind=8) real(kind=8), intent(inout) :: xguess (:) integer :: stat real(kind=8) :: step (size(xguess))","tags":"","loc":"module/optimization.html"},{"title":"envelopes – fenvelopes","text":"Functions to be used in the different continuation methods to trace\nphase envelopes Uses progress_bar_module dtypes constants linalg legacy_ar_models module~~envelopes~~UsesGraph module~envelopes envelopes progress_bar_module progress_bar_module module~envelopes->progress_bar_module legacy_ar_models legacy_ar_models module~envelopes->legacy_ar_models module~dtypes dtypes module~envelopes->module~dtypes module~constants constants module~envelopes->module~constants module~linalg linalg module~envelopes->module~linalg module~dtypes->module~constants io io module~dtypes->io iso_fortran_env iso_fortran_env module~constants->iso_fortran_env module~linalg->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~envelopes~~UsedByGraph module~envelopes envelopes proc~px_three_phase_from_pt px_three_phase_from_pt proc~px_three_phase_from_pt->module~envelopes proc~px_envelopes px_envelopes proc~px_envelopes->module~envelopes program~main main program~main->module~envelopes proc~pt_envelopes pt_envelopes proc~pt_envelopes->module~envelopes Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables env_number max_iters max_points Interfaces F Derived Types PTEnvel3 Functions X2 break_conditions_three_phases k_wilson p_wilson Subroutines F2 dFdS envelope2 find_hpl fix_delx get_case k_wilson_bubble pt_F_three_phases pt_envelope_three_phase pt_three_phase_from_intersection update_specification Variables Type Visibility Attributes Name Initial integer, public :: env_number = 0 integer, public, parameter :: max_iters = 100 integer, public, parameter :: max_points = 2000 Interfaces interface public function F(X, ns, S) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S Return Value real(kind=pr) Derived Types type, public, extends( AbsEnvel ) :: PTEnvel3 Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: P (:) real(kind=pr), public, allocatable :: T (:) real(kind=pr), public, allocatable :: beta (:) type( critical_point ), public, allocatable :: critical_points (:) real(kind=pr), public, allocatable :: lnKx (:,:) real(kind=pr), public, allocatable :: lnKy (:,:) integer, public :: n Functions public function X2 (kfact, P, T) result(X) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: kfact (nc) real(kind=pr), intent(in) :: P real(kind=pr), intent(in) :: T Return Value real(kind=pr)(nc+2) public function break_conditions_three_phases (X, ns, S) Set of conditions to break the tracing. Arguments Type Intent Optional Attributes Name real(kind=pr) :: X (:) Variables vector integer :: ns Number of specification real(kind=pr) :: S Value of specification Return Value logical,allocatable, (:) public function k_wilson (t, p) result(k) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: t real(kind=pr), intent(in) :: p Return Value real(kind=pr)(size(pc)) public function p_wilson (z, t) result(p) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: t Return Value real(kind=pr) Subroutines public subroutine F2 (incipient, z, y, X, S, ns, F, dF) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: incipient real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: y (nc) real(kind=pr), intent(in) :: X (nc+2) real(kind=pr), intent(in) :: S integer, intent(in) :: ns real(kind=pr), intent(out) :: F (nc+2) real(kind=pr), intent(out) :: dF (nc+2,nc+2) public subroutine dFdS (dF_dS) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(out) :: dF_dS (nc+2) public subroutine envelope2 (ichoice, n, z, T, P, KFACT, n_points, Tv, Pv, Dv, ncri, icri, Tcri, Pcri, Dcri, this_envelope) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ichoice integer, intent(in) :: n real(kind=pr), intent(in) :: z (n) real(kind=pr) :: T real(kind=pr) :: P real(kind=pr), intent(inout) :: KFACT (n) integer, intent(out) :: n_points real(kind=pr), intent(out) :: Tv (max_points) real(kind=pr), intent(out) :: Pv (max_points) real(kind=pr), intent(out) :: Dv (max_points) integer, intent(out) :: ncri integer, intent(out), dimension(4) :: icri real(kind=pr), intent(out), dimension(4) :: Tcri (4) real(kind=pr), intent(out), dimension(4) :: Pcri (4) real(kind=pr), intent(out), dimension(4) :: Dcri (4) type( envelope ), intent(out) :: this_envelope public subroutine find_hpl (t, p, k) Find a HPLL initial point at a given pressure Arguments Type Intent Optional Attributes Name real(kind=pr), intent(inout) :: t real(kind=pr), intent(in) :: p real(kind=pr), intent(out) :: k (nc) public subroutine fix_delx (point, iterations, desired_iterations, first_tol, tol, delX) Arguments Type Intent Optional Attributes Name integer, intent(in) :: point integer, intent(in) :: iterations integer, intent(in) :: desired_iterations real(kind=pr), intent(in) :: first_tol real(kind=pr), intent(in) :: tol real(kind=pr), intent(inout) :: delX (:) public subroutine get_case (dew, bub, hpl, intersections, self_intersections, this_case) Arguments Type Intent Optional Attributes Name type( envelope ), intent(in) :: dew type( envelope ), intent(in) :: bub type( envelope ), intent(in) :: hpl type( point ), intent(out), allocatable :: intersections (:) type( point ), intent(out), allocatable :: self_intersections (:) character(len=:), intent(out), allocatable :: this_case public subroutine k_wilson_bubble (z, t_0, p_end, t, p, k) Find the Wilson Kfactors at ~10 bar to initialize a bubble point Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: z (:) real(kind=pr), intent(in) :: t_0 real(kind=pr), intent(in) :: p_end real(kind=pr), intent(inout) :: t real(kind=pr), intent(inout) :: p real(kind=pr), intent(out) :: k (size(z)) public subroutine pt_F_three_phases (Xvars, ns, S, F, df) Function to solve at each point of a three phase envelope. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: Xvars (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(out) :: F (size(Xvars)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(Xvars),size(Xvars)) Jacobian matrix public subroutine pt_envelope_three_phase (X0, spec_number, del_S0, envel) Subroutine to calculate Px phase envelopes via continuation method.\nThree phases version. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X0 (:) Vector of variables integer, intent(in) :: spec_number Number of specification real(kind=pr), intent(in) :: del_S0 type( PTEnvel3 ), intent(out) :: envel Calculated envelopes public subroutine pt_three_phase_from_intersection (pt_x, pt_y, intersections, pt_x_3, pt_y_3) Arguments Type Intent Optional Attributes Name type( envelope ), intent(in) :: pt_x type( envelope ), intent(in) :: pt_y type( point ), intent(in) :: intersections (:) type( PTEnvel3 ), intent(out) :: pt_x_3 (:) type( PTEnvel3 ), intent(out) :: pt_y_3 (:) public subroutine update_specification (iter, passingcri, X, dF, ns, S, delS, dXdS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iter logical, intent(in) :: passingcri real(kind=pr), intent(in) :: X (nc+2) real(kind=pr), intent(in) :: dF (nc+2,nc+2) integer, intent(inout) :: ns real(kind=pr), intent(inout) :: S real(kind=pr), intent(inout) :: delS real(kind=pr), intent(inout) :: dXdS (nc+2)","tags":"","loc":"module/envelopes.html"},{"title":"io_nml – fenvelopes","text":"Namelist I/O Module Module that holds all the I/O routines to read from a setup file\nand setup the models and parameters included included in the thermodynamic\nroutines ```fortran ! Namelist based input file\n ! =========================\n !\n ! Units:\n !  - Pressure: bar\n !  - Temperature: K\n !  - Volume: L\n ! ========================= &nml_setup\n     nc=3,                    ! Number of components\n     model=”PR78”,            ! SRK PR76 PR78 RKPR\n     mixrule=”ClassicVdW”     ! ClassicVdW\n / &nml_composition\n     names=”C4” “C20” “H2O”\n     spec=”critical”          ! critical or parameters\n     z=0.16 0.04 0.8\n / &nml_classicvdw\n     kij(1, :)=0   0   0.5\n     kij(2, :)=0   0   0.5\n     kij(3, :)=0.5 0.5 0\n / &nml_critical\n     ! Critical constants\n     tc=425.2 782.0 647.3\n     pc=38.0 14.6 220.89\n     w=0.1928 0.816 0.344\n / Uses constants legacy_ar_models io module~~io_nml~~UsesGraph module~io_nml io_nml module~constants constants module~io_nml->module~constants legacy_ar_models legacy_ar_models module~io_nml->legacy_ar_models io io module~io_nml->io iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~io_nml~~UsedByGraph module~io_nml io_nml proc~setup setup proc~setup->module~io_nml Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables mixrule model names nunit_input path_to_file spec Subroutines read_system setup_input write_system read_components read_kij_lij read_model read_pr76 read_pr78 read_srk Variables Type Visibility Attributes Name Initial character(len=50), public :: mixrule character(len=50), public :: model character(len=50), public, allocatable :: names (:) integer, public :: nunit_input character(len=254), public :: path_to_file character(len=50), public :: spec Subroutines public subroutine read_system (filepath) Arguments Type Intent Optional Attributes Name character(len=*) :: filepath public subroutine setup_input (filepath) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filepath Setup input file to be used\nPath to input file public subroutine write_system (file_unit) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: file_unit private subroutine read_components () Read components\nRead kij and lij matrixes\nSince in the ClassicVdW mixing rules the bij matrix is constant\nit’s stored beforehand Arguments None private subroutine read_kij_lij () Arguments None private subroutine read_model () Reads the thermodynamic model to be used and sets up the selector Arguments None private subroutine read_pr76 () Read PR76 model Arguments None private subroutine read_pr78 () Arguments None private subroutine read_srk () Read SRK model parameters Read more… Arguments None","tags":"","loc":"module/io_nml.html"},{"title":"dsp_lines – fenvelopes","text":"Module to calculate DSP lines Uses progress_bar_module inj_envelopes dtypes constants linalg module~~dsp_lines~~UsesGraph module~dsp_lines dsp_lines progress_bar_module progress_bar_module module~dsp_lines->progress_bar_module module~inj_envelopes inj_envelopes module~dsp_lines->module~inj_envelopes module~constants constants module~dsp_lines->module~constants module~linalg linalg module~dsp_lines->module~linalg module~dtypes dtypes module~dsp_lines->module~dtypes module~inj_envelopes->progress_bar_module module~inj_envelopes->module~constants module~inj_envelopes->module~linalg module~inj_envelopes->module~dtypes iso_fortran_env iso_fortran_env module~constants->iso_fortran_env module~linalg->module~constants module~dtypes->module~constants io io module~dtypes->io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~dsp_lines~~UsedByGraph module~dsp_lines dsp_lines proc~pt_envelopes pt_envelopes proc~pt_envelopes->module~dsp_lines Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables FE_LOG del_S_multiplier env_number max_dT max_da max_dp max_iters max_points Functions break_conditions_dsp_line dsp_line_from_dsp Subroutines dsp_line dsp_line_F fix_step Variables Type Visibility Attributes Name Initial character(len=255), public :: FE_LOG real(kind=pr), public :: del_S_multiplier = 1.0_pr integer, public :: env_number = 0 Number of calculated envelope real(kind=pr), public :: max_dT = 10.0_pr real(kind=pr), public :: max_da = 0.1_pr real(kind=pr), public :: max_dp = 20.0_pr integer, public :: max_iters = 1000 Maximum number of iterations for a newton step integer, public, parameter :: max_points = 1000 Maximum number of points for each envelope Functions public function break_conditions_dsp_line (X, ns, S, del_S) Set of conditions to break the tracing. Arguments Type Intent Optional Attributes Name real(kind=pr) :: X (:) Variables vector integer :: ns Number of specification real(kind=pr) :: S Value of specification real(kind=pr) :: del_S Return Value logical,allocatable, (:) public function dsp_line_from_dsp (inter, pt_1, pt_2, del_S0, alpha0) result(envels) Arguments Type Intent Optional Attributes Name type( point ), intent(in) :: inter type( envelope ), intent(in) :: pt_1 type( envelope ), intent(in) :: pt_2 real(kind=pr), optional :: del_S0 real(kind=pr), optional :: alpha0 Return Value type( injelope )(2) Subroutines public subroutine dsp_line (X0, spec_number, del_S0, envels) Subroutine to calculate Px phase envelopes via continuation method.\nThree phases version. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X0 (:) Vector of variables integer, intent(in) :: spec_number Number of specification real(kind=pr), intent(in) :: del_S0 type( injelope ), intent(out) :: envels Calculated envelopes public subroutine dsp_line_F (Xvars, ns, S, F, df) Function to solve at each point of a three phase envelope. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: Xvars (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(out) :: F (size(Xvars)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(Xvars),size(Xvars)) Jacobian matrix public subroutine fix_step (iters, X, ns, S, del_S, dXdS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: iters real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S real(kind=pr), intent(inout) :: del_S real(kind=pr), intent(inout) :: dXdS (size(X))","tags":"","loc":"module/dsp_lines.html"},{"title":"inj_envelopes – fenvelopes","text":"Module to calculate Px phase envelopes Uses linalg dtypes constants progress_bar_module module~~inj_envelopes~~UsesGraph module~inj_envelopes inj_envelopes module~linalg linalg module~inj_envelopes->module~linalg progress_bar_module progress_bar_module module~inj_envelopes->progress_bar_module module~constants constants module~inj_envelopes->module~constants module~dtypes dtypes module~inj_envelopes->module~dtypes module~linalg->module~constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env module~dtypes->module~constants io io module~dtypes->io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~inj_envelopes~~UsedByGraph module~inj_envelopes inj_envelopes module~dsp_lines dsp_lines module~dsp_lines->module~inj_envelopes proc~px_envelopes px_envelopes proc~px_envelopes->module~inj_envelopes program~main main program~main->module~inj_envelopes proc~setup setup proc~setup->module~inj_envelopes proc~pt_envelopes pt_envelopes proc~pt_envelopes->module~dsp_lines Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables FE_LOG T critical_fact critical_multiplier del_S_multiplier del_S_multiplier_three_phase env_number injection_case max_dalpha max_dp max_iters max_points z_0 z_injection Derived Types injelope Functions break_conditions break_conditions_three_phases get_case px_hpl_line px_three_phase_from_inter px_three_phase_from_pt px_two_phase_from_pt remove_duplicates same_line Subroutines F_injection F_injection_three_phases fix_step_two_phases from_nml get_z injection_envelope injection_envelope_three_phase update_spec Variables Type Visibility Attributes Name Initial character(len=255), public :: FE_LOG real(kind=pr), public :: T Temperature of injection real(kind=pr), public :: critical_fact = 3.0_pr real(kind=pr), public :: critical_multiplier = 2.0_pr real(kind=pr), public :: del_S_multiplier = 2.0_pr real(kind=pr), public :: del_S_multiplier_three_phase = 1.7_pr integer, public :: env_number = 0 Number of calculated envelope character(len=10), public :: injection_case Kind of injection displace|dilute real(kind=pr), public :: max_dalpha = 0.01_pr real(kind=pr), public :: max_dp = 50.0_pr integer, public :: max_iters = 50 Maximum number of iterations for a newton step integer, public, parameter :: max_points = 1000 Maximum number of points for each envelope real(kind=pr), public, allocatable :: z_0 (:) Original fluid composition real(kind=pr), public, allocatable :: z_injection (:) Injection fluid composition Derived Types type, public, extends( envelope ) :: injelope Components Type Visibility Attributes Name Initial real(kind=pr), public, allocatable :: alpha (:) Ammount of injected fluid real(kind=pr), public, allocatable :: z_inj (:) Injected fluid composition real(kind=pr), public, allocatable :: z_mix (:,:) Composition at each step Type-Bound Procedures procedure, public :: write => write_envel_2 Functions public function break_conditions (X, ns, S, del_S) Set of conditions to break the tracing of a two phase line. Arguments Type Intent Optional Attributes Name real(kind=pr) :: X (:) Vector of variables integer :: ns Number of specification real(kind=pr) :: S Specification value real(kind=pr) :: del_S Return Value logical,allocatable, (:) public function break_conditions_three_phases (X, ns, S, del_S) Set of conditions to break the tracing. Arguments Type Intent Optional Attributes Name real(kind=pr) :: X (:) Variables vector integer :: ns Number of specification real(kind=pr) :: S Value of specification real(kind=pr) :: del_S Return Value logical,allocatable, (:) public function get_case (dew_envel, bub_envel) result(n_case) Arguments Type Intent Optional Attributes Name type( injelope ), intent(in) :: dew_envel type( injelope ), intent(in) :: bub_envel Return Value integer public function px_hpl_line (alpha_0, p) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: alpha_0 Staring to search real(kind=pr), intent(in) :: p Pressure of HPLL Return Value type( injelope ) Resulting HPLL line public function px_three_phase_from_inter (inter, px_1, px_2, del_S0, beta0) result(envels) Arguments Type Intent Optional Attributes Name type( point ), intent(in) :: inter type( injelope ), intent(in) :: px_1 type( injelope ), intent(in) :: px_2 real(kind=pr), optional :: del_S0 real(kind=pr), optional :: beta0 Return Value type( injelope )(2) public function px_three_phase_from_pt (t_inj, pt_env_3, t_tol, del_S0) result(envel) Calculate three phase Px envelopes at a given injection temperature. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: t_inj Injection temperature [K] type( PTEnvel3 ), intent(in) :: pt_env_3 (:) Base PT envelopes real(kind=pr), intent(in) :: t_tol Absolute temperature tolerance real(kind=pr), intent(in), optional :: del_S0 First point Return Value type( injelope ) Output Px envelope public function px_two_phase_from_pt (t_inj, pt_env_2, t_tol, del_S0) result(envel) Calculate two phase Px envelopes at a given injection temperature. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: t_inj Injection temperature [K] type( envelope ), intent(in) :: pt_env_2 Base PT envelope real(kind=pr), intent(in) :: t_tol Absolute temperature tolerance real(kind=pr), intent(in), optional :: del_S0 First point Return Value type( injelope ) Output Px envelope public function remove_duplicates (envels) result(clean_envels) From a set of envelopes check if they are the same line Arguments Type Intent Optional Attributes Name class( injelope ) :: envels (:) Return Value type( injelope ),allocatable, (:) public function same_line (env1, env2) Arguments Type Intent Optional Attributes Name class( injelope ), intent(in) :: env1 class( injelope ), intent(in) :: env2 Return Value logical Subroutines public subroutine F_injection (X, ns, S, F, df) Function to solve at each point of the phase envelope. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(out) :: F (size(X)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(x),size(X)) Jacobian matrix public subroutine F_injection_three_phases (Xvars, ns, S, F, df) Function to solve at each point of a three phase envelope. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: Xvars (:) Vector of variables integer, intent(in) :: ns Number of specification real(kind=pr), intent(in) :: S Specification value real(kind=pr), intent(out) :: F (size(Xvars)) Vector of functions valuated real(kind=pr), intent(out) :: df (size(Xvars),size(Xvars)) Jacobian matrix public subroutine fix_step_two_phases (X, ns, S, solve_its, del_S, dXdS) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(in) :: ns real(kind=pr), intent(in) :: S integer, intent(in) :: solve_its real(kind=pr), intent(inout) :: del_S real(kind=pr), intent(inout) :: dXdS (size(X)) public subroutine from_nml (filepath) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filepath public subroutine get_z (alpha, z, dzda) Calculate the fluid composition based on an amount of addition\nof second fluid. Read more… Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: alpha Addition percentaje real(kind=pr), intent(out) :: z (size(z_0)) New composition real(kind=pr), intent(out), optional :: dzda (size(z_0)) Derivative wrt public subroutine injection_envelope (X0, spec_number, del_S0, envels) Subroutine to calculate Px phase envelopes via continuation method Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X0 (:) Vector of variables integer, intent(in) :: spec_number Number of specification real(kind=pr), intent(in) :: del_S0 type( injelope ), intent(out) :: envels Calculated envelopes public subroutine injection_envelope_three_phase (X0, spec_number, del_S0, envels) Subroutine to calculate Px phase envelopes via continuation method.\nThree phases version. Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X0 (:) Vector of variables integer, intent(in) :: spec_number Number of specification real(kind=pr), intent(in) :: del_S0 type( injelope ), intent(out) :: envels Calculated envelopes public subroutine update_spec (X, ns, del_S, dF, dXdS) Arguments Type Intent Optional Attributes Name real(kind=pr), intent(in) :: X (:) integer, intent(inout) :: ns real(kind=pr), intent(inout) :: del_S real(kind=pr), intent(in) :: dF (size(X),size(X)) real(kind=pr), intent(inout) :: dXdS (size(X))","tags":"","loc":"module/inj_envelopes.html"},{"title":"constants – fenvelopes","text":"Uses iso_fortran_env module~~constants~~UsesGraph module~constants constants iso_fortran_env iso_fortran_env module~constants->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~constants~~UsedByGraph module~constants constants proc~pt_envelope_three_phase pt_envelope_three_phase proc~pt_envelope_three_phase->module~constants module~inj_envelopes inj_envelopes module~inj_envelopes->module~constants module~linalg linalg module~inj_envelopes->module~linalg module~dtypes dtypes module~inj_envelopes->module~dtypes proc~injection_envelope injection_envelope proc~injection_envelope->module~constants module~envelopes envelopes module~envelopes->module~constants module~envelopes->module~linalg module~envelopes->module~dtypes proc~dsp_line dsp_line proc~dsp_line->module~constants module~dsp_lines dsp_lines module~dsp_lines->module~constants module~dsp_lines->module~inj_envelopes module~dsp_lines->module~linalg module~dsp_lines->module~dtypes module~io_nml io_nml module~io_nml->module~constants program~main main program~main->module~constants program~main->module~inj_envelopes program~main->module~envelopes program~main->module~dtypes proc~full_newton full_newton proc~full_newton->module~constants module~linalg->module~constants proc~envelope2 envelope2 proc~envelope2->module~constants proc~envelope2->module~linalg proc~envelope2->module~dtypes module~dtypes->module~constants proc~injection_envelope_three_phase injection_envelope_three_phase proc~injection_envelope_three_phase->module~constants module~phase_equilibria phase_equilibria module~phase_equilibria->module~constants proc~px_envelopes px_envelopes proc~px_envelopes->module~inj_envelopes proc~px_envelopes->module~envelopes proc~px_envelopes->module~linalg proc~pt_envelopes pt_envelopes proc~pt_envelopes->module~envelopes proc~pt_envelopes->module~dsp_lines proc~pt_envelopes->module~linalg proc~px_three_phase_from_pt px_three_phase_from_pt proc~px_three_phase_from_pt->module~envelopes proc~px_three_phase_from_pt->module~linalg proc~px_hpl_line px_hpl_line proc~px_hpl_line->module~linalg proc~pt_three_phase_from_intersection pt_three_phase_from_intersection proc~pt_three_phase_from_intersection->module~linalg proc~setup setup proc~setup->module~inj_envelopes proc~setup->module~io_nml proc~dsp_line_from_dsp dsp_line_from_dsp proc~dsp_line_from_dsp->module~linalg proc~get_case get_case proc~get_case->module~linalg proc~px_three_phase_from_inter px_three_phase_from_inter proc~px_three_phase_from_inter->module~linalg proc~px_two_phase_from_pt px_two_phase_from_pt proc~px_two_phase_from_pt->module~linalg Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables R database_path ouput_path path_sep pr Variables Type Visibility Attributes Name Initial real(kind=pr), public, parameter :: R = 0.08314472 character(len=254), public :: database_path = \"database/\" character(len=254), public :: ouput_path = \"fenvelopes_output/\" character(len=1), public :: path_sep = \"/\" integer, public, parameter :: pr = real64","tags":"","loc":"module/constants.html"},{"title":"main – fenvelopes","text":"Uses flap inj_envelopes dtypes constants stdlib_ansi legacy_ar_models envelopes program~~main~~UsesGraph program~main main stdlib_ansi stdlib_ansi program~main->stdlib_ansi module~inj_envelopes inj_envelopes program~main->module~inj_envelopes legacy_ar_models legacy_ar_models program~main->legacy_ar_models module~envelopes envelopes program~main->module~envelopes flap flap program~main->flap module~constants constants program~main->module~constants module~dtypes dtypes program~main->module~dtypes module~inj_envelopes->module~constants module~inj_envelopes->module~dtypes module~linalg linalg module~inj_envelopes->module~linalg progress_bar_module progress_bar_module module~inj_envelopes->progress_bar_module module~envelopes->legacy_ar_models module~envelopes->module~constants module~envelopes->module~dtypes module~envelopes->module~linalg module~envelopes->progress_bar_module iso_fortran_env iso_fortran_env module~constants->iso_fortran_env module~dtypes->module~constants io io module~dtypes->io module~linalg->module~constants Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Calls program~~main~~CallsGraph program~main main proc~setup setup program~main->proc~setup proc~px_envelopes px_envelopes program~main->proc~px_envelopes proc~get_z get_z program~main->proc~get_z proc~pt_envelopes pt_envelopes program~main->proc~pt_envelopes proc~setup_cli setup_cli proc~setup->proc~setup_cli proc~from_nml from_nml proc~setup->proc~from_nml proc~read_system read_system proc~setup->proc~read_system proc~write_system write_system proc~setup->proc~write_system proc~px_three_phase_from_pt px_three_phase_from_pt proc~px_envelopes->proc~px_three_phase_from_pt proc~px_two_phase_from_pt px_two_phase_from_pt proc~px_envelopes->proc~px_two_phase_from_pt proc~px_hpl_line px_hpl_line proc~px_envelopes->proc~px_hpl_line interface~intersection intersection proc~px_envelopes->interface~intersection px_branch_3 px_branch_3 proc~px_envelopes->px_branch_3 proc~px_three_phase_from_inter px_three_phase_from_inter proc~px_envelopes->proc~px_three_phase_from_inter proc~k_wilson k_wilson proc~pt_envelopes->proc~k_wilson proc~k_wilson_bubble k_wilson_bubble proc~pt_envelopes->proc~k_wilson_bubble proc~dsp_line_from_dsp dsp_line_from_dsp proc~pt_envelopes->proc~dsp_line_from_dsp proc~p_wilson p_wilson proc~pt_envelopes->proc~p_wilson proc~pt_three_phase_from_intersection pt_three_phase_from_intersection proc~pt_envelopes->proc~pt_three_phase_from_intersection proc~find_hpl find_hpl proc~pt_envelopes->proc~find_hpl dsps dsps proc~pt_envelopes->dsps proc~envelope2 envelope2 proc~pt_envelopes->proc~envelope2 proc~get_case get_case proc~pt_envelopes->proc~get_case optval optval proc~px_three_phase_from_pt->optval proc~interpol interpol proc~px_three_phase_from_pt->proc~interpol proc~injection_envelope_three_phase injection_envelope_three_phase proc~px_three_phase_from_pt->proc~injection_envelope_three_phase proc~px_two_phase_from_pt->optval proc~injection_envelope injection_envelope proc~px_two_phase_from_pt->proc~injection_envelope proc~px_two_phase_from_pt->proc~interpol proc~k_wilson_bubble->proc~k_wilson proc~dsp_line_from_dsp->proc~get_z proc~dsp_line dsp_line proc~dsp_line_from_dsp->proc~dsp_line proc~dsp_line_from_dsp->optval proc~dsp_line_from_dsp->proc~interpol none~foo foo proc~px_hpl_line->none~foo proc~px_hpl_line->proc~injection_envelope proc~pt_envelope_three_phase pt_envelope_three_phase proc~pt_three_phase_from_intersection->proc~pt_envelope_three_phase proc~pt_three_phase_from_intersection->proc~interpol termo termo proc~find_hpl->termo z z proc~find_hpl->z proc~intersect_two_lines intersect_two_lines interface~intersection->proc~intersect_two_lines proc~intersect_one_line intersect_one_line interface~intersection->proc~intersect_one_line proc~read_components read_components proc~read_system->proc~read_components proc~setup_input setup_input proc~read_system->proc~setup_input proc~read_model read_model proc~read_system->proc~read_model lij lij proc~write_system->lij str str proc~write_system->str kij kij proc~write_system->kij proc~px_three_phase_from_inter->proc~get_z proc~px_three_phase_from_inter->optval proc~px_three_phase_from_inter->proc~interpol proc~px_three_phase_from_inter->proc~injection_envelope_three_phase proc~solve_system solve_system proc~envelope2->proc~solve_system proc~update_specification update_specification proc~envelope2->proc~update_specification proc~f2 F2 proc~envelope2->proc~f2 delta_x delta_x proc~envelope2->delta_x proc~fix_delx fix_delx proc~envelope2->proc~fix_delx proc~envelope2->str m m proc~envelope2->m xin xin proc~envelope2->xin proc~get_case->interface~intersection proc~pt_envelope_three_phase->proc~solve_system proc~pt_envelope_three_phase->str proc~full_newton full_newton proc~pt_envelope_three_phase->proc~full_newton proc~break_conditions_three_phases break_conditions_three_phases proc~pt_envelope_three_phase->proc~break_conditions_three_phases progress_bar progress_bar proc~pt_envelope_three_phase->progress_bar xnew xnew proc~pt_envelope_three_phase->xnew knew knew proc~pt_envelope_three_phase->knew dxds_in dxds_in proc~pt_envelope_three_phase->dxds_in k k proc~pt_envelope_three_phase->k none~dgesv dgesv proc~solve_system->none~dgesv proc~update_specification->proc~solve_system proc~dfds dFdS proc~update_specification->proc~dfds proc~f2->termo proc~intersects intersects proc~intersect_two_lines->proc~intersects proc~read_components->lij proc~read_srk read_srk proc~read_components->proc~read_srk proc~read_kij_lij read_kij_lij proc~read_components->proc~read_kij_lij b b proc~read_components->b proc~read_pr76 read_pr76 proc~read_components->proc~read_pr76 bij bij proc~read_components->bij proc~read_pr78 read_pr78 proc~read_components->proc~read_pr78 proc~intersect_one_line->proc~intersects proc~dsp_line->str proc~fix_step fix_step proc~dsp_line->proc~fix_step proc~dsp_line->proc~full_newton proc~dsp_line->progress_bar proc~break_conditions_dsp_line break_conditions_dsp_line proc~dsp_line->proc~break_conditions_dsp_line proc~update_spec update_spec proc~dsp_line->proc~update_spec none~foo->proc~get_z none~foo->termo proc~injection_envelope->proc~get_z proc~injection_envelope->str proc~injection_envelope->proc~full_newton proc~injection_envelope->progress_bar proc~fix_step_two_phases fix_step_two_phases proc~injection_envelope->proc~fix_step_two_phases proc~injection_envelope->proc~update_spec proc~injection_envelope->xnew proc~injection_envelope->knew proc~break_conditions break_conditions proc~injection_envelope->proc~break_conditions proc~read_model->z setup setup proc~read_model->setup proc~injection_envelope_three_phase->proc~get_z proc~injection_envelope_three_phase->str proc~injection_envelope_three_phase->proc~full_newton proc~injection_envelope_three_phase->progress_bar proc~injection_envelope_three_phase->proc~update_spec proc~break_conditions_three_phases~2 break_conditions_three_phases proc~injection_envelope_three_phase->proc~break_conditions_three_phases~2 proc~injection_envelope_three_phase->knew proc~injection_envelope_three_phase->dxds_in srk_factory srk_factory proc~read_srk->srk_factory proc~full_newton->proc~solve_system proc~read_kij_lij->lij proc~read_kij_lij->kij proc~update_spec->proc~solve_system proc~intersects->proc~solve_system pr76_factory pr76_factory proc~read_pr76->pr76_factory pr78_factory pr78_factory proc~read_pr78->pr78_factory Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables alpha cli cli_error cli_string et pt_bub pt_bub_3 pt_dew pt_dew_3 pt_hpl px_bub px_dew px_hpl st Subroutines pt_envelopes px_envelopes setup setup_cli Variables Type Attributes Name Initial real(kind=pr) :: alpha = 0.0 type(command_line_interface) :: cli integer :: cli_error character(len=99) :: cli_string real(kind=pr) :: et type( envelope ) :: pt_bub Shared 2ph-PT envelopes type( PTEnvel3 ), allocatable :: pt_bub_3 (:) Shared 3ph-PT envelopes type( envelope ) :: pt_dew Shared 2ph-PT envelopes type( PTEnvel3 ), allocatable :: pt_dew_3 (:) Shared 3ph-PT envelopes type( envelope ) :: pt_hpl Shared 2ph-PT envelopes type( injelope ) :: px_bub Shared 2ph-Px envelopes type( injelope ) :: px_dew Shared 2ph-Px envelopes type( injelope ) :: px_hpl Shared 2ph-Px envelopes real(kind=pr) :: st Subroutines subroutine pt_envelopes () Calculation of PT envelopes of the main system. Arguments None subroutine px_envelopes () Calculation of Px envelopes at selected temperature. Arguments None subroutine setup () Setup system Read more… Arguments None subroutine setup_cli () Setup CLI subroutine Read more… Arguments None","tags":"","loc":"program/main.html"},{"title":"Flash.f90 – fenvelopes","text":"This file depends on sourcefile~~flash.f90~~EfferentGraph sourcefile~flash.f90 Flash.f90 sourcefile~constants.f90 constants.f90 sourcefile~flash.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules phase_equilibria Source Code Flash.f90 Source Code module phase_equilibria use constants , only : pr use legacy_ar_models , only : zTVTERMO , termo , n => nc , omg => w , tc , pc implicit none contains subroutine flash_pt ( z , p , t , x , y , beta , its ) real ( pr ), intent ( in ) :: z (:) !! Feed phase molar fractions real ( pr ), intent ( in ) :: p !! Pressure [bar] real ( pr ), intent ( in ) :: t !! Temperature [K] real ( pr ), intent ( out ) :: x ( size ( z )) !! Phase X molar fractions real ( pr ), intent ( out ) :: y ( size ( z )) !! Phase Y molar fractions real ( pr ), intent ( out ) :: beta !! Molar Y fraction real ( pr ), optional , intent ( out ) :: its !! Number of iterations real ( pr ) :: rho_x , rho_y end subroutine subroutine flash ( spec , FIRST , z , t , p , v , x , y , rho_x , rho_y , beta , iter ) ! Flash specification, eos id and  number of compounds in the system character ( len =* ), intent ( in ) :: spec !! Flash specification [PT | VT] logical , intent ( in out ) :: FIRST logical :: stopflash ! composition of the system real * 8 , intent ( in ) :: z (:) ! Temperature and Pressure for the flash real * 8 , intent ( in ) :: t ! Temperature for the flash (K) real * 8 :: p ! (bar) Pressure for the flash (TP) or resulting from (TV) real * 8 :: v ! (L/mol) Molar vol for the flash (TV) or resulting from (TP) ! Results from flash calculation real * 8 , dimension ( size ( z )), intent ( out ) :: x ! composition of liquid (molar fractions) real * 8 , dimension ( size ( z )), intent ( out ) :: y ! composition of vapour (molar fractions) real * 8 , intent ( out ) :: rho_x ! density of liquid (moles/L) real * 8 , intent ( out ) :: rho_y ! density of vapour (moles/L) real * 8 , intent ( out ) :: beta ! total fraction of vapour (molar base) integer , intent ( out ) :: iter ! number of iterations required to converge ! Intermediate variables during calculation process real * 8 , dimension ( n ) :: PHILOGy , PHILOGx , DLPHIT , DLPHIP real * 8 , dimension ( n ) :: KFACT , LOG_K , AUXK , var_K , denom , varKold , logKold real * 8 , dimension ( n , n ) :: FUGN real * 8 :: g0 , g1 ! function g valuated at beta=0 and 1, based on Wilson K factors real * 8 :: g , dg , bmin , bmax , Vy , Vx ! real*8, dimension(nco, nco) :: Kij_or_K0, Tstar ! real*8, dimension(nco) :: saveK, LOG_K2 real ( 8 ) :: aux , bx , savek ( n ), log_k2 ( n ) integer :: MTYP real ( 8 ) :: dh , dpv , DPVl , dpvv , dVydVl , h , pl , pold , pold2 , pv , step , stepv real ( 8 ) :: told , told2 , bij ( n , n ) integer :: i , j , iterv , nco ! do i = 1, n !    do j = i, n !       bij(i, j) = (1 - lij(i, j))*(b(i) + b(j))/2 !       bij(j, i) = bij(i, j) !    end do ! end do ! !----------------------------------------------------------- ! This algorithm assumes that the specified T and P correspond to ! vapor-liquid separation predicted by the provided model (0<beta<1) if ( spec == 'TV' . or . spec == 'isoV' ) then Vx = 0.0 if ( FIRST ) then ! the EoS one-phase pressure will be used to estimate Wilson K factors call zTVTERMO ( n , 0 , T , z , V , P , DPV , PHILOGy , DLPHIP , DLPHIT , FUGN ) if ( P < 0 ) P = 1.0 end if end if AUXK = log ( saveK ( 1 : n )) if ( FIRST ) then !  use Wilson to initiate the first flash KFACT = ( PC / P ) * exp ( 5.373 * ( 1 + omg ) * ( 1 - TC / T )) Pold2 = 0.d0 Pold = 0.d0 Told2 = 0.d0 Told = 0.d0 else !  for running the indirect \"Tv flash\" for comparisonn purposes !        else if(Pold2==0.d0.or.spec=='TV')then ! use the converged K's from the previous flash KFACT = saveK ( 1 : n ) !        else ! use extrapolation based on the last two points (not resolved yet for series of TV flashes) !            if(spec=='isoV')    LOG_K = AUXK + (AUXK - LOG_K2) !            if(spec=='TP'.and.P/=Pold)      LOG_K = AUXK + (AUXK - LOG_K2)*(P-Pold)/(Pold-Pold2) !            if(spec=='TP'.and.T/=Told)      LOG_K = AUXK + (AUXK - LOG_K2)*(T-Told)/(Told-Told2) !            KFACT = EXP(LOG_K) end if LOG_K2 (: n ) = AUXK Pold2 = Pold Pold = P Told2 = Told Told = T ! WRITE (2,3) (KFACT(i),i=1,N) call betato01 ( n , z , KFACT ) ! adapted 26/11/2014 LOG_K = log ( KFACT ) ! now we must have  g0>0 and g1<0 and therefore 0<beta<1 (M&M page 252) call betalimits ( n , z , KFACT , bmin , bmax ) beta = ( bmin + bmax ) / 2 ! first guess for beta ! Succesive sustitution loop starts here var_K = 1.0 iter = 0 do while ( maxval ( abs ( var_K )) > 1.d-6 ) if ( maxval ( abs ( var_K )) > 1.10 ) then ! 26/11/2014 g0 = sum ( z * KFACT ) - 1.D0 g1 = 1.D0 - sum ( z / KFACT ) if ( g0 < 0 . or . g1 > 0 ) then ! bring beta back to range, by touching KFACT call betato01 ( n , z , KFACT ) call betalimits ( n , z , KFACT , bmin , bmax ) beta = ( bmin + bmax ) / 2 ! new guess for beta end if end if iter = iter + 1 ! Newton starts here (Rachford-Rice) g = 1.0 step = 1.0 do while ( abs ( g ) > 1.d-5 . and . abs ( step ) > 1.d-10 ) denom = 1 + beta * ( KFACT - 1.D0 ) g = sum ( z * ( KFACT - 1.D0 ) / denom ) dg = - sum ( z * ( KFACT - 1.D0 ) ** 2 / denom ** 2 ) step = - g / dg beta = beta + step do while (( beta < bmin . or . bmax < beta ) . and . step > 1e-10 ) ! much better (GUARANTED!) 3/3/15 step = step / 2 beta = beta - step end do end do denom = 1 + beta * ( KFACT - 1.D0 ) y = z * KFACT / denom x = y / KFACT ! new for TV Flash if ( spec == 'TV' . or . spec == 'isoV' ) then ! find Vy,Vx (vV and vL) from V balance and P equality equations dVydVl = - ( 1 - beta ) / beta ! call Bcalc(n, x, T, Bx) ! TODO: Add this intiial volume if ( Vx < Bx ) Vx = 1.625 * Bx ! First evaluation will be with Vx = 1.5*Bx ! Pl = -1.0 call zTVTERMO ( n , 0 , T , x , Vx , Pl , DPVl , PHILOGy , DLPHIP , DLPHIT , FUGN ) ! 26/06/15 do while ( Pl < 0 . or . DPVl >= 0 ) Vx = Vx - 0.2 * ( Vx - Bx ) call zTVTERMO ( n , 0 , T , x , Vx , Pl , DPVl , PHILOGy , DLPHIP , DLPHIT , FUGN ) end do Vy = ( v - ( 1 - beta ) * Vx ) / beta h = 1.0 iterv = 0 stopflash = . false . do while ( abs ( h ) > 1.d-4 ) ! Newton for solving P equality, with Vx as independent variable iterv = iterv + 1 if ( iterv >= 100 ) then write ( 2 , * ) 'volume convergence problems' P = - 1.0 stopflash = . true . exit end if call zTVTERMO ( n , 0 , T , x , Vx , Pl , DPVl , PHILOGy , DLPHIP , DLPHIT , FUGN ) call zTVTERMO ( n , 0 , T , y , Vy , Pv , DPVv , PHILOGy , DLPHIP , DLPHIT , FUGN ) h = Pv - Pl dh = - DPVv * dVydVl - DPVl stepv = - h / dh if ( iterv >= 10 ) stepv = stepv / 2 Vx = Vx + stepv do while ( Vx < 1.001 * Bx ) stepv = stepv / 2 Vx = Vx - stepv end do Vy = ( v - ( 1 - beta ) * Vx ) / beta end do if ( stopflash . eqv . . true .) exit call zTVTERMO ( n , 1 , T , x , Vx , Pl , DPVl , PHILOGx , DLPHIP , DLPHIT , FUGN ) call zTVTERMO ( n , 1 , T , y , Vy , Pv , DPVv , PHILOGy , DLPHIP , DLPHIT , FUGN ) else ! for TP Flash ! nc,MTYP,INDIC,T,P,rn,V,PHILOG,DLPHI MTYP = 0 ! -1   (with 0, generalized also fo LL and not only VL) call TERMO ( n , MTYP , 1 , T , P , y , Vy , PHILOGy , DLPHIP , DLPHIT , FUGN ) MTYP = 1 call TERMO ( n , MTYP , 1 , T , P , x , Vx , PHILOGx , DLPHIP , DLPHIT , FUGN ) end if varKold = var_K logKold = LOG_K ! From previous iteration step var_K = PHILOGx - PHILOGy - LOG_K ! variation in LOG_K = new - old LOG_K = PHILOGx - PHILOGy aux = sum ( var_K + varKold ) if ( iter > 10 . and . abs ( aux ) < 0.05 ) then ! oscilation behavior detected (27/06/15) LOG_K = ( LOG_K + logKold ) / 2 end if KFACT = exp ( LOG_K ) call betalimits ( n , z , KFACT , bmin , bmax ) ! 26/06/15 if (( beta < bmin ) . or . ( bmax < beta )) then beta = ( bmin + bmax ) / 2 end if if ( iter > 500 ) then p = - 1 return end if end do !  WRITE (2,4) (KFACT(i),i=1,N) rho_x = 1 / Vx rho_y = 1 / Vy if ( spec == 'TP' ) v = beta * Vy + ( 1 - beta ) * Vx if ( spec == 'TV' . or . spec == 'isoV' ) write ( 4 , * ) T , P , Pv if ( spec == 'TV' . or . spec == 'isoV' ) P = Pv FIRST = . false . if ( maxval ( KFACT ) < 1.001 . and . minval ( KFACT ) > 0.999 ) then ! trivial solution P = - 1.0 return !go to 31 end if saveK ( 1 : n ) = KFACT ! 3  format('KWilson ', 15E12.4) ! 4  format('KFinal  ', 15E12.4) !----------------------------------------------------------- ! print *, x  ! Estos print son los que \"lee\" tanto Fluids como Sur ! print *, y ! print *, rho_x ! print *, rho_y ! print *, beta end subroutine flash subroutine betato01 ( n , z , KFACT ) implicit none integer , intent ( in ) :: n ! number of compounds in the system real * 8 , dimension ( n ), intent ( in ) :: z ! composition of the system real * 8 , dimension ( n ) :: KFACT ! K factors (modified in this routine) real * 8 :: g0 , g1 ! function g valuated at beta=0 and 1, based on K factors g1 = 1.0 do while ( g0 < 0 . or . g1 > 0 ) g0 = sum ( z * KFACT ) - 1.D0 g1 = 1.D0 - sum ( z / KFACT ) if ( g0 < 0 ) then KFACT = 1.1 * KFACT ! increased volatiliy will bring the solution from subcooled liquid into VLE else if ( g1 > 0 ) then KFACT = 0.9 * KFACT ! decreased volatiliy will bring the solution from superheated vapor into VLE end if end do end subroutine betato01 subroutine betalimits ( n , z , KFACT , bmin , bmax ) implicit none integer , intent ( in ) :: n ! number of compounds in the system real * 8 , dimension ( n ), intent ( in ) :: z , KFACT ! composition of the system and K factors real * 8 , intent ( out ) :: bmin , bmax real * 8 , dimension ( n ) :: vmin , vmax integer :: i , in , ix in = 0 ix = 0 vmin = 0.d0 ! max=1.001d0    ! modified  3/3/15 (not to generate false separations with beta 0.9999...) vmax = 1.00001d0 ! modified 28/6/15 (to prevent overshooting in the Newton for solving RR eq.) do i = 1 , n if ( KFACT ( i ) * z ( i ) > 1 ) then in = in + 1 vmin ( in ) = ( KFACT ( i ) * z ( i ) - 1.d0 ) / ( KFACT ( i ) - 1.d0 ) else if ( KFACT ( i ) < z ( i )) then ix = ix + 1 vmax ( ix ) = ( 1.d0 - z ( i )) / ( 1.d0 - KFACT ( i )) end if end do bmin = maxval ( vmin ) bmax = minval ( vmax ) end subroutine betalimits end module","tags":"","loc":"sourcefile/flash.f90.html"},{"title":"linalg.f90 – fenvelopes","text":"This file depends on sourcefile~~linalg.f90~~EfferentGraph sourcefile~linalg.f90 linalg.f90 sourcefile~constants.f90 constants.f90 sourcefile~linalg.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~linalg.f90~~AfferentGraph sourcefile~linalg.f90 linalg.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~envelopes.f90->sourcefile~linalg.f90 sourcefile~mod_dsp_lines.f90 mod_dsp_lines.f90 sourcefile~mod_dsp_lines.f90->sourcefile~linalg.f90 sourcefile~mod_inj_envelopes.f90 mod_inj_envelopes.f90 sourcefile~mod_dsp_lines.f90->sourcefile~mod_inj_envelopes.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~linalg.f90 sourcefile~main.f90->sourcefile~envelopes.f90 sourcefile~main.f90->sourcefile~mod_dsp_lines.f90 sourcefile~main.f90->sourcefile~mod_inj_envelopes.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~linalg.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~envelopes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules linalg Source Code linalg.f90 Source Code module linalg !! Wrapper module around LAPACK's `dgesv` and lines intersections detector use constants , only : pr implicit none type :: point real ( pr ) :: x real ( pr ) :: y integer :: i integer :: j end type point interface intersection module procedure :: intersect_two_lines module procedure :: intersect_one_line end interface contains function solve_system ( a , b ) result ( x ) real ( pr ), intent ( in ) :: b (:) real ( pr ), intent ( in ) :: a ( size ( b ), size ( b )) real ( pr ) :: x ( size ( b )) real ( 8 ) :: a_lapack ( size ( b ), size ( b )), b_lapack ( size ( b )) integer :: n , nrhs , lda , ipiv ( size ( b )), ldb , info interface subroutine dgesv ( n , nrhs , a , lda , ipiv , b , ldb , info ) integer :: n integer :: nrhs real ( 8 ) :: a ( n , n ) integer :: lda integer :: ipiv ( n ) real ( 8 ) :: b ( n ) integer :: ldb integer :: info end subroutine end interface n = size ( a , dim = 1 ) nrhs = 1 lda = n ldb = n a_lapack = a b_lapack = b call dgesv ( n , nrhs , a_lapack , lda , ipiv , b_lapack , ldb , info ) x = b_lapack end function solve_system function intersect_two_lines ( l1_x , l1_y , l2_x , l2_y ) result ( intersections ) real ( pr ), intent ( in ) :: l1_x (:), l1_y (:), l2_x (:), l2_y (:) type ( point ), allocatable :: intersections (:) real ( pr ) :: s , t integer :: i , j real ( pr ) :: x , y , xold = 9999 , yold = 9999 allocate ( intersections ( 0 )) line1 : do i = 2 , size ( l1_x ) line2 : do j = 2 , size ( l2_x ) associate ( & x1 => l1_x ( i - 1 ), x2 => l1_x ( i ), & x3 => l2_x ( j - 1 ), x4 => l2_x ( j ), & y1 => l1_y ( i - 1 ), y2 => l1_y ( i ), & y3 => l2_y ( j - 1 ), y4 => l2_y ( j )) call intersects ( x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4 , s , t ) if ( 0 <= s . and . s <= 1 . and . 0 <= t . and . t <= 1 ) then x = s * ( x2 - x1 ) + x1 y = s * ( y2 - y1 ) + y1 if ( & abs (( x - xold )) > 1e-2_pr . and . abs (( y - yold )) > 1e-2_pr & ) then xold = x yold = y intersections = [ intersections , point ( x , y , i , j )] exit line2 end if end if end associate end do line2 end do line1 if ( size ( intersections ) > 3 ) then deallocate ( intersections ) allocate ( intersections ( 0 )) end if end function function intersect_one_line ( lx , ly ) result ( intersections ) real ( pr ), intent ( in ) :: lx (:), ly (:) type ( point ), allocatable :: intersections (:) real ( pr ) :: s , t integer :: i , j real ( pr ) :: x , y , xold = 9999 , yold = 9999 allocate ( intersections ( 0 )) line1 : do i = 2 , size ( lx ) - 1 line2 : do j = i + 2 , size ( lx ) associate ( & x1 => lx ( i - 1 ), x2 => lx ( i ), & x3 => lx ( j ), x4 => lx ( j - 1 ), & y1 => ly ( i - 1 ), y2 => ly ( i ), & y3 => ly ( j ), y4 => ly ( j - 1 )) call intersects ( x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4 , s , t ) if ( 0 <= s . and . s <= 1 . and . 0 <= t . and . t <= 1 ) then x = s * ( x2 - x1 ) + x1 y = s * ( y2 - y1 ) + y1 if ( abs ( x - xold ) > 1 . and . abs ( y - yold ) > 1 ) then xold = x yold = y ! Use earliest point for the \"other\" line intersections = [ intersections , point ( x , y , i , j - 1 )] end if end if end associate end do line2 end do line1 end function subroutine intersects ( x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4 , s , t ) real ( pr ), intent ( in ) :: x1 , x2 , x3 , x4 , y1 , y2 , y3 , y4 real ( pr ), intent ( out ) :: s , t real ( pr ) :: A ( 2 , 2 ), b ( 2 ), tmp A ( 1 , :) = [ x2 - x1 , x3 - x4 ] A ( 2 , :) = [ y2 - y1 , y3 - y4 ] b = [ x3 - x1 , y3 - y1 ] b = solve_system ( a , b ) s = b ( 1 ) t = b ( 2 ) end subroutine elemental function interpol ( x1 , x2 , y1 , y2 , x_obj ) result ( y ) !! Linear interpolation. !! !! Calculates the linear interpolation between two points at a desired !! x value with the equation: !!  !!    y = \\frac{y_2 - y_1}{x_2 - x_1} \\cdot (x_{obj})  - x_1 + y_1 !!  !! !! Since this function is defined as `elemental` it will also interpolate !! a set of vectors. !! !! Examples of usage: !! !! ```fortran !! x1 = 2 !! x2 = 5 !! y1 = 2 !! y2 = 9 !! y = interpol(x1, x2, y1, y2, 2.3) !! ``` !! !! ```fortran !! x1 = 2 !! x2 = 5 !! y1 = [2, 6] !! y2 = [9, 15] !! y = interpol(x1, x2, y1, y2, 2.3) !! ``` real ( pr ), intent ( in ) :: x1 !! First point x value real ( pr ), intent ( in ) :: x2 !! Second point x value real ( pr ), intent ( in ) :: y1 !! First point y value real ( pr ), intent ( in ) :: y2 !! Second point y value real ( pr ), intent ( in ) :: x_obj !! Desired x value to interpolate real ( pr ) :: y !! y value at `x_obj` y = ( y2 - y1 ) / ( x2 - x1 ) * ( x_obj - x1 ) + y1 end function subroutine full_newton ( fun , iters , X , ns , S , max_iters , F , dF ) !! Subroutine to solve a point in the envelope. !! !! Procedure that solves a point with the Newton-Raphson method. use constants , only : ouput_path use minpack_module , only : dpmpar , hybrj1 interface subroutine fun ( X , ns , S , F , dF ) !! Function to solve import pr real ( pr ), intent ( in ) :: X (:) integer , intent ( in ) :: ns real ( pr ), intent ( in ) :: S real ( pr ), intent ( out ) :: F ( size ( X )) real ( pr ), intent ( out ) :: dF ( size ( X ), size ( X )) end subroutine end interface !&< integer , intent ( out ) :: iters !! Number of iterations needed real ( pr ), intent ( in out ) :: X (:) !! Variables vector integer , intent ( in ) :: ns !! Number of specification real ( pr ), intent ( in ) :: S !! Specification value integer , intent ( in ) :: max_iters !! Maximum iterations real ( pr ), intent ( out ) :: F ( size ( X )) !! Function values at solved point real ( pr ), intent ( out ) :: df ( size ( X ), size ( X )) !! Jacobian values !&> real ( pr ) :: b ( size ( X )), A ( size ( X ), size ( X )) real ( pr ) :: dX ( size ( X )), tol = 1e-6 integer :: n , ldfjac , info , lwa , funit real ( pr ) :: fvec ( size ( x )), fjac ( size ( x ), size ( x )) real ( pr ), allocatable :: wa (:) n = size ( X ) ! ldfjac = n ! lwa = (n*(n+13))/2 ! allocate(wa(lwa)) ! call hybrj1(fcn, n, x, Fvec, Fjac, Ldfjac, Tol, Info, Wa, Lwa) ! f = fvec ! df = fjac ! iters = 3 ! if (info == 4) iters = max_iters+1 dX = 20 ! open(newunit=funit, file=\"fenvelopes_output/newton\") ! write(funit, *) n b = 500 newton : do iters = 1 , max_iters if ( maxval ( abs ( dx / x )) < tol . or . maxval ( abs ( b )) < tol ) exit newton call fun ( X , ns , S , b , a ) b = - b if ( any ( isnan ( b ))) dx = dx / maxval ( abs ( dx )) dX = solve_system ( A , b ) do while ( maxval ( abs ( dx )) > 0.5 ) dX = dX / 10 end do ! write(funit, *) x, dx, -b X = X + dX end do newton F = - b dF = A ! close(funit) contains subroutine fcn ( n , x , fvec , fjac , ldfjac , iflag ) integer , intent ( in ) :: N real ( pr ), intent ( in ) :: x ( n ) real ( pr ), intent ( inout ) :: fvec ( n ) real ( pr ), intent ( inout ) :: fjac ( ldfjac , n ) integer , intent ( in ) :: ldfjac integer , intent ( inout ) :: iflag call fun ( X , ns , S , fvec , fjac ) end subroutine end subroutine end module linalg","tags":"","loc":"sourcefile/linalg.f90.html"},{"title":"types.f90 – fenvelopes","text":"This file depends on sourcefile~~types.f90~~EfferentGraph sourcefile~types.f90 types.f90 sourcefile~constants.f90 constants.f90 sourcefile~types.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~types.f90~~AfferentGraph sourcefile~types.f90 types.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~envelopes.f90->sourcefile~types.f90 sourcefile~mod_dsp_lines.f90 mod_dsp_lines.f90 sourcefile~mod_dsp_lines.f90->sourcefile~types.f90 sourcefile~mod_inj_envelopes.f90 mod_inj_envelopes.f90 sourcefile~mod_dsp_lines.f90->sourcefile~mod_inj_envelopes.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~types.f90 sourcefile~main.f90->sourcefile~envelopes.f90 sourcefile~main.f90->sourcefile~mod_dsp_lines.f90 sourcefile~main.f90->sourcefile~mod_inj_envelopes.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~types.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~envelopes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules dtypes Source Code types.f90 Source Code module dtypes use constants , only : pr use io implicit none private public :: AbsEnvel public :: envelope public :: env3 public :: print_header public :: critical_point type , abstract :: AbsEnvel end type type :: critical_point real ( pr ) :: t real ( pr ) :: p real ( pr ) :: alpha end type critical_point type :: envelope real ( pr ), allocatable :: vars (:, :) !! Value of the set of variables at each point real ( pr ), allocatable :: z (:) !! Global composition real ( pr ), allocatable :: t (:) !! Temperature points real ( pr ), allocatable :: p (:) !! Pressure points real ( pr ), allocatable :: logk (:, :) !! ln(K) for each point real ( pr ), allocatable :: logphi (:, :) !! lnphi for each point type ( critical_point ), allocatable :: critical_points (:) !! Critical points contains procedure :: write => write_envel_2 end type envelope type , extends ( envelope ) :: env3 real ( pr ), allocatable :: beta (:) !! Other phase fraction real ( pr ), allocatable :: x (:, :) !! real ( pr ), allocatable :: y (:, :) !! real ( pr ), allocatable :: w (:, :) !! real ( pr ), allocatable :: logks (:, :) !! ln(Ks) type ( critical_point ), allocatable :: ll_critical_points (:) contains procedure :: write => write_envel_3 end type env3 contains subroutine write_critical_points ( self , file_name ) type ( critical_point ), intent ( in ) :: self (:) character ( len =* ), optional , intent ( in ) :: file_name !! Ouptut file name character ( len = :), allocatable :: filename integer :: file_unit integer :: i if ( present ( file_name )) then filename = file_name else filename = \"CP\" end if open ( newunit = file_unit , file = filename ) write ( file_unit , \"(A)\" ) \"P            T\" do i = 1 , size ( self ) write ( file_unit , \"(2(E10.5,2x))\" ) self ( i )% t , self ( i )% p end do close ( file_unit ) end subroutine subroutine write_envel_2 ( self , file_name ) class ( envelope ), intent ( in ) :: self character ( len =* ), optional , intent ( in ) :: file_name !! Ouptut file name character ( len = :), allocatable :: filename integer :: i , n , file_unit , n_components if ( present ( file_name )) then filename = file_name else filename = \"envelout-2phase\" end if n = size ( self % t ) n_components = size ( self % z ) associate ( t => self % t , p => self % p , & logk => self % logk , & z => self % z & ) open ( newunit = file_unit , file = filename ) write ( file_unit , * ) & \"P \" , \"T \" , ( \"K\" // str ( i ), i = 1 , n_components ), & ( \"z\" // str ( i ), i = 1 , n_components ) do i = 1 , n write ( file_unit , * ) p ( i ), t ( i ), logk ( i , :), z end do close ( file_unit ) end associate ! Write Critical Points file ! filename = filename // \"-CP\" ! call write_critical_points(self%critical_points, filename) deallocate ( filename ) end subroutine write_envel_2 subroutine write_envel_3 ( self , file_name ) class ( env3 ), intent ( in ) :: self character ( len =* ), optional , intent ( in ) :: file_name character ( len = :), allocatable :: filename integer :: i , n , file_unit , n_components if ( present ( file_name )) then filename = file_name else filename = \"envelout-3phase\" end if n_components = size ( self % z ) associate ( t => self % t , p => self % p , & logk => self % logk , logks => self % logks , & x => self % x , y => self % y , w => self % w , beta => self % beta & ) n = size ( self % t ) open ( newunit = file_unit , file = filename ) write ( file_unit , * ) & \"P \" , \"T \" , \"beta \" , & ( \"K\" // str ( i ), i = 1 , n_components ), & ( \"KS\" // str ( i ), i = 1 , n_components ), & ( \"x\" // str ( i ), i = 1 , n_components ), & ( \"y\" // str ( i ), i = 1 , n_components ), & ( \"w\" // str ( i ), i = 1 , n_components ) do i = 1 , n write ( file_unit , * ) p ( i ), t ( i ), beta ( i ), logk ( i , :), logks ( i , :), x ( i , :), y ( i , :), w ( i , :) end do close ( file_unit ) end associate ! Write Critical Points file filename = filename // \"-CP\" call write_critical_points ( self % critical_points , filename ) deallocate ( filename ) end subroutine write_envel_3 subroutine print_header ( name ) character ( len = 250 ), intent ( in ) :: name print * , \"===================================\" print * , \"!\" , name print * , \"-----------------------------------\" end subroutine print_header end module dtypes","tags":"","loc":"sourcefile/types.f90.html"},{"title":"optim.f90 – fenvelopes","text":"Files dependent on this one sourcefile~~optim.f90~~AfferentGraph sourcefile~optim.f90 optim.f90 sourcefile~mod_inj_envelopes.f90 mod_inj_envelopes.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~optim.f90 sourcefile~mod_dsp_lines.f90 mod_dsp_lines.f90 sourcefile~mod_dsp_lines.f90->sourcefile~mod_inj_envelopes.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_inj_envelopes.f90 sourcefile~main.f90->sourcefile~mod_dsp_lines.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules nelder_mead optimization Source Code optim.f90 Source Code module nelder_mead contains subroutine nelmin ( fn , n , start , xmin , ynewlo , reqmin , step , konvge , kcount , & icount , numres , ifault ) !*****************************************************************************80 ! !! nelmin() minimizes a function using the Nelder-Mead algorithm. ! !  Discussion: ! !    This routine seeks the minimum value of a user-specified function. ! !    Simplex function minimisation procedure due to Nelder and Mead (1965), !    as implemented by O'Neill(1971, Appl.Statist. 20, 338-45), with !    subsequent comments by Chambers+Ertel(1974, 23, 250-1), Benyon(1976, !    25, 97) and Hill(1978, 27, 380-2) ! !    The function to be minimized must be defined by a function of !    the form ! !      function fn ( x, f ) !      real ( kind = rk ) fn !      real ( kind = rk ) x(*) ! !    and the name of this subroutine must be declared EXTERNAL in the !    calling routine and passed as the argument FN. ! !    This routine does not include a termination test using the !    fitting of a quadratic surface. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    27 August 2021 ! !  Author: ! !    Original FORTRAN77 version by R ONeill. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    John Nelder, Roger Mead, !    A simplex method for function minimization, !    Computer Journal, !    Volume 7, 1965, pages 308-313. ! !    R ONeill, !    Algorithm AS 47: !    Function Minimization Using a Simplex Procedure, !    Applied Statistics, !    Volume 20, Number 3, 1971, pages 338-345. ! !  Input: ! !    external FN, the name of the function which evaluates !    the function to be minimized. ! !    integer N, the number of variables. !    0 < N is required. ! !    real ( kind = rk ) START(N).  On a starting point for the iteration. ! !    real ( kind = rk ) REQMIN, the terminating limit for the variance !    of the function values.  0 < REQMIN is required. ! !    real ( kind = rk ) STEP(N), determines the size and shape of the !    initial simplex.  The relative magnitudes of its elements should reflect !    the units of the variables. ! !    integer KONVGE, the convergence check is carried out !    every KONVGE iterations. 0 < KONVGE is required. ! !    integer KCOUNT, the maximum number of function !    evaluations. ! !  Output: ! !    real ( kind = rk ) START(N).  This data may have been overwritten. ! !    real ( kind = rk ) XMIN(N), the coordinates of the point which !    is estimated to minimize the function. ! !    real ( kind = rk ) YNEWLO, the minimum value of the function. ! !    integer ICOUNT, the number of function evaluations !    used. ! !    integer NUMRES, the number of restarts. ! !    integer IFAULT, error indicator. !    0, no errors detected. !    1, REQMIN, N, or KONVGE has an illegal value. !    2, iteration terminated because KCOUNT was exceeded without convergence. ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer n real ( kind = rk ), parameter :: ccoeff = 0.5D+00 real ( kind = rk ) del real ( kind = rk ), parameter :: ecoeff = 2.0D+00 real ( kind = rk ), parameter :: eps = 0.001D+00 interface function fn ( x ) import rk real ( rk ) :: x (:) real ( rk ) :: fn end function end interface integer i integer icount integer ifault integer ihi integer ilo integer j integer jcount integer kcount integer konvge integer l integer numres real ( kind = rk ) p ( n , n + 1 ) real ( kind = rk ) p2star ( n ) real ( kind = rk ) pbar ( n ) real ( kind = rk ) pstar ( n ) real ( kind = rk ), parameter :: rcoeff = 1.0D+00 real ( kind = rk ) reqmin real ( kind = rk ) rq real ( kind = rk ) start ( n ) real ( kind = rk ) step ( n ) real ( kind = rk ) x real ( kind = rk ) xmin ( n ) real ( kind = rk ) y ( n + 1 ) real ( kind = rk ) y2star real ( kind = rk ) ylo real ( kind = rk ) ynewlo real ( kind = rk ) ystar real ( kind = rk ) z ! !  Check the input parameters. ! if ( reqmin <= 0.0D+00 ) then ifault = 1 return end if if ( n < 1 ) then ifault = 1 return end if if ( konvge < 1 ) then ifault = 1 return end if ! !  Initialization. ! icount = 0 numres = 0 jcount = konvge del = 1.0D+00 rq = reqmin * real ( n , kind = rk ) ! !  Initial or restarted loop. ! do p ( 1 : n , n + 1 ) = start ( 1 : n ) y ( n + 1 ) = fn ( start ) icount = icount + 1 ! !  Define the initial simplex. ! do j = 1 , n x = start ( j ) start ( j ) = start ( j ) + step ( j ) * del p ( 1 : n , j ) = start ( 1 : n ) y ( j ) = fn ( start ) icount = icount + 1 start ( j ) = x end do ! !  Find highest and lowest Y values.  YNEWLO = Y(IHI) indicates !  the vertex of the simplex to be replaced. ! ilo = minloc ( y ( 1 : n + 1 ), 1 ) ylo = y ( ilo ) ! !  Inner loop. ! do while ( icount < kcount ) ! !  YNEWLO is, of course, the HIGHEST value??? ! ihi = maxloc ( y ( 1 : n + 1 ), 1 ) ynewlo = y ( ihi ) ! !  Calculate PBAR, the centroid of the simplex vertices !  excepting the vertex with Y value YNEWLO. ! do i = 1 , n pbar ( i ) = ( sum ( p ( i , 1 : n + 1 )) - p ( i , ihi )) / real ( n , kind = rk ) end do ! !  Reflection through the centroid. ! pstar ( 1 : n ) = pbar ( 1 : n ) + rcoeff * ( pbar ( 1 : n ) - p ( 1 : n , ihi )) ystar = fn ( pstar ) icount = icount + 1 ! !  Successful reflection, so extension. ! if ( ystar < ylo ) then p2star ( 1 : n ) = pbar ( 1 : n ) + ecoeff * ( pstar ( 1 : n ) - pbar ( 1 : n )) y2star = fn ( p2star ) icount = icount + 1 ! !  Retain extension or contraction. ! if ( ystar < y2star ) then p ( 1 : n , ihi ) = pstar ( 1 : n ) y ( ihi ) = ystar else p ( 1 : n , ihi ) = p2star ( 1 : n ) y ( ihi ) = y2star end if ! !  No extension. ! else l = 0 do i = 1 , n + 1 if ( ystar < y ( i )) then l = l + 1 end if end do if ( 1 < l ) then p ( 1 : n , ihi ) = pstar ( 1 : n ) y ( ihi ) = ystar ! !  Contraction on the Y(IHI) side of the centroid. ! else if ( l == 0 ) then p2star ( 1 : n ) = pbar ( 1 : n ) + ccoeff * ( p ( 1 : n , ihi ) - pbar ( 1 : n )) y2star = fn ( p2star ) icount = icount + 1 ! !  Contract the whole simplex. ! if ( y ( ihi ) < y2star ) then do j = 1 , n + 1 p ( 1 : n , j ) = ( p ( 1 : n , j ) + p ( 1 : n , ilo )) * 0.5D+00 xmin ( 1 : n ) = p ( 1 : n , j ) y ( j ) = fn ( xmin ) icount = icount + 1 end do ilo = minloc ( y ( 1 : n + 1 ), 1 ) ylo = y ( ilo ) cycle ! !  Retain contraction. ! else p ( 1 : n , ihi ) = p2star ( 1 : n ) y ( ihi ) = y2star end if ! !  Contraction on the reflection side of the centroid. ! else if ( l == 1 ) then p2star ( 1 : n ) = pbar ( 1 : n ) + ccoeff * ( pstar ( 1 : n ) - pbar ( 1 : n )) y2star = fn ( p2star ) icount = icount + 1 ! !  Retain reflection? ! if ( y2star <= ystar ) then p ( 1 : n , ihi ) = p2star ( 1 : n ) y ( ihi ) = y2star else p ( 1 : n , ihi ) = pstar ( 1 : n ) y ( ihi ) = ystar end if end if end if ! !  Check if YLO improved. ! if ( y ( ihi ) < ylo ) then ylo = y ( ihi ) ilo = ihi end if jcount = jcount - 1 if ( 0 < jcount ) then cycle end if ! !  Check to see if minimum reached. ! if ( icount <= kcount ) then jcount = konvge x = sum ( y ( 1 : n + 1 )) / real ( n + 1 , kind = rk ) z = sum (( y ( 1 : n + 1 ) - x ) ** 2 ) if ( z <= rq ) then exit end if end if end do ! !  Factorial tests to check that YNEWLO is a local minimum. ! xmin ( 1 : n ) = p ( 1 : n , ilo ) ynewlo = y ( ilo ) if ( kcount < icount ) then ifault = 2 exit end if ifault = 0 do i = 1 , n del = step ( i ) * eps xmin ( i ) = xmin ( i ) + del z = fn ( xmin ) icount = icount + 1 if ( z < ynewlo ) then ifault = 2 exit end if xmin ( i ) = xmin ( i ) - del - del z = fn ( xmin ) icount = icount + 1 if ( z < ynewlo ) then ifault = 2 exit end if xmin ( i ) = xmin ( i ) + del end do if ( ifault == 0 ) then exit end if ! !  Restart the procedure. ! start ( 1 : n ) = xmin ( 1 : n ) del = eps numres = numres + 1 end do return end end module module optimization use nelder_mead , only : nelmin integer :: konvge = 100 , kcount = 1e5 integer :: icount , numres , ifault integer :: funit_settings integer :: iostat contains subroutine nm_opt ( f , xguess , stat , step ) implicit none interface function f ( x ) real ( 8 ) :: x (:) real ( 8 ) :: f end function end interface real ( 8 ), intent ( in out ) :: xguess (:) integer :: n integer :: stat real ( 8 ) :: start ( size ( xguess )), xmin ( size ( xguess )), ynewlo , reqmin , step ( size ( xguess )) n = size ( xguess ) reqmin = 1e-8 start = xguess call nelmin ( f , n , start , xmin , ynewlo , reqmin , step , konvge , kcount , icount , numres , ifault ) xguess = xmin stat = ifault end subroutine end module","tags":"","loc":"sourcefile/optim.f90.html"},{"title":"envelopes.f90 – fenvelopes","text":"This file depends on sourcefile~~envelopes.f90~~EfferentGraph sourcefile~envelopes.f90 envelopes.f90 sourcefile~constants.f90 constants.f90 sourcefile~envelopes.f90->sourcefile~constants.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~envelopes.f90->sourcefile~linalg.f90 sourcefile~types.f90 types.f90 sourcefile~envelopes.f90->sourcefile~types.f90 sourcefile~linalg.f90->sourcefile~constants.f90 sourcefile~types.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~envelopes.f90~~AfferentGraph sourcefile~envelopes.f90 envelopes.f90 sourcefile~mod_inj_envelopes.f90 mod_inj_envelopes.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~envelopes.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~envelopes.f90 sourcefile~main.f90->sourcefile~mod_inj_envelopes.f90 sourcefile~mod_dsp_lines.f90 mod_dsp_lines.f90 sourcefile~main.f90->sourcefile~mod_dsp_lines.f90 sourcefile~mod_dsp_lines.f90->sourcefile~mod_inj_envelopes.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules envelopes Source Code envelopes.f90 Source Code module envelopes !! Functions to be used in the different continuation methods to trace !! phase envelopes use constants , only : pr use linalg , only : solve_system , full_newton use dtypes , only : AbsEnvel , envelope , critical_point use legacy_ar_models , only : nc , termo use progress_bar_module , only : progress_bar implicit none type , extends ( AbsEnvel ) :: PTEnvel3 integer :: n real ( pr ), allocatable :: lnKx (:, :) real ( pr ), allocatable :: lnKy (:, :) real ( pr ), allocatable :: T (:) real ( pr ), allocatable :: P (:) real ( pr ), allocatable :: beta (:) type ( critical_point ), allocatable :: critical_points (:) end type integer , parameter :: max_points = 2000 integer , parameter :: max_iters = 100 integer :: env_number = 0 interface function F ( X , ns , S ) import pr real ( pr ), intent ( in ) :: X (:) integer , intent ( in ) :: ns real ( pr ), intent ( in ) :: S real ( pr ) :: F end function end interface contains ! =========================================================================== !  Initializators ! --------------------------------------------------------------------------- subroutine k_wilson_bubble ( z , t_0 , p_end , t , p , k ) !! Find the Wilson Kfactors at ~10 bar to initialize a bubble point use legacy_ar_models , only : pc , tc , w real ( pr ), intent ( in ) :: z (:) real ( pr ), intent ( in ) :: t_0 real ( pr ), intent ( in ) :: p_end real ( pr ), intent ( in out ) :: p real ( pr ), intent ( in out ) :: t real ( pr ), intent ( out ) :: k ( size ( z )) P = 10 0.0 T = t_0 do while ( P > p_end ) T = T - 5._pr P = 1.0_pr / sum ( z * pc * exp ( 5.373_pr * ( 1 + w ) * ( 1 - tc / T ))) end do k = k_wilson ( t , p ) end subroutine function k_wilson ( t , p ) result ( k ) ! use system, only: pc, tc, w use legacy_ar_models , only : pc , tc , w real ( pr ), intent ( in ) :: t , p real ( pr ) :: k ( size ( pc )) k = pc * exp ( 5.373_pr * ( 1.0_pr + w ) * ( 1.0_pr - tc / t )) / p end function function p_wilson ( z , t ) result ( p ) ! use system, only: pc, tc, w use legacy_ar_models , only : pc , tc , w real ( pr ), intent ( in ) :: t , z (:) real ( pr ) :: p P = 1.0_pr / sum ( z * pc * exp ( 5.373_pr * ( 1 + w ) * ( 1 - tc / T ))) end function ! =========================================================================== ! =========================================================================== ! General routines ! --------------------------------------------------------------------------- subroutine update_specification ( iter , passingcri , X , dF , ns , S , delS , dXdS ) integer , intent ( in ) :: iter logical , intent ( in ) :: passingcri real ( pr ), intent ( in ) :: X ( nc + 2 ) real ( pr ), intent ( in ) :: dF ( nc + 2 , nc + 2 ) integer , intent ( in out ) :: ns real ( pr ), intent ( in out ) :: S real ( pr ), intent ( in out ) :: delS real ( pr ), intent ( in out ) :: dXdS ( nc + 2 ) real ( pr ) :: dF_dS ( nc + 2 ) real ( pr ) :: bd ( nc + 2 ) real ( pr ) :: AJ ( nc + 2 , nc + 2 ) real ( pr ) :: delmax , updel integer :: nsold dF_dS = 0 call dFdS ( dF_dS ) bd = - dF_dS AJ = dF dXdS = solve_system ( AJ , bd ) ! Selection of (the most changing) variable to be specified for the next point nsold = ns ns = maxloc ( abs ( dXdS ), dim = 1 ) if ( maxval ( abs ( X (: nc ))) < 0.2 ) then ns = maxloc ( abs ( dXdS (: nc )), dim = 1 ) ! T and P not allowed to be chosen close to a critical point end if if ( ns /= nsold ) then delS = dXdS ( ns ) * delS ! translation of delS to the  new specification variable dXdS = dXdS / dXdS ( ns ) ! translation of sensitivities S = X ( ns ) ! update of S end if ! Setting step in S for the next point to be calculated delmax = max ( sqrt ( abs ( X ( ns ))) / 10 , 0.1 ) updel = delS * 3 / iter if ( passingcri ) updel = delS if ( delS > 0 ) then delS = min ( updel , delmax ) else delS = max ( updel , - delmax ) end if delS = 5 * delS S = S + delS end subroutine ! =========================================================================== ! =========================================================================== ! Specification function derivatives ! --------------------------------------------------------------------------- subroutine dFdS ( dF_dS ) ! use system, only: nc use legacy_ar_models , only : nc real ( pr ), intent ( out ) :: dF_dS ( nc + 2 ) dF_dS = 0 dF_dS ( nc + 2 ) = - 1 end subroutine ! --------------------------------------------------------------------------- ! =========================================================================== ! Two Phase envelopes ! --------------------------------------------------------------------------- function X2 ( kfact , P , T ) result ( X ) real ( pr ), intent ( in ) :: kfact ( nc ) real ( pr ), intent ( in ) :: P real ( pr ), intent ( in ) :: T real ( pr ) :: X ( nc + 2 ) integer :: n n = size ( kfact ) X (: n ) = log ( kfact ) X ( n + 1 ) = log ( T ) X ( n + 2 ) = log ( P ) end function subroutine F2 ( incipient , z , y , X , S , ns , F , dF ) character ( len =* ), intent ( in ) :: incipient real ( pr ), intent ( in ) :: z (:) real ( pr ), intent ( in ) :: X ( nc + 2 ) real ( pr ), intent ( in ) :: y ( nc ) real ( pr ), intent ( in ) :: S integer , intent ( in ) :: ns real ( pr ), intent ( out ) :: F ( nc + 2 ) real ( pr ), intent ( out ) :: dF ( nc + 2 , nc + 2 ) real ( pr ) :: Vx , Vy , lnfug_x ( nc ), lnfug_y ( nc ) real ( pr ) :: dlnphi_dt_x ( nc ), dlnphi_dt_y ( nc ) real ( pr ) :: dlnphi_dp_x ( nc ), dlnphi_dp_y ( nc ) real ( pr ) :: dlnphi_dn_x ( nc , nc ), dlnphi_dn_y ( nc , nc ) real ( pr ) :: T , P integer :: ix , iy , n , j n = size ( z ) F = 0 dF = 0 T = exp ( X ( n + 1 )) P = exp ( X ( n + 2 )) select case ( incipient ) case ( \"liquid\" ) ix = - 1 iy = 1 case ( \"vapor\" ) ix = 1 iy = - 1 case ( \"2ndliquid\" ) ix = 1 iy = 1 case default ix = 0 iy = 0 end select call TERMO ( n , iy , 4 , T , P , y , Vy , lnfug_y , dlnphi_dp_y , dlnphi_dt_y , dlnphi_dn_y ) call TERMO ( n , ix , 2 , T , P , z , Vx , lnfug_x , dlnphi_dp_x , dlnphi_dt_x , dlnphi_dn_x ) F (: n ) = X (: n ) + lnfug_y - lnfug_x ! X(:n) are LOG_K F ( n + 1 ) = sum ( y - z ) F ( n + 2 ) = X ( ns ) - S ! Jacobian Matrix do j = 1 , n df (: n , j ) = dlnphi_dn_y (:, j ) * y ( j ) df ( j , j ) = dF ( j , j ) + 1 end do df (: n , n + 1 ) = T * ( dlnphi_dt_y - dlnphi_dt_x ) df (: n , n + 2 ) = P * ( dlnphi_dp_y - dlnphi_dp_x ) df ( n + 1 , : n ) = y df ( n + 2 , :) = 0 df ( n + 2 , ns ) = 1 end subroutine F2 subroutine fix_delx (& point , iterations , desired_iterations , first_tol , tol , delX & ) integer , intent ( in ) :: point integer , intent ( in ) :: iterations integer , intent ( in ) :: desired_iterations real ( pr ), intent ( in ) :: first_tol real ( pr ), intent ( in ) :: tol real ( pr ), intent ( in out ) :: delX (:) if ( point == 1 ) then do while ( maxval ( abs ( delX )) > first_tol ) ! Too large Newton step --> Reduce it delX = delX / 2 end do else do while ( maxval ( abs ( delX )) > tol ) ! Too large Newton step --> Reduce it delX = delX / 2 end do if ( iterations > desired_iterations ) then ! too many iterations (sometimes due to oscillatory behavior ! near critical point) --> Reduce it delX = delX / 2 endif end if end subroutine subroutine find_hpl ( t , p , k ) !! Find a HPLL initial point at a given pressure use legacy_ar_models , only : nc , termo , z real ( pr ), intent ( in out ) :: t real ( pr ), intent ( in ) :: p real ( pr ), intent ( out ) :: k ( nc ) integer :: i , ncomp real ( pr ) :: diff real ( pr ) :: v real ( pr ) :: x ( nc ), y ( nc ), lnfug_z ( nc ), lnfug_y ( nc ) diff = - 1 ncomp = nc y = 0 y ( ncomp ) = 1 do while ( diff < 0 ) t = t - 1.0_pr call termo ( nc , 4 , 1 , t , p , z , v , philog = lnfug_z ) call termo ( nc , 4 , 1 , t , p , y , v , philog = lnfug_y ) diff = ( log ( z ( ncomp )) + lnfug_z ( ncomp )) - ( log ( y ( ncomp )) + lnfug_y ( ncomp )) end do k = exp ( lnfug_y - lnfug_z ) end subroutine subroutine envelope2 ( ichoice , n , z , T , P , KFACT , & ! This will probably always exist n_points , Tv , Pv , Dv , ncri , icri , Tcri , Pcri , Dcri , & ! This shouldnt be here in the future this_envelope ) ! This output should encapsulate everything use dtypes , only : envelope , critical_point use linalg , only : point , solve_system use constants , only : ouput_path use io , only : str implicit none ! number of compounds in the system and starting point type integer , intent ( in ) :: n , ichoice ! estimated T and P for first point (then used for every point) real ( pr ) :: T , P ! Maximun pressure real ( pr ) :: maxP ! estimated K factors for first point (then used for every point) real ( pr ), intent ( in out ) :: KFACT ( n ) ! composition of the system real ( pr ), intent ( in ) :: z ( n ) ! T, P and Density of the calculated envelope real ( pr ), intent ( out ) :: Tv ( max_points ) real ( pr ), intent ( out ) :: Pv ( max_points ) real ( pr ), intent ( out ) :: Dv ( max_points ) ! number of valid elements in Tv, Pv and Dv arrays integer , intent ( out ) :: n_points ! positions of the last saturation points before each critical point integer , dimension ( 4 ), intent ( out ) :: icri ! T, P and Density of critical points real ( pr ), dimension ( 4 ), intent ( out ) :: Tcri ( 4 ), Pcri ( 4 ), Dcri ( 4 ) ! number of valid elements in icri, Tcri, Pcri and Dcri arrays integer , intent ( out ) :: ncri ! Intermediate variables during calculation process real ( pr ), dimension ( n ) :: y real ( pr ), dimension ( n + 2 ) :: X , Xold , Xold2 , delX , bd , F , dFdS , dXdS real ( pr ), dimension ( n + 2 , n + 2 ) :: JAC , AJ real ( pr ) :: Vx logical :: run , passingcri , minT , minmaxT character ( len = :), allocatable :: incipient_phase type ( envelope ), intent ( out ) :: this_envelope real ( pr ) :: tmp_logk ( max_points , n ) real ( pr ) :: tmp_logphi ( max_points , n ) ! Extrapolation of variables to detect critical points real ( pr ) :: extra_slope ( n + 2 ) real ( pr ) :: lnK_extrapolated ( n ) real ( pr ) :: delta_t integer :: i integer :: iy , ix ! Vapor or liquid selectors ! Specification value, delta and index real ( pr ) :: S , delS integer :: ns real ( pr ) :: Told2 , Told real ( pr ) :: frac ! Netwon method integer :: iter ! Iteration integer :: max_iter ! Critical Points type ( critical_point ), allocatable :: critical_points (:) integer :: black_i ! Number of steps while trying to escape the CP real ( pr ) :: stepx integer :: funit_output character ( len = 254 ) :: fname_env ! ======================================================================== !  OUTPUT file ! ------------------------------------------------------------------------ env_number = env_number + 1 write ( fname_env , * ) env_number fname_env = \"env-2ph-PT\" // \"_\" // trim ( adjustl ( fname_env )) fname_env = trim ( adjustl ( ouput_path )) // trim ( fname_env ) // \".dat\" open ( newunit = funit_output , file = fname_env ) ! ======================================================================== ! Initialize with zero Tv and Pv allocate ( this_envelope % vars ( max_points - 50 , n + 2 )) Tv = 0 Pv = 0 minT = . false . minmaxT = . false . passingcri = . false . Told2 = 0.0 Told = 1 0.0 maxP = 0.d0 !----------------------------------------------------------- ! Continuation method for tracing the envelope starts here run = . true . i = 0 ncri = 0 JAC ( n + 1 , :) = 0.d0 X (: n ) = log ( KFACT ) X ( n + 1 ) = log ( T ) X ( n + 2 ) = log ( P ) iy = 1 ix = 1 select case ( ichoice ) case ( 1 ) incipient_phase = \"vapor\" iy = - 1 case ( 2 ) incipient_phase = \"liquid\" ix = - 1 case ( 3 ) incipient_phase = \"2ndliquid\" end select write ( funit_output , * ) \"#\" , incipient_phase write ( funit_output , \"(*(A,2x))\" ) \"STAT\" , \"iter\" , \"ns\" , \"T\" , \"P\" , & ( \"lnK\" // str ( i ), i = 1 , n ), ( \"y\" // str ( i ), i = 1 , n ) if ( ichoice <= 2 ) then ! low T bub (1) or dew (2) ! x will be vapor phase during the first part, ! and liquid after a critical point is crossed if ( ichoice == 1 ) iy = - 1 if ( ichoice == 2 ) ix = - 1 ns = n + 1 S = log ( T ) delS = 0.005 ! Wilson estimate for vapor (or liquid) composition y = KFACT * z else ! (ichoice==3) high P L-L sat ! PmaxDewC = maxval(PdewC(1:ilastDewC)) ns = n + 2 S = log ( P ) delS = - 0.05 y = kfact * z ! y = 0.d0 ! y(n) = 1.d0 end if Xold = 0.d0 dFdS = 0.d0 dFdS ( n + 2 ) = - 1.d0 i = 0 do while ( run ) i = i + 1 if ( i > max_points - 50 ) then exit end if ! Newton starts here delX = 1.0 iter = 0 max_iter = 500 do while ( maxval ( abs ( delX )) > 1.d-9 . and . iter <= max_iter ) ! Solve point with full Newton method call F2 ( incipient_phase , z , y , X , S , ns , F , JAC ) iter = iter + 1 bd = - F AJ = JAC delX = solve_system ( AJ , bd ) call fix_delX ( i , iter , 3 , 1 0.0_pr , 0.08_pr , delX ) X = X + delX if (. not . passingcri . and . i /= 1 & . and . iter > 10 & . and . maxval ( abs ( delX )) > 0.001 ) then ! Too many iterations --> Reduce step to new point delS = delS * 2.0 / 4.0 S = S - delS X = Xold + dXdS * delS end if KFACT = exp ( X (: n )) y = z * KFACT T = exp ( X ( n + 1 )) P = exp ( X ( n + 2 )) end do ! Point converged (unless it jumped out because of high number of iterations) if ( iter > max_iter ) run = . false . if ( P > maxP ) maxP = P if ( run ) write ( funit_output , * ) \"SOL\" , iter , ns , T , P , X (: n ), z * exp ( X (: n )) if ( incipient_phase == \"liquid\" . and . i > 1 ) then ! TODO: If this is the way the low p dew line finishes, ! I think this could be better, like using dPdT if ( P < Pv ( i - 1 ) . and . P < maxP / 5 . and . T > 300 ) then run = . true . ! to finish envelope going to low T bubble end if end if Tv ( i ) = T Pv ( i ) = P this_envelope % vars ( i , :) = X tmp_logk ( i , : n ) = X (: n ) if ( incipient_phase == \"2ndliquid\" . and . P < 0.1 ) then ! isolated LL line detected. ! Stop and start a new one from low T false bubble point run = . false . end if if ( i > max_points - 50 ) exit if ( sum ( X (: n ) * Xold (: n )) < 0 ) then ! critical point detected ncri = ncri + 1 icri ( ncri ) = i - 1 frac = - Xold ( ns ) / ( X ( ns ) - Xold ( ns )) Tcri ( ncri ) = Tv ( i - 1 ) + frac * ( T - Tv ( i - 1 )) Pcri ( ncri ) = Pv ( i - 1 ) + frac * ( P - Pv ( i - 1 )) Dcri ( ncri ) = Dv ( i - 1 ) + frac * ( Dv ( i ) - Dv ( i - 1 )) select case ( incipient_phase ) case ( \"liquid\" ) incipient_phase = \"vapor\" case ( \"vapor\" ) incipient_phase = \"liquid\" end select write ( funit_output , * ) \" \" write ( funit_output , * ) \" \" write ( funit_output , * ) \"#\" , incipient_phase end if if ( run ) then ! Calculation of sensitivities (dXdS) ! dgesv( n, nrhs, a, lda, ipiv, b, ldb, info ) call update_specification ( iter , passingcri , X , JAC , ns , S , delS , dXdS ) ! Generation of estimates for the next point Told2 = Told Told = T Xold2 = Xold Xold = X X = Xold + dXdS * delS critical_region : block black_i = 0 if ( passingcri ) passingcri = . false . if ( i > 10 ) then ! After the 10th step extrapolate the K factors in order ! to find a possible critical point (check if all lnK values ! change sign). extrapolation : block integer :: loc integer :: its real ( pr ) :: delta real ( pr ) :: m ( size ( X )) real ( pr ) :: max_lnK , max_lnK2 , delta_lnK real ( pr ) :: delta_X ( size ( x )) real ( pr ) :: Xin ( size ( X )) its = 0 delta = delS exit extrapolation ! Variation of lnK based on deltaS ! m = 37.0_pr * (X - Xold2)/(delta) ! lnK_extrapolated = (delta) * m(:n) + X(:n) lnK_extrapolated = X (: n ) + 4 * delS * dXdS if ( all (( X (: n ) * lnK_extrapolated < 0 ), dim = 1 )) then ! All lnK changed sign, so a CP is inminent ! aproach it enough to force the jumping algorithm do while ( & maxval ( abs ( X (: n ))) >= 0.03 & . and . all ( X (: n ) * lnK_extrapolated > 0 , dim = 1 )& ) print * , its , \"Getting to critical\" , & exp ( X ( n + 1 )), exp ( X ( n + 2 )), maxval ( abs ( X (: n ))), & all ( X (: n ) * lnK_extrapolated > 0 , dim = 1 ) its = its + 1 delta_x = delta * m X = delta_x + X S = X ( ns ) if ( its > 10 ) exit end do passingcri = . true . end if end block extrapolation end if do while ( maxval ( abs ( X (: n ))) < 0.03 ) ! print *, \"Jumping critical\" ! approaching the black hole... get out of there! (0.03) black_i = black_i + 1 if ( black_i > 50 ) then print * , \"Stuck on the black hole\" if ( black_i > 100 ) stop end if stepX = maxval ( abs ( X (: n ) - Xold (: n ))) ! the step given by the most changing logK to fall into ! the black hole S = S + delS X = X + dXdS * delS ! passingcri = .true. ! if (stepX > 0.07) then !    !  half step back !    S = S - delS/2 !    X = X - dXdS*delS/2 ! else !    ! one more step to jump over the critical point !    S = S + delS !    X = X + dXdS*delS ! end if end do end block critical_region T = exp ( X ( n + 1 )) do while (. not . passingcri . and . abs ( T - Told ) > 15 ) ! Delta T estimations > 7K are not allowed delS = delS / 2 S = S - delS X = Xold + dXdS * delS T = exp ( X ( n + 1 )) end do P = exp ( X ( n + 2 )) KFACT = exp ( X (: n )) y = z * KFACT ! Finish conditions if (( dXdS ( n + 1 ) * delS < 0 . and . P < 0.05 . and . T < 5 0.0 ) & ! dew line stops when P<0.1 bar or T<50K . or . ( P > 1.0 . and . T < 5 0.0 ) & ! bubble line stops when T<50K . or . ( P > 5000 ) & . or . ( abs ( dels ) < 1.d-10 )) then run = . false . end if end if end do !----------------------------------------------------------- n_points = i write ( funit_output , * ) \" \" write ( funit_output , * ) \" \" write ( funit_output , * ) \"#critical\" if ( ncri == 0 ) write ( funit_output , * ) \"NaN NaN\" do i = 1 , ncri write ( funit_output , * ) Tcri ( i ), Pcri ( i ) end do ! Define envelope values, omit the last point to avoid not really ! converged cases close ( funit_output ) this_envelope % logk = tmp_logk (: n_points - 1 , :) this_envelope % logphi = tmp_logphi (: n_points - 1 , :) this_envelope % t = Tv (: n_points - 1 ) this_envelope % p = Pv (: n_points - 1 ) this_envelope % z = z allocate ( critical_points ( ncri )) critical_points % t = tcri (: ncri ) critical_points % p = pcri (: ncri ) this_envelope % critical_points = critical_points end subroutine envelope2 ! =========================================================================== ! =========================================================================== ! Three-phase envelopes ! --------------------------------------------------------------------------- subroutine pt_F_three_phases ( Xvars , ns , S , F , dF ) !! Function to solve at each point of a three phase envelope. !! !! The vector of variables X corresponds to: !!  X = [lnKx_i, lnKy_i lnP, lnT, \\beta]  !! !! While the equations are: !! !!  F = [ !!        lnKx_i - ln \\phi_i(x, P, T) + ln \\phi_i(w, P, T), !!        lnKy_i - ln \\phi_i(y, P, T) + ln \\phi_i(w, P, T), !!        \\sum_{i=1}&#94;N (w_i) - 1, !!        \\sum_{i=1}&#94;N (x_i - y_i), !!        X_{ns} - S !! ]  use legacy_ar_models , only : TERMO , z use iso_fortran_env , only : error_unit real ( pr ), intent ( in ) :: Xvars (:) !! Vector of variables integer , intent ( in ) :: ns !! Number of specification real ( pr ), intent ( in ) :: S !! Specification value real ( pr ), intent ( out ) :: F ( size ( Xvars )) !! Vector of functions valuated real ( pr ), intent ( out ) :: df ( size ( Xvars ), size ( Xvars )) !! Jacobian matrix ! Xvars variables ! real(pr) :: z((Size(Xvars)-3)/2) real ( pr ) :: Kx (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: Ky (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: P real ( pr ) :: T real ( pr ) :: beta ! Main phase 1 variables real ( pr ) :: Vx real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 ) :: x , lnfug_x , dlnphi_dt_x , dlnphi_dp_x real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 , ( Size ( Xvars ) - 3 ) / 2 ) :: dlnphi_dn_x ! Main phase 2 variables real ( pr ) :: Vy real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 ) :: y , lnfug_y , dlnphi_dt_y , dlnphi_dp_y real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 , ( Size ( Xvars ) - 3 ) / 2 ) :: dlnphi_dn_y ! Incipient phase variables real ( pr ) :: Vw real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 ) :: w , lnfug_w , dlnphi_dt_w , dlnphi_dp_w real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 , ( Size ( Xvars ) - 3 ) / 2 ) :: dlnphi_dn_w ! Derivative of w wrt beta real ( pr ) :: dwdb (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: dwdKx (( Size ( Xvars ) - 3 ) / 2 ), dxdKx (( Size ( Xvars ) - 3 ) / 2 ), dydKx (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: dwdKy (( Size ( Xvars ) - 3 ) / 2 ), dxdKy (( Size ( Xvars ) - 3 ) / 2 ), dydKy (( Size ( Xvars ) - 3 ) / 2 ) integer :: i , j , n n = ( Size ( Xvars ) - 3 ) / 2 Kx = exp ( Xvars ( 1 : n )) Ky = exp ( Xvars ( n + 1 : 2 * n )) P = exp ( Xvars ( 2 * n + 1 )) T = exp ( Xvars ( 2 * n + 2 )) beta = Xvars ( 2 * n + 3 ) w = z / ( beta * Ky + ( 1 - beta ) * Kx ) x = w * Kx y = w * Ky call TERMO ( & n , 0 , 4 , T , P , x , Vx , lnfug_x , dlnphi_dp_x , dlnphi_dt_x , dlnphi_dn_x & ) call TERMO ( & n , 0 , 4 , T , P , y , Vy , lnfug_y , dlnphi_dp_y , dlnphi_dt_y , dlnphi_dn_y & ) call TERMO ( & n , 0 , 4 , T , P , w , Vw , lnfug_w , dlnphi_dp_w , dlnphi_dt_w , dlnphi_dn_w & ) F = 0 F ( 1 : n ) = Xvars ( 1 : n ) + lnfug_x - lnfug_w F ( n + 1 : 2 * n ) = Xvars ( n + 1 : 2 * n ) + lnfug_y - lnfug_w F ( 2 * n + 1 ) = sum ( w ) - 1 F ( 2 * n + 2 ) = sum ( x - y ) F ( 2 * n + 3 ) = Xvars ( ns ) - S df = 0 dwdb = z * ( Kx - Ky ) / (( 1 - beta ) * Kx + beta * Ky ) ** 2 dwdKx = - z * ( 1 - beta ) / ( Ky * beta + ( 1 - beta ) * Kx ) ** 2 dxdKx = Kx * dwdKx + w dydKx = Ky * dwdKx dwdKy = - z * ( beta ) / ( Ky * beta + ( 1 - beta ) * Kx ) ** 2 dxdKy = Kx * dwdKy dydKy = Ky * dwdKy + w do i = 1 , n do j = 1 , n df ( i , j ) = Kx ( j ) * ( dlnphi_dn_x ( i , j ) * dxdKx ( j ) & - dlnphi_dn_w ( i , j ) * dwdKx ( j )) df ( i + n , j ) = Kx ( j ) * ( dlnphi_dn_y ( i , j ) * dydKx ( j ) & - dlnphi_dn_w ( i , j ) * dwdKx ( j )) df ( i , j + n ) = Ky ( j ) * ( dlnphi_dn_x ( i , j ) * dxdKy ( j ) & - dlnphi_dn_w ( i , j ) * dwdKy ( j )) df ( i + n , j + n ) = Ky ( j ) * ( dlnphi_dn_y ( i , j ) * dydKy ( j ) & - dlnphi_dn_w ( i , j ) * dwdKy ( j )) end do ! dlnK_i/dlnK_i df ( i , i ) = df ( i , i ) + 1 df ( i + n , i + n ) = df ( i + n , i + n ) + 1 df ( i , 2 * n + 3 ) = sum ( Kx * dlnphi_dn_x ( i , :) * dwdb - dlnphi_dn_w ( i , :) * dwdb ) df ( i + n , 2 * n + 3 ) = sum ( Ky * dlnphi_dn_y ( i , :) * dwdb - dlnphi_dn_w ( i , :) * dwdb ) df ( 2 * n + 1 , i ) = Kx ( i ) * dwdKx ( i ) df ( 2 * n + 1 , i + n ) = Ky ( i ) * dwdKy ( i ) df ( 2 * n + 2 , i ) = Kx ( i ) * dxdKx ( i ) - Kx ( i ) * dydKx ( i ) df ( 2 * n + 2 , i + n ) = Ky ( i ) * dxdKy ( i ) - Ky ( i ) * dydKy ( i ) end do ! Derivatives wrt P df (: n , 2 * n + 1 ) = P * ( dlnphi_dp_x - dlnphi_dp_w ) df ( n + 1 : 2 * n , 2 * n + 1 ) = P * ( dlnphi_dp_y - dlnphi_dp_w ) ! Derivatives wrt T df (: n , 2 * n + 2 ) = T * ( dlnphi_dt_x - dlnphi_dt_w ) df ( n + 1 : 2 * n , 2 * n + 2 ) = T * ( dlnphi_dt_y - dlnphi_dt_w ) ! Derivatives wrt beta df ( 2 * n + 1 , 2 * n + 3 ) = sum ( dwdb ) df ( 2 * n + 2 , 2 * n + 3 ) = sum ( Kx * dwdb - Ky * dwdb ) ! Derivatives wrt Xs df ( 2 * n + 3 , :) = 0 df ( 2 * n + 3 , ns ) = 1 end subroutine subroutine pt_envelope_three_phase ( X0 , spec_number , del_S0 , envel ) use constants , only : ouput_path use io , only : str !! Subroutine to calculate Px phase envelopes via continuation method. !! Three phases version. real ( pr ), intent ( in ) :: X0 (:) !! Vector of variables integer , intent ( in ) :: spec_number !! Number of specification real ( pr ), intent ( in ) :: del_S0 !! \\Delta S_0 type ( PTEnvel3 ), intent ( out ) :: envel !! Calculated envelopes type ( critical_point ), allocatable :: cps (:) real ( pr ) :: X ( size ( X0 )) integer :: ns real ( pr ) :: S real ( pr ) :: del_S real ( pr ) :: XS ( max_points , size ( X0 )) real ( pr ) :: F ( size ( X0 )), dF ( size ( X0 ), size ( X0 )), dXdS ( size ( X0 )) integer :: point , iters , n integer :: i integer :: funit_output character ( len = 254 ) :: fname_env allocate ( cps ( 0 )) X = X0 n = ( size ( X0 ) - 3 ) / 2 ns = spec_number S = X ( ns ) del_S = del_S0 ! ====================================================================== !  Output file ! ---------------------------------------------------------------------- env_number = env_number + 1 write ( fname_env , * ) env_number fname_env = \"env-3ph-PT\" // \"_\" // trim ( adjustl ( fname_env )) fname_env = trim ( adjustl ( ouput_path )) // trim ( fname_env ) // \".dat\" open ( newunit = funit_output , file = fname_env ) write ( funit_output , * ) \"#\" write ( funit_output , * ) \"STAT\" , \" iters\" , \" ns\" , \" T\" , \" P\" , & \" beta\" , ( \" lnKx\" // str ( i ), i = 1 , n ), ( \" lnKy\" // str ( i ), i = 1 , n ) write ( funit_output , * ) \"X0\" , iters , ns , exp ( X ( 2 * n + 2 )), exp ( X ( 2 * n + 1 )), & X ( 2 * n + 3 ), X (: 2 * n ) ! ====================================================================== enveloop : do point = 1 , max_points call progress_bar ( point , max_points , advance = . false .) call full_newton ( pt_F_three_phases , iters , X , ns , S , max_iters , F , dF ) if ( iters >= max_iters ) then print * , \"Breaking: Above max iterations\" exit enveloop end if write ( funit_output , * ) \"SOL\" , iters , ns , exp ( X ( 2 * n + 2 )), & exp ( X ( 2 * n + 1 )), X ( 2 * n + 3 ), X (: 2 * n ) XS ( point , :) = X update_spec : block real ( pr ) :: dFdS ( size ( X0 )) integer :: ns_new dFdS = 0 ! Actually it's -dFdS dFdS ( 2 * n + 3 ) = 1 dXdS = solve_system ( dF , dFdS ) if ( maxval ( abs ( X (: 2 * n ))) < 1 ) then ! T, P and beta not allowed near a CP ns_new = maxloc ( abs ( dXdS (: 2 * n )), dim = 1 ) else ns_new = maxloc ( abs ( dXdS ), dim = 1 ) end if if ( ns_new /= ns ) then ! translation of delS to the  new specification variable del_S = dXdS ( ns_new ) * del_S dXdS = dXdS / dXdS ( ns_new ) ns = ns_new end if end block update_spec fix_step : block real ( pr ) :: Xnew ( size ( X0 )) real ( pr ) :: dP , dT del_S = sign ( 2.5_pr , del_S ) * minval ([ & max ( abs ( X ( ns ) / 5 ), 0.1_pr ), & abs ( del_S ) * 3 / iters & ] & ) Xnew = X + dXdS * del_S dP = exp ( Xnew ( 2 * n + 1 )) - exp ( X ( 2 * n + 1 )) dT = exp ( Xnew ( 2 * n + 2 )) - exp ( X ( 2 * n + 2 )) do while ( abs ( dP ) > 2 . or . abs ( dT ) > 5 ) dXdS = dXdS / 2.0_pr Xnew = X + dXdS * del_S dP = exp ( Xnew ( 2 * n + 1 )) - exp ( X ( 2 * n + 1 )) dT = exp ( Xnew ( 2 * n + 2 )) - exp ( X ( 2 * n + 2 )) end do end block fix_step detect_critical : block real ( pr ) :: K (( size ( X0 ) - 3 ) / 2 ), Knew (( size ( X0 ) - 3 ) / 2 ), & Xnew ( size ( X0 )), fact real ( pr ) :: pc , tc , dS_c , dXdS_in ( size ( X0 )) integer :: max_changing , i fact = 4.0_pr loop : do i = 0 , 1 Xnew = X + fact * dXdS * del_S K = X ( i * n + 1 :( i + 1 ) * n ) Knew = Xnew ( i * n + 1 :( i + 1 ) * n ) max_changing = minloc ( abs ( Knew - K ), dim = 1 ) if ( all ( K * Knew < 0 )) then dS_c = ( & - k ( max_changing ) * ( Xnew ( ns ) - X ( ns )) & / ( Knew ( max_changing ) - K ( max_changing )) & ) Xnew = X + dXdS * dS_c Tc = exp ( Xnew ( 2 * n + 2 )) pc = exp ( Xnew ( 2 * n + 1 )) cps = [ cps , critical_point ( tc , pc , 0.0_pr )] del_S = dS_c + sign ( 0.04_pr , dS_c ) write ( funit_output , * ) \"\" write ( funit_output , * ) \"\" exit loop end if end do loop end block detect_critical X = X + dXdS * del_S S = X ( ns ) if ( any ( break_conditions_three_phases ( X , ns , S ))) then print * , \"Breaking: \" , break_conditions_three_phases ( X , ns , S ) exit enveloop end if end do enveloop write ( funit_output , * ) \"\" write ( funit_output , * ) \"\" write ( funit_output , * ) \"#critical\" if ( size ( cps ) > 0 ) then do i = 1 , size ( cps ) write ( funit_output , * ) cps ( i )% t , cps ( i )% p end do else write ( funit_output , * ) \"NaN NaN\" end if close ( funit_output ) call progress_bar ( point , max_points , . true .) envel % lnKx = XS (: point , : n ) envel % lnKy = XS (: point , n + 1 : 2 * n ) envel % P = exp ( XS (: point , 2 * n + 1 )) envel % T = exp ( XS (: point , 2 * n + 2 )) envel % beta = XS (: point , 2 * n + 3 ) envel % critical_points = cps end subroutine function break_conditions_three_phases ( X , ns , S ) !! Set of conditions to break the tracing. real ( pr ) :: X (:) !! Variables vector integer :: ns !! Number of specification real ( pr ) :: S !! Value of specification integer :: n real ( pr ) :: p , t , beta logical , allocatable :: break_conditions_three_phases (:) n = ( size ( X ) - 3 ) / 2 p = exp ( X ( 2 * n + 1 )) beta = x ( 2 * n + 3 ) t = X ( 2 * n + 2 ) break_conditions_three_phases = [ & beta < 0 & . or . 1 < beta & ] end function ! =========================================================================== ! =========================================================================== !  Intersections and crossings ! --------------------------------------------------------------------------- subroutine get_case (& dew , bub , hpl , intersections , self_intersections , this_case & ) use linalg , only : intersection , point type ( envelope ), intent ( in ) :: dew type ( envelope ), intent ( in ) :: bub type ( envelope ), intent ( in ) :: hpl type ( point ), allocatable , intent ( out ) :: intersections (:) type ( point ), allocatable , intent ( out ) :: self_intersections (:) character ( len = :), allocatable , intent ( out ) :: this_case type ( point ), allocatable :: inter_dew_bub (:) type ( point ), allocatable :: inter_hpl_bub (:) type ( point ), allocatable :: inter_hpl_dew (:) inter_dew_bub = intersection ( dew % t , dew % p , bub % t , bub % p ) inter_hpl_bub = intersection ( hpl % t , hpl % p , bub % t , bub % p ) inter_hpl_dew = intersection ( hpl % t , hpl % p , dew % t , dew % p ) if ( size ( inter_dew_bub ) == 2 ) then this_case = \"2_DEW_BUB\" intersections = inter_dew_bub else if ( size ( inter_hpl_bub ) == 1 . and . size ( inter_dew_bub ) == 1 ) then this_case = \"2_HPL_BUB_DEW_BUB\" intersections = [ inter_hpl_bub , inter_dew_bub ] else if ( size ( inter_hpl_bub ) == 2 ) then this_case = \"2_HPL_BUB\" intersections = [ inter_hpl_bub ( 1 ), inter_hpl_bub ( 2 )] else if ( size ( inter_hpl_dew ) == 1 ) then this_case = \"1_HPL_DEW\" intersections = inter_hpl_dew else if ( size ( inter_hpl_bub ) == 1 ) then this_case = \"1_HPL_BUB\" intersections = inter_hpl_bub else this_case = \"0\" allocate ( intersections ( 0 )) end if end subroutine subroutine pt_three_phase_from_intersection (& pt_x , pt_y , intersections , & pt_x_3 , pt_y_3 & ) use legacy_ar_models , only : z use linalg , only : point , interpol type ( envelope ), intent ( in ) :: pt_x , pt_y type ( point ), intent ( in ) :: intersections (:) type ( PTEnvel3 ), intent ( out ) :: pt_x_3 (:), pt_y_3 (:) real ( pr ), allocatable :: lnKx (:), lnKy (:) real ( pr ), allocatable :: X (:) real ( pr ) :: t , p , beta , del_S0 real ( pr ), allocatable :: phase_y (:), phase_x (:) integer :: i , j , i_inter = 1 integer :: ns do i_inter = 1 , size ( intersections ) i = intersections ( i_inter )% i j = intersections ( i_inter )% j t = intersections ( i_inter )% x p = intersections ( i_inter )% y lnKx = interpol ( pt_x % t ( i ), pt_x % t ( i + 1 ), & pt_x % logk ( i , :), pt_x % logk ( i + 1 , :), & t & ) lnKy = interpol ( & pt_y % t ( j ), pt_y % t ( j + 1 ), & pt_y % logk ( j , :), pt_y % logk ( j + 1 , :), & t & ) ! Bubble line composition phase_y = exp ( lnKy ) * z ! Dew line composition phase_x = exp ( lnKx ) * z del_S0 = - 0.01_pr beta = 1 ns = 2 * nc + 3 ! ================================================================== !  Line with incipient phase gas ! ------------------------------------------------------------------ print * , \"Three Phase: Gas\" lnKx = log ( phase_x / phase_y ) lnKy = log ( z / phase_y ) X = [ lnKx , lnKy , log ( p ), log ( t ), beta ] call pt_envelope_three_phase ( X , ns , del_S0 , pt_x_3 ( i_inter )) ! ================================================================== ! ================================================================== !  Line with incipient phase liquid ! ------------------------------------------------------------------ print * , \"Three Phase: Liquid\" lnKx = log ( phase_y / phase_x ) lnKy = log ( z / phase_x ) X = [ lnKx , lnKy , log ( p ), log ( t ), beta ] call pt_envelope_three_phase ( X , ns , del_S0 , pt_y_3 ( i_inter )) ! ================================================================== end do ! =========================================================================== end subroutine end module envelopes","tags":"","loc":"sourcefile/envelopes.f90.html"},{"title":"io_nml.f90 – fenvelopes","text":"This file depends on sourcefile~~io_nml.f90~~EfferentGraph sourcefile~io_nml.f90 io_nml.f90 sourcefile~constants.f90 constants.f90 sourcefile~io_nml.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~io_nml.f90~~AfferentGraph sourcefile~io_nml.f90 io_nml.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~io_nml.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules io_nml Source Code io_nml.f90 Source Code module io_nml !! Namelist I/O Module !! !! Module that holds all the I/O routines to read from a setup file !! and setup the models and parameters included included in the thermodynamic !! routines !! !! ```fortran !! !!  ! Namelist based input file !!  ! ========================= !!  ! !!  ! Units: !!  !  - Pressure: bar !!  !  - Temperature: K !!  !  - Volume: L !!  ! ========================= !! !! !!  &nml_setup !!      nc=3,                    ! Number of components !!      model=\"PR78\",            ! SRK PR76 PR78 RKPR !!      mixrule=\"ClassicVdW\"     ! ClassicVdW !!  / !! !!  &nml_composition !!      names=\"C4\" \"C20\" \"H2O\" !!      spec=\"critical\"          ! critical or parameters !!      z=0.16 0.04 0.8 !!  / !! !!  &nml_classicvdw !!      kij(1, :)=0   0   0.5 !!      kij(2, :)=0   0   0.5 !!      kij(3, :)=0.5 0.5 0 !!  / !! !!  &nml_critical !!      ! Critical constants !!      tc=425.2 782.0 647.3 !!      pc=38.0 14.6 220.89 !!      w=0.1928 0.816 0.344 !!  / !! use constants , only : pr use legacy_ar_models , only : nc , thermo_model , mixing_rule , tdep , & & z , & & tc , pc , w , & & ac , b , k , & & kij , lij , bij , & & setup , SRK_factory , PR76_factory , PR78_factory use io , only : str implicit none integer :: nunit_input character ( len = 50 ) :: model , mixrule character ( len = 254 ) :: path_to_file character ( len = 50 ) :: spec character ( len = 50 ), allocatable :: names (:) private public :: setup_input , read_system , write_system contains subroutine setup_input ( filepath ) !> Setup input file to be used character ( len =* ), intent ( in ) :: filepath !! Path to input file path_to_file = trim ( adjustl ( filepath )) end subroutine subroutine read_model () !> Reads the thermodynamic model to be used and sets up the selector ! variables used in the thermo routines namelist / nml_setup / nc , model , mixrule integer :: i , j ! Open file and get setup information open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_setup ) close ( nunit_input ) ! Setup the legacy model name select case ( model ) case ( \"SRK\" ) thermo_model = 1 case ( \"PR76\" ) thermo_model = 2 case ( \"PR78\" ) thermo_model = 3 case ( \"RKPR\" ) thermo_model = 4 end select ! This should be below, but to assure compatiblity with legacy the ! mixing rule should be setup first select case ( mixrule ) case ( \"ClassicVdW\" ) tdep = 0 mixing_rule = 0 end select ! Allocate in memory all the parameters call setup ( nc , thermo_model , tdep , mixing_rule ) allocate ( names ( nc )) allocate ( z ( nc )) end subroutine subroutine read_components () !! Read components namelist / nml_composition / names , spec , z integer :: i , j ! Open file and get the components to use, their composition and what ! kind of specification to use on their definition open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_composition ) close ( nunit_input ) ! Normalize compositions z = z / sum ( z ) select case ( model ) case ( \"SRK\" ) call read_srk () case ( \"PR76\" ) call read_pr76 () case ( \"PR78\" ) call read_pr78 () end select select case ( mixrule ) case ( \"ClassicVdW\" ) !! Read kij and lij matrixes !! Since in the ClassicVdW mixing rules the bij matrix is constant !! it's stored beforehand call read_kij_lij () do i = 1 , nc do j = i , nc bij ( i , j ) = 0.5_pr * ( b ( i ) + b ( j )) * ( 1.0_pr - lij ( i , j )) bij ( j , i ) = bij ( i , j ) end do end do end select end subroutine subroutine read_srk () !! Read SRK model parameters !! !! options: !! !! - spec=`critical` -> Use critical constants !! - spec=`parameters` -> Use EoS parameters !! namelist / nml_critical / tc , pc , w !! Critical constants namelist / nml_parameters / ac , b , k !! EoS parameters select case ( spec ) case ( \"critical\" ) open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_critical ) close ( nunit_input ) call SRK_factory ( z , tc_in = tc , pc_in = pc , w_in = w ) case ( \"parameters\" ) open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_parameters ) close ( nunit_input ) call SRK_factory ( z , ac_in = ac , b_in = b , k_in = k ) end select end subroutine subroutine read_pr76 () !! Read PR76 model namelist / nml_critical / tc , pc , w namelist / nml_parameters / ac , b , k select case ( spec ) case ( \"critical\" ) open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_critical ) close ( nunit_input ) call PR76_factory ( z , tc_in = tc , pc_in = pc , w_in = w ) case ( \"parameters\" ) open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_parameters ) close ( nunit_input ) call PR76_factory ( z , ac_in = ac , b_in = b , k_in = k ) end select end subroutine subroutine read_pr78 () ! Read PR78 model namelist / nml_critical / tc , pc , w namelist / nml_parameters / ac , b , k select case ( spec ) case ( \"critical\" ) open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_critical ) close ( nunit_input ) call PR78_factory ( z , tc_in = tc , pc_in = pc , w_in = w ) case ( \"parameters\" ) open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_parameters ) close ( nunit_input ) call PR78_factory ( z , ac_in = ac , b_in = b , k_in = k ) end select end subroutine subroutine read_kij_lij () ! Read the Kij and Lij matrices namelist / nml_classicvdw / kij , lij integer :: i , j kij = 0 lij = 0 open ( newunit = nunit_input , file = path_to_file ) read ( nunit_input , nml = nml_classicvdw ) close ( nunit_input ) do i = 1 , nc do j = 1 , nc kij ( i , j ) = kij ( j , i ) lij ( i , j ) = lij ( j , i ) end do end do end subroutine subroutine read_system ( filepath ) character ( len =* ) :: filepath call setup_input ( filepath ) call read_model () call read_components () close ( nunit_input ) end subroutine subroutine write_system ( file_unit ) ! Write read system into a file integer , intent ( in ), optional :: file_unit integer :: i ! if (.not. present(file_unit)) file_unit= character ( len = 20 ) :: fmt_pure character ( len = 20 ) :: fmt_names fmt_pure = \"(xG,\" // adjustl ( trim ( str ( nc ))) // \"F10.4)\" fmt_names = \"(8x, \" // adjustl ( trim ( str ( nc ))) // \"(A8))\" write ( file_unit , * ) \"=====================\" write ( file_unit , * ) \"General System: \" write ( file_unit , * ) \"---------------------\" write ( file_unit , * ) \"Model: \" , model write ( file_unit , * ) \"MixingRule: \" , mixrule write ( file_unit , * ) \"Names: \" , ( trim ( names ( i )) // \" \" , i = 1 , nc ) write ( file_unit , \"(xA,2x,*(F8.6, 2x))\" ) \"Z:\" , z write ( file_unit , * ) \"====================\" write ( file_unit , * ) \"Critical Constants: \" write ( file_unit , * ) \"--------------------\" write ( file_unit , fmt_pure ) \"Tc: \" , tc write ( file_unit , fmt_pure ) \"Pc: \" , pc write ( file_unit , fmt_pure ) \"w : \" , w write ( file_unit , * ) \"====================\" write ( file_unit , * ) \"EoS Parameters: \" write ( file_unit , * ) \"--------------------\" write ( file_unit , fmt_pure ) \"ac:\" , ac write ( file_unit , fmt_pure ) \"b :\" , b write ( file_unit , fmt_pure ) \"k :\" , k write ( file_unit , * ) \"====================\" write ( file_unit , * ), \"Mixing Rules: \" write ( file_unit , * ), \"--------------------\" write ( file_unit , * ) \"Kij: \" write ( file_unit , fmt_names ) names do i = 1 , nc write ( file_unit , fmt_pure ) str ( i ), kij ( i , :) end do write ( file_unit , * ) \"lij: \" write ( file_unit , fmt_names ) names do i = 1 , nc write ( file_unit , fmt_pure ) str ( i ), lij ( i , :) end do end subroutine end module","tags":"","loc":"sourcefile/io_nml.f90.html"},{"title":"mod_dsp_lines.f90 – fenvelopes","text":"This file depends on sourcefile~~mod_dsp_lines.f90~~EfferentGraph sourcefile~mod_dsp_lines.f90 mod_dsp_lines.f90 sourcefile~constants.f90 constants.f90 sourcefile~mod_dsp_lines.f90->sourcefile~constants.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~mod_dsp_lines.f90->sourcefile~linalg.f90 sourcefile~mod_inj_envelopes.f90 mod_inj_envelopes.f90 sourcefile~mod_dsp_lines.f90->sourcefile~mod_inj_envelopes.f90 sourcefile~types.f90 types.f90 sourcefile~mod_dsp_lines.f90->sourcefile~types.f90 sourcefile~linalg.f90->sourcefile~constants.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~constants.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~linalg.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~types.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~envelopes.f90 sourcefile~optim.f90 optim.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~optim.f90 sourcefile~types.f90->sourcefile~constants.f90 sourcefile~envelopes.f90->sourcefile~constants.f90 sourcefile~envelopes.f90->sourcefile~linalg.f90 sourcefile~envelopes.f90->sourcefile~types.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mod_dsp_lines.f90~~AfferentGraph sourcefile~mod_dsp_lines.f90 mod_dsp_lines.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_dsp_lines.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules dsp_lines Source Code mod_dsp_lines.f90 Source Code module dsp_lines !! Module to calculate DSP lines use constants , only : pr , R use dtypes , only : envelope , critical_point use inj_envelopes , only : update_spec , injection_case , z_0 , z_injection , & get_z , injelope use linalg , only : solve_system , interpol , full_newton use progress_bar_module , only : progress_bar implicit none ! =========================================================================== !  Parameters ! --------------------------------------------------------------------------- integer :: env_number = 0 !! Number of calculated envelope integer :: max_iters = 1000 !! Maximum number of iterations for a newton step integer , parameter :: max_points = 1000 !! Maximum number of points for each envelope character ( len = 255 ) :: FE_LOG real ( pr ) :: del_S_multiplier = 1.0_pr real ( pr ) :: max_da = 0.1_pr real ( pr ) :: max_dp = 2 0.0_pr real ( pr ) :: max_dT = 1 0.0_pr ! =========================================================================== contains ! =========================================================================== ! Three-phases ! --------------------------------------------------------------------------- subroutine dsp_line_F ( Xvars , ns , S , F , dF ) !! Function to solve at each point of a three phase envelope. !! !! The vector of variables X corresponds to: !!  X = [lnKx_i, lnKy_i lnP, \\alpha, T]  !! !! While the equations are: !! !!  F = [ !!        lnKx_i - ln \\phi_i(x, P, T) + ln \\phi_i(w, P, T), !!        lnKy_i - ln \\phi_i(y, P, T) + ln \\phi_i(w, P, T), !!        \\sum_{i=1}&#94;N (w_i) - 1, !!        \\sum_{i=1}&#94;N (x_i - y_i), !!        X_{ns} - S !! ]  use legacy_ar_models , only : TERMO use iso_fortran_env , only : error_unit real ( pr ), intent ( in ) :: Xvars (:) !! Vector of variables integer , intent ( in ) :: ns !! Number of specification real ( pr ), intent ( in ) :: S !! Specification value real ( pr ), intent ( out ) :: F ( size ( Xvars )) !! Vector of functions valuated real ( pr ), intent ( out ) :: df ( size ( Xvars ), size ( Xvars )) !! Jacobian matrix ! Xvars variables real ( pr ) :: Kx (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: Ky (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: P real ( pr ) :: alpha real ( pr ) :: T ! Incipient phase 1 variables real ( pr ) :: Vx real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 ) :: x , lnfug_x , dlnphi_dt_x , dlnphi_dp_x real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 , ( Size ( Xvars ) - 3 ) / 2 ) :: dlnphi_dn_x ! Incipient phase 2 variables real ( pr ) :: Vy real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 ) :: y , lnfug_y , dlnphi_dt_y , dlnphi_dp_y real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 , ( Size ( Xvars ) - 3 ) / 2 ) :: dlnphi_dn_y ! Main phase variables real ( pr ) :: Vz real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 ) :: z , lnfug_z , dlnphi_dt_z , dlnphi_dp_z real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 , ( Size ( Xvars ) - 3 ) / 2 ) :: dlnphi_dn_z ! Derivative of z wrt alpha real ( pr ) :: dzda (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: dzdKx (( Size ( Xvars ) - 3 ) / 2 ), dxdKx (( Size ( Xvars ) - 3 ) / 2 ), dydKx (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: dzdKy (( Size ( Xvars ) - 3 ) / 2 ), dxdKy (( Size ( Xvars ) - 3 ) / 2 ), dydKy (( Size ( Xvars ) - 3 ) / 2 ) integer :: i , j , n n = ( Size ( Xvars ) - 3 ) / 2 ! Setting variables Kx = exp ( Xvars ( 1 : n )) Ky = exp ( Xvars ( n + 1 : 2 * n )) P = exp ( Xvars ( 2 * n + 1 )) alpha = Xvars ( 2 * n + 2 ) T = exp ( Xvars ( 2 * n + 3 )) call get_z ( alpha , z , dzda ) ! if (any(z < 0)) return x = Kx * z y = Ky * z call TERMO ( & n , 0 , 4 , T , P , x , Vx , lnfug_x , dlnphi_dp_x , dlnphi_dt_x , dlnphi_dn_x & ) call TERMO ( & n , 0 , 4 , T , P , y , Vy , lnfug_y , dlnphi_dp_y , dlnphi_dt_y , dlnphi_dn_y & ) call TERMO ( & n , 0 , 4 , T , P , z , Vz , lnfug_z , dlnphi_dp_z , dlnphi_dt_z , dlnphi_dn_z & ) F ( 1 : n ) = log ( Kx ) + lnfug_x - lnfug_z F ( n + 1 : 2 * n ) = log ( Ky ) + lnfug_y - lnfug_z F ( 2 * n + 1 ) = sum ( x - z ) F ( 2 * n + 2 ) = sum ( y - z ) F ( 2 * n + 3 ) = Xvars ( ns ) - S df = 0 do i = 1 , n do j = 1 , n df ( i , j ) = x ( j ) * dlnphi_dn_x ( i , j ) df ( i + n , j + n ) = y ( j ) * dlnphi_dn_y ( i , j ) end do df ( i , i ) = df ( i , i ) + 1 df ( i + n , i + n ) = df ( i + n , i + n ) + 1 ! Derivatives wrt alpha df ( i , 2 * n + 2 ) = sum ( dlnphi_dn_x ( i , :) * Kx * dzda - dlnphi_dn_z ( i , :) * dzda ) df ( i + n , 2 * n + 2 ) = sum ( dlnphi_dn_y ( i , :) * Ky * dzda - dlnphi_dn_z ( i , :) * dzda ) end do df (: n , 2 * n + 1 ) = P * ( dlnphi_dp_x - dlnphi_dp_z ) df ( n + 1 : 2 * n , 2 * n + 1 ) = P * ( dlnphi_dp_y - dlnphi_dp_z ) df (: n , 2 * n + 3 ) = T * ( dlnphi_dt_x - dlnphi_dt_z ) df ( n + 1 : 2 * n , 2 * n + 3 ) = T * ( dlnphi_dt_y - dlnphi_dt_z ) df ( 2 * n + 1 , : n ) = x df ( 2 * n + 2 , n + 1 : 2 * n ) = y df ( 2 * n + 1 , 2 * n + 2 ) = sum ( Kx * dzda - dzda ) df ( 2 * n + 2 , 2 * n + 2 ) = sum ( Ky * dzda - dzda ) df ( 2 * n + 3 , ns ) = 1 end subroutine subroutine dsp_line ( X0 , spec_number , del_S0 , envels ) use constants , only : ouput_path use io , only : str !! Subroutine to calculate Px phase envelopes via continuation method. !! Three phases version. real ( pr ), intent ( in ) :: X0 (:) !! Vector of variables integer , intent ( in ) :: spec_number !! Number of specification real ( pr ), intent ( in ) :: del_S0 !! \\Delta S_0 type ( injelope ), intent ( out ) :: envels !! Calculated envelopes type ( critical_point ), allocatable :: cps (:) real ( pr ) :: X ( size ( X0 )) integer :: ns real ( pr ) :: S real ( pr ) :: XS ( max_points , size ( X0 )) real ( pr ) :: del_S real ( pr ) :: F ( size ( X0 )), dF ( size ( X0 ), size ( X0 )), dXdS ( size ( X0 )) integer :: point , iters , n integer :: i integer :: funit_output character ( len = 254 ) :: fname_env allocate ( cps ( 0 )) X = X0 n = ( size ( X0 ) - 3 ) / 2 ns = spec_number S = X ( ns ) del_S = del_S0 ! ====================================================================== !  Output file ! ---------------------------------------------------------------------- env_number = env_number + 1 write ( fname_env , * ) env_number fname_env = \"env-3ph-DSP\" // \"_\" // trim ( adjustl ( fname_env )) fname_env = trim ( adjustl ( ouput_path )) // trim ( fname_env ) // \".dat\" open ( newunit = funit_output , file = fname_env ) write ( funit_output , * ) \"#\" , env_number write ( funit_output , * ) \"STAT\" , \" iters\" , \" ns\" , \" alpha\" , \" P\" , & \" T\" , ( \" lnKx\" // str ( i ), i = 1 , n ), ( \" lnKy\" // str ( i ), i = 1 , n ) write ( funit_output , * ) \"X0\" , iters , ns , & X ( 2 * n + 2 ), exp ( X ( 2 * n + 1 )), exp ( X ( 2 * n + 3 )), X (: 2 * n ) ! ====================================================================== enveloop : do point = 1 , max_points call progress_bar ( point , max_points , advance = . false .) call full_newton ( dsp_line_F , iters , X , ns , S , max_iters , F , dF ) if ( iters >= max_iters ) then call progress_bar ( point , max_points , advance = . true .) print * , \"Breaking: Above max iterations\" exit enveloop end if write ( funit_output , * ) \"SOL\" , iters , ns , & X ( 2 * n + 2 ), exp ( X ( 2 * n + 1 )), exp ( X ( 2 * n + 3 )), X (: 2 * n ) XS ( point , :) = X call update_spec ( X , ns , del_S , dF , dXdS ) call fix_step ( iters , X , ns , S , del_S , dXdS ) X = X + dXdS * del_S S = X ( ns ) if ( any ( break_conditions_dsp_line ( X , ns , S , del_S )) . and . point > 10 ) then call progress_bar ( point , max_points , . true .) print * , \"Breaking: \" , break_conditions_dsp_line ( X , ns , S , del_S ) exit enveloop end if end do enveloop write ( funit_output , * ) \"\" write ( funit_output , * ) \"\" write ( funit_output , * ) \"#critical\" if ( size ( cps ) > 0 ) then do i = 1 , size ( cps ) write ( funit_output , * ) cps ( i )% alpha , cps ( i )% p end do else write ( funit_output , * ) \"NaN NaN\" end if close ( funit_output ) envels % z = z_0 envels % z_inj = z_injection envels % logk = XS (: point , : n ) envels % alpha = XS (: point , n + 2 ) envels % p = exp ( XS (: point , n + 1 )) envels % critical_points = cps end subroutine subroutine fix_step ( iters , X , ns , S , del_S , dXdS ) integer , intent ( in ) :: iters real ( pr ), intent ( in ) :: X (:) integer , intent ( in ) :: ns real ( pr ), intent ( in ) :: S real ( pr ), intent ( in out ) :: del_S real ( pr ), intent ( in out ) :: dXdS ( size ( X )) real ( pr ) :: Xnew ( size ( X )) real ( pr ) :: da , dP , dT integer :: n n = ( size ( X ) - 3 ) / 2 del_S = sign ( del_S_multiplier , del_S ) * minval ([ & max ( abs ( X ( ns ) / 10 ), 0.1_pr ), & abs ( del_S ) * 3 / iters & ] & ) if ( injection_case == \"dilution\" ) del_S = 50 * del_S Xnew = X + dXdS * del_S da = ( Xnew ( 2 * n + 2 )) - ( X ( 2 * n + 2 )) dP = exp ( Xnew ( 2 * n + 1 )) - exp ( X ( 2 * n + 1 )) dT = exp ( Xnew ( 2 * n + 3 )) - exp ( X ( 2 * n + 3 )) do while ( abs ( da ) > max_da . or . abs ( dP ) > max_dP . or . abs ( dT ) > max_dT ) dXdS = dXdS / 2.0_pr Xnew = X + dXdS * del_S da = ( Xnew ( 2 * n + 2 )) - ( X ( 2 * n + 2 )) dP = exp ( Xnew ( 2 * n + 1 )) - exp ( X ( 2 * n + 1 )) dT = exp ( Xnew ( 2 * n + 3 )) - exp ( X ( 2 * n + 3 )) end do end subroutine function break_conditions_dsp_line ( X , ns , S , del_S ) !! Set of conditions to break the tracing. real ( pr ) :: X (:) !! Variables vector integer :: ns !! Number of specification real ( pr ) :: S !! Value of specification real ( pr ) :: del_S integer :: n real ( pr ) :: p , alpha logical , allocatable :: break_conditions_dsp_line (:) n = ( size ( X ) - 3 ) / 2 p = exp ( X ( 2 * n + 1 )) alpha = X ( 2 * n + 2 ) break_conditions_dsp_line = [ . false .& ! p < 0.001_pr .or. p > 5000, & ! abs(del_S) < 1e-5 & ] end function ! =========================================================================== ! =========================================================================== ! Initialization procedures ! --------------------------------------------------------------------------- function dsp_line_from_dsp (& inter , pt_1 , pt_2 , del_S0 , alpha0 & ) result ( envels ) use legacy_ar_models , only : nc use stdlib_optval , only : optval use linalg , only : point , interpol type ( point ), intent ( in ) :: inter type ( envelope ), intent ( in ) :: pt_1 , pt_2 type ( injelope ) :: envels ( 2 ) real ( pr ), optional :: del_S0 real ( pr ), optional :: alpha0 integer :: i , j real ( pr ) :: lnKx ( nc ), lnKy ( nc ), t , p , X ( 2 * nc + 3 ), alpha real ( pr ) :: del_S real ( pr ) :: z ( nc ), dzda ( nc ) integer :: ns del_S = optval ( del_S0 , 0.01_pr ) alpha = optval ( alpha0 , 0._pr ) i = inter % i j = inter % j t = inter % x p = inter % y lnKx = interpol ( & pt_1 % t ( i ), pt_1 % t ( i + 1 ), & pt_1 % logk ( i , :), pt_1 % logk ( i + 1 , :), & t & ) lnKy = interpol ( & pt_2 % t ( j ), pt_2 % t ( j + 1 ), & pt_2 % logk ( j , :), pt_2 % logk ( j + 1 , :), & t & ) call get_z ( alpha , z , dzda ) ns = 2 * nc + 2 X = [ lnKx , lnKy , log ( p ), alpha , log ( t )] call dsp_line ( X , ns , del_S , envels ( 1 )) X = [ lnKx , lnKy , log ( p ), alpha , log ( t )] call dsp_line ( X , ns , - del_S , envels ( 2 )) ! ================================================================== end function ! =========================================================================== end module","tags":"","loc":"sourcefile/mod_dsp_lines.f90.html"},{"title":"mod_inj_envelopes.f90 – fenvelopes","text":"This file depends on sourcefile~~mod_inj_envelopes.f90~~EfferentGraph sourcefile~mod_inj_envelopes.f90 mod_inj_envelopes.f90 sourcefile~constants.f90 constants.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~constants.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~envelopes.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~linalg.f90 sourcefile~optim.f90 optim.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~optim.f90 sourcefile~types.f90 types.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~types.f90 sourcefile~envelopes.f90->sourcefile~constants.f90 sourcefile~envelopes.f90->sourcefile~linalg.f90 sourcefile~envelopes.f90->sourcefile~types.f90 sourcefile~linalg.f90->sourcefile~constants.f90 sourcefile~types.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~mod_inj_envelopes.f90~~AfferentGraph sourcefile~mod_inj_envelopes.f90 mod_inj_envelopes.f90 sourcefile~mod_dsp_lines.f90 mod_dsp_lines.f90 sourcefile~mod_dsp_lines.f90->sourcefile~mod_inj_envelopes.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~mod_inj_envelopes.f90 sourcefile~main.f90->sourcefile~mod_dsp_lines.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules inj_envelopes Source Code mod_inj_envelopes.f90 Source Code module inj_envelopes !! Module to calculate Px phase envelopes use constants , only : pr , R use dtypes , only : envelope , critical_point use linalg , only : solve_system , interpol , full_newton use progress_bar_module , only : progress_bar implicit none type , extends ( envelope ) :: injelope real ( pr ), allocatable :: alpha (:) !! Ammount of injected fluid real ( pr ), allocatable :: z_inj (:) !! Injected fluid composition real ( pr ), allocatable :: z_mix (:, :) !! Composition at each step end type ! =========================================================================== !  Parameters ! --------------------------------------------------------------------------- integer :: env_number = 0 !! Number of calculated envelope integer :: max_iters = 50 !! Maximum number of iterations for a newton step integer , parameter :: max_points = 1000 !! Maximum number of points for each envelope real ( pr ), allocatable :: z_0 (:) !! Original fluid composition real ( pr ), allocatable :: z_injection (:) !! Injection fluid composition real ( pr ) :: T !! Temperature of injection character ( len = 10 ) :: injection_case !! Kind of injection displace|dilute character ( len = 255 ) :: FE_LOG ! Two-phase settings real ( pr ) :: del_S_multiplier = 2.0_pr real ( pr ) :: max_dp = 5 0.0_pr real ( pr ) :: max_dalpha = 0.01_pr real ( pr ) :: critical_multiplier = 2.0_pr ! Three phase parameters real ( pr ) :: del_S_multiplier_three_phase = 1.7_pr real ( pr ) :: critical_fact = 3.0_pr ! =========================================================================== contains subroutine from_nml ( filepath ) use legacy_ar_models , only : nc character ( len =* ), intent ( in ) :: filepath integer :: funit namelist / nml_px / T , z_0 , z_injection , injection_case allocate ( z_0 ( nc ), z_injection ( nc )) open ( newunit = funit , file = filepath ) read ( funit , nml = nml_px ) close ( funit ) z_injection = z_injection / sum ( z_injection ) end subroutine ! =========================================================================== ! Two-phases ! --------------------------------------------------------------------------- subroutine F_injection ( X , ns , S , F , dF ) !! Function to solve at each point of the phase envelope. !! !! The vector of variables X corresponds to: !!  X = [lnK_i, lnP, \\alpha]  !! !! While the equations are: !! !!  F = [lnK_i - ln \\phi_i(y, P, T) + ln \\phi_i(z, P, T), !!         \\sum_{i=1}&#94;N, X_{ns} - S]  !! !! The injection can be considered as two kinds of injection: !! - Displacement:  z = \\alpha z_i + (1-\\alpha) z_0  !! - Addition:   z = \\frac{\\alpha z_i + (1-\\alpha) z_0}{\\sum_{i=1}&#94;N \\alpha z_i + (1-\\alpha) z_0}  !! use iso_fortran_env , only : error_unit use legacy_ar_models , only : TERMO real ( pr ), intent ( in ) :: X (:) !! Vector of variables integer , intent ( in ) :: ns !! Number of specification real ( pr ), intent ( in ) :: S !! Specification value real ( pr ), intent ( out ) :: F ( size ( X )) !! Vector of functions valuated real ( pr ), intent ( out ) :: df ( size ( x ), size ( X )) !! Jacobian matrix ! X variables real ( pr ) :: K ( size ( X ) - 2 ) real ( pr ) :: alpha real ( pr ) :: P ! Main phase variables real ( pr ) :: Vz real ( pr ), dimension ( size ( X ) - 2 ) :: z , lnfug_z , dlnphi_dt_z , dlnphi_dp_z real ( pr ), dimension ( size ( X ) - 2 , size ( X ) - 2 ) :: dlnphi_dn_z ! Incipient phase variables real ( pr ) :: Vy real ( pr ), dimension ( size ( X ) - 2 ) :: y , lnfug_y , dlnphi_dt_y , dlnphi_dp_y real ( pr ), dimension ( size ( X ) - 2 , size ( X ) - 2 ) :: dlnphi_dn_y ! Derivative of z wrt alpha real ( pr ) :: dzda ( size ( X ) - 2 ) integer :: i , j , n n = size ( X ) - 2 K = exp ( X ( 1 : n )) P = exp ( X ( n + 1 )) alpha = X ( n + 2 ) call get_z ( alpha , z , dzda ) ! if (any(z < 0)) z = 0 y = K * z call TERMO ( & n , 0 , 4 , T , P , y , Vy , lnfug_y , dlnphi_dp_y , dlnphi_dt_y , dlnphi_dn_y & ) call TERMO ( & n , 0 , 4 , T , P , z , Vz , lnfug_z , dlnphi_dp_z , dlnphi_dt_z , dlnphi_dn_z & ) F ( 1 : n ) = X (: n ) + lnfug_y - lnfug_z F ( n + 1 ) = sum ( y - z ) F ( n + 2 ) = X ( ns ) - S df = 0 do i = 1 , n do j = 1 , n df ( i , j ) = y ( j ) * dlnphi_dn_y ( i , j ) end do df ( i , i ) = df ( i , i ) + 1 df ( i , n + 2 ) = sum ( K * dlnphi_dn_y ( i , :) * dzda - dlnphi_dn_z ( i , :) * dzda ) end do df (: n , n + 1 ) = P * ( dlnphi_dp_y - dlnphi_dp_z ) df ( n + 1 , : n ) = y df ( n + 1 , n + 2 ) = sum ( dzda * ( K - 1 )) df ( n + 2 , :) = 0 df ( n + 2 , ns ) = 1 end subroutine subroutine injection_envelope ( X0 , spec_number , del_S0 , envels ) !! Subroutine to calculate Px phase envelopes via continuation method use constants , only : ouput_path use io , only : str real ( pr ), intent ( in ) :: X0 (:) !! Vector of variables integer , intent ( in ) :: spec_number !! Number of specification real ( pr ), intent ( in ) :: del_S0 !! \\Delta S_0 type ( injelope ), intent ( out ) :: envels !! Calculated envelopes type ( critical_point ), allocatable :: cps (:) real ( pr ) :: X ( size ( X0 )) integer :: ns real ( pr ) :: S real ( pr ) :: XS ( max_points , size ( X0 )) real ( pr ) :: del_S real ( pr ) :: F ( size ( X0 )), dF ( size ( X0 ), size ( X0 )), dXdS ( size ( X0 )) real ( pr ) :: z ( size ( X0 ) - 2 ) integer :: point , iters , n integer :: i integer :: funit_output character ( len = 254 ) :: fname_env allocate ( cps ( 0 )) X = X0 n = size ( X0 ) - 2 ns = spec_number S = X ( ns ) del_S = del_S0 call get_z ( X ( n + 2 ), z ) ! ======================================================================== !  Output file ! ------------------------------------------------------------------------ env_number = env_number + 1 write ( fname_env , * ) env_number fname_env = \"env-2ph-PX\" // \"_\" // trim ( adjustl ( fname_env )) fname_env = trim ( adjustl ( ouput_path )) // trim ( fname_env ) // \".dat\" open ( newunit = funit_output , file = fname_env ) write ( funit_output , * ) \"#\" , T write ( funit_output , * ) \"STAT\" , \" iters\" , \" ns\" , \" alpha\" , \" P\" , & ( \" lnK\" // str ( i ), i = 1 , n ), ( \" z\" // str ( i ), i = 1 , n ) write ( funit_output , * ) \"X0\" , iters , ns , X ( n + 2 ), exp ( X ( n + 1 )), X (: n ), z ! ======================================================================== enveloop : do point = 1 , max_points call progress_bar ( point , max_points , advance = . false .) call full_newton ( f_injection , iters , X , ns , S , max_iters , F , dF ) if ( iters >= max_iters ) then call progress_bar ( point , max_points , advance = . true .) print * , \"Breaking: Above max iterations\" exit enveloop end if XS ( point , :) = X call update_spec ( X , ns , del_S , dF , dXdS ) call fix_step_two_phases ( X , ns , S , iters , del_S , dXdS ) detect_critical : block real ( pr ) :: K ( size ( X0 ) - 2 ), Knew ( size ( X0 ) - 2 ), & Xnew ( size ( X0 )), fact real ( pr ) :: pc , alpha_c , dS_c integer :: max_changing fact = critical_fact ! 2.5 Xnew = X + fact * dXdS * del_S K = X (: n ) Knew = Xnew (: n ) if ( all ( K * Knew < 0 )) then max_changing = maxloc ( abs ( K - Knew ), dim = 1 ) dS_c = ( & - K ( max_changing ) * ( Xnew ( max_changing ) - X ( max_changing )) & / ( Knew ( max_changing ) - K ( max_changing )) & ) Xnew = X + dXdS * dS_c alpha_c = Xnew ( n + 2 ) pc = exp ( Xnew ( n + 1 )) cps = [ cps , critical_point ( t , pc , alpha_c )] del_S = dS_c + critical_multiplier * dS_c write ( funit_output , * ) \"\" write ( funit_output , * ) \"\" end if end block detect_critical X = X + dXdS * del_S S = X ( ns ) if ( any ( break_conditions ( X , ns , S , del_S ))) then print * , \"Breaking: \" , break_conditions ( X , ns , S , del_S ) exit enveloop end if call get_z ( X ( n + 2 ), z ) write ( funit_output , * ) \"SOL\" , iters , ns , X ( n + 2 ), exp ( X ( n + 1 )), & X (: n ), z end do enveloop write ( funit_output , * ) \"\" write ( funit_output , * ) \"\" write ( funit_output , * ) \"#critical\" if ( size ( cps ) > 0 ) then do i = 1 , size ( cps ) write ( funit_output , * ) cps ( i )% alpha , cps ( i )% p end do else write ( funit_output , * ) \"NaN NaN\" end if close ( funit_output ) point = point - 1 envels % z = z_0 envels % z_inj = z_injection envels % logk = XS (: point , : n ) envels % alpha = XS (: point , n + 2 ) envels % p = exp ( XS (: point , n + 1 )) envels % critical_points = cps end subroutine subroutine update_spec ( X , ns , del_S , dF , dXdS ) real ( pr ), intent ( in ) :: X (:) integer , intent ( in out ) :: ns real ( pr ), intent ( in out ) :: del_S real ( pr ), intent ( in ) :: dF ( size ( X ), size ( X )) real ( pr ), intent ( in out ) :: dXdS ( size ( X )) real ( pr ) :: dFdS ( size ( X )) integer :: ns_new integer :: n dFdS = 0 dFdS ( size ( dFdS )) = 1 dXdS = solve_system ( dF , dFdS ) ns_new = maxloc ( abs ( dXdS ), dim = 1 ) if ( ns_new /= ns ) then ! translation of delS and dXdS to the  new specification variable del_S = dXdS ( ns_new ) * del_S dXdS = dXdS / dXdS ( ns_new ) ns = ns_new end if end subroutine subroutine fix_step_two_phases ( X , ns , S , solve_its , del_S , dXdS ) real ( pr ), intent ( in ) :: X (:) integer , intent ( in ) :: ns real ( pr ), intent ( in ) :: S integer , intent ( in ) :: solve_its real ( pr ), intent ( in out ) :: del_S real ( pr ), intent ( in out ) :: dXdS ( size ( X )) real ( pr ) :: Xnew ( size ( X - 1 )) real ( pr ) :: dP , dalpha real ( pr ) :: dP_tol , dalpha_tol integer :: n n = size ( X ) - 2 del_S = sign ( del_S_multiplier , del_S ) * minval ([ & max ( sqrt ( abs ( X ( ns ))) / 10 , 0.1 ), & abs ( del_S ) * 3 / solve_its & ] & ) if ( injection_case == \"dilution\" ) del_S = 50 * del_S Xnew = X + dXdS * del_S dP = exp ( Xnew ( n + 1 )) - exp ( X ( n + 1 )) dalpha = Xnew ( n + 2 ) - X ( n + 2 ) if ( X ( n + 2 ) > 1.9 ) then dP_tol = max_dP / 2 dalpha_tol = max_dalpha / 2 else dP_tol = max_dp dalpha_tol = max_dalpha end if do while ( abs ( dP ) > dp_tol . or . abs ( dalpha ) > dalpha_tol ) dXdS = dXdS / 2.0_pr Xnew = X + dXdS * del_S dP = exp ( Xnew ( n + 1 )) - exp ( X ( n + 1 )) dalpha = Xnew ( n + 2 ) - X ( n + 2 ) end do end subroutine function break_conditions ( X , ns , S , del_S ) !! Set of conditions to break the tracing of a two phase line. real ( pr ) :: X (:) !! Vector of variables integer :: ns !! Number of specification real ( pr ) :: S !! Specification value real ( pr ) :: del_S !! \\Delta S integer :: n real ( pr ) :: p , alpha logical , allocatable :: break_conditions (:) n = size ( X ) - 2 p = exp ( X ( n + 1 )) alpha = X ( n + 2 ) break_conditions = [ . false . & ! p < 1e-15 .or. p > 5000, & ! abs(del_S) < 1e-3 & ] end function ! =========================================================================== ! =========================================================================== ! Three-phases ! --------------------------------------------------------------------------- subroutine F_injection_three_phases ( Xvars , ns , S , F , dF ) !! Function to solve at each point of a three phase envelope. !! !! The vector of variables X corresponds to: !!  X = [lnKx_i, lnKy_i lnP, \\alpha, \\beta]  !! !! While the equations are: !! !!  F = [ !!        lnKx_i - ln \\phi_i(x, P, T) + ln \\phi_i(w, P, T), !!        lnKy_i - ln \\phi_i(y, P, T) + ln \\phi_i(w, P, T), !!        \\sum_{i=1}&#94;N (w_i) - 1, !!        \\sum_{i=1}&#94;N (x_i - y_i), !!        X_{ns} - S !! ]  use legacy_ar_models , only : TERMO use iso_fortran_env , only : error_unit real ( pr ), intent ( in ) :: Xvars (:) !! Vector of variables integer , intent ( in ) :: ns !! Number of specification real ( pr ), intent ( in ) :: S !! Specification value real ( pr ), intent ( out ) :: F ( size ( Xvars )) !! Vector of functions valuated real ( pr ), intent ( out ) :: df ( size ( Xvars ), size ( Xvars )) !! Jacobian matrix ! Xvars variables real ( pr ) :: z (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: Kx (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: Ky (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: P real ( pr ) :: beta real ( pr ) :: alpha ! Main phase 1 variables real ( pr ) :: Vx real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 ) :: x , lnfug_x , dlnphi_dt_x , dlnphi_dp_x real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 , ( Size ( Xvars ) - 3 ) / 2 ) :: dlnphi_dn_x ! Main phase 2 variables real ( pr ) :: Vy real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 ) :: y , lnfug_y , dlnphi_dt_y , dlnphi_dp_y real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 , ( Size ( Xvars ) - 3 ) / 2 ) :: dlnphi_dn_y ! Incipient phase variables real ( pr ) :: Vw real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 ) :: w , lnfug_w , dlnphi_dt_w , dlnphi_dp_w real ( pr ), dimension (( Size ( Xvars ) - 3 ) / 2 , ( Size ( Xvars ) - 3 ) / 2 ) :: dlnphi_dn_w ! Derivative of z wrt alpha real ( pr ) :: dzda (( Size ( Xvars ) - 3 ) / 2 ), dwda (( Size ( Xvars ) - 3 ) / 2 ) ! Derivative of w wrt beta real ( pr ) :: dwdb (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: dwdKx (( Size ( Xvars ) - 3 ) / 2 ), dxdKx (( Size ( Xvars ) - 3 ) / 2 ), dydKx (( Size ( Xvars ) - 3 ) / 2 ) real ( pr ) :: dwdKy (( Size ( Xvars ) - 3 ) / 2 ), dxdKy (( Size ( Xvars ) - 3 ) / 2 ), dydKy (( Size ( Xvars ) - 3 ) / 2 ) integer :: i , j , n n = ( Size ( Xvars ) - 3 ) / 2 Kx = exp ( Xvars ( 1 : n )) Ky = exp ( Xvars ( n + 1 : 2 * n )) P = exp ( Xvars ( 2 * n + 1 )) alpha = Xvars ( 2 * n + 2 ) beta = Xvars ( 2 * n + 3 ) call get_z ( alpha , z , dzda ) ! if (any(z < 0)) z = 0 w = z / ( beta * Ky + ( 1 - beta ) * Kx ) x = w * Kx y = w * Ky call TERMO ( & n , 0 , 4 , T , P , x , Vx , lnfug_x , dlnphi_dp_x , dlnphi_dt_x , dlnphi_dn_x & ) call TERMO ( & n , 0 , 4 , T , P , y , Vy , lnfug_y , dlnphi_dp_y , dlnphi_dt_y , dlnphi_dn_y & ) call TERMO ( & n , 0 , 4 , T , P , w , Vw , lnfug_w , dlnphi_dp_w , dlnphi_dt_w , dlnphi_dn_w & ) F ( 1 : n ) = Xvars ( 1 : n ) + lnfug_x - lnfug_w F ( n + 1 : 2 * n ) = Xvars ( n + 1 : 2 * n ) + lnfug_y - lnfug_w F ( 2 * n + 1 ) = sum ( w ) - 1 F ( 2 * n + 2 ) = sum ( x - y ) F ( 2 * n + 3 ) = Xvars ( ns ) - S df = 0 dwda = 1.0_pr / ( beta * Ky + ( 1 - beta ) * Kx ) * dzda dwdb = z * ( Kx - Ky ) / (( 1 - beta ) * Kx + beta * Ky ) ** 2 dwdKx = - z * ( 1 - beta ) / ( Ky * beta + ( 1 - beta ) * Kx ) ** 2 dxdKx = Kx * dwdKx + w dydKx = Ky * dwdKx dwdKy = - z * ( beta ) / ( Ky * beta + ( 1 - beta ) * Kx ) ** 2 dxdKy = Kx * dwdKy dydKy = Ky * dwdKy + w do i = 1 , n do j = 1 , n df ( i , j ) = Kx ( j ) * ( dlnphi_dn_x ( i , j ) * dxdKx ( j ) & - dlnphi_dn_w ( i , j ) * dwdKx ( j )) df ( i + n , j ) = Kx ( j ) * ( dlnphi_dn_y ( i , j ) * dydKx ( j ) & - dlnphi_dn_w ( i , j ) * dwdKx ( j )) df ( i , j + n ) = Ky ( j ) * ( dlnphi_dn_x ( i , j ) * dxdKy ( j ) & - dlnphi_dn_w ( i , j ) * dwdKy ( j )) df ( i + n , j + n ) = Ky ( j ) * ( dlnphi_dn_y ( i , j ) * dydKy ( j ) & - dlnphi_dn_w ( i , j ) * dwdKy ( j )) end do df ( i , i ) = df ( i , i ) + 1 df ( i + n , i + n ) = df ( i + n , i + n ) + 1 df ( i , 2 * n + 2 ) = sum ( & Kx * dlnphi_dn_x ( i , :) * dwda - dlnphi_dn_w ( i , :) * dwda & ) df ( i + n , 2 * n + 2 ) = sum ( Ky * dlnphi_dn_y ( i , :) * dwda & - dlnphi_dn_w ( i , :) * dwda ) ! Derivatives wrt beta df ( i , 2 * n + 3 ) = sum ( Kx * dlnphi_dn_x ( i , :) * dwdb & - dlnphi_dn_w ( i , :) * dwdb ) df ( i + n , 2 * n + 3 ) = sum ( Ky * dlnphi_dn_y ( i , :) * dwdb & - dlnphi_dn_w ( i , :) * dwdb ) df ( 2 * n + 1 , i ) = Kx ( i ) * dwdKx ( i ) df ( 2 * n + 1 , i + n ) = Ky ( i ) * dwdKy ( i ) df ( 2 * n + 2 , i ) = Kx ( i ) * dxdKx ( i ) - Kx ( i ) * dydKx ( i ) df ( 2 * n + 2 , i + n ) = Ky ( i ) * dxdKy ( i ) - Ky ( i ) * dydKy ( i ) end do ! Derivatives wrt P df (: n , 2 * n + 1 ) = P * ( dlnphi_dp_x - dlnphi_dp_w ) df ( n + 1 : 2 * n , 2 * n + 1 ) = P * ( dlnphi_dp_y - dlnphi_dp_w ) ! Derivatives wrt alpha df ( 2 * n + 1 , 2 * n + 2 ) = sum ( dwda ) df ( 2 * n + 2 , 2 * n + 2 ) = sum ( Kx * dwda - Ky * dwda ) ! Derivatives wrt beta df ( 2 * n + 1 , 2 * n + 3 ) = sum ( dwdb ) df ( 2 * n + 2 , 2 * n + 3 ) = sum ( Kx * dwdb - Ky * dwdb ) ! Derivatives wrt Xs df ( 2 * n + 3 , :) = 0 df ( 2 * n + 3 , ns ) = 1 end subroutine subroutine injection_envelope_three_phase ( X0 , spec_number , del_S0 , envels ) use constants , only : ouput_path use io , only : str !! Subroutine to calculate Px phase envelopes via continuation method. !! Three phases version. real ( pr ), intent ( in ) :: X0 (:) !! Vector of variables integer , intent ( in ) :: spec_number !! Number of specification real ( pr ), intent ( in ) :: del_S0 !! \\Delta S_0 type ( injelope ), intent ( out ) :: envels !! Calculated envelopes type ( critical_point ), allocatable :: cps (:) real ( pr ), target :: X ( size ( X0 )) integer :: ns real ( pr ) :: S real ( pr ) :: XS ( max_points , size ( X0 )) real ( pr ) :: del_S real ( pr ) :: F ( size ( X0 )), dF ( size ( X0 ), size ( X0 )), dXdS ( size ( X0 )) real ( pr ), pointer :: lnP real ( pr ), pointer :: alpha real ( pr ), pointer :: beta real ( pr ), pointer :: lnKx (:) real ( pr ), pointer :: lnKy (:) real ( pr ) :: z ( size ( z_0 )) integer :: point , iters , n integer :: i integer :: funit_output character ( len = 254 ) :: fname_env allocate ( cps ( 0 )) X = X0 n = ( size ( X0 ) - 3 ) / 2 ns = spec_number S = X ( ns ) del_S = del_S0 lnKx => X (: n ) lnKy => X ( n + 1 : 2 * n ) lnP => X ( 2 * n + 1 ) alpha => X ( 2 * n + 2 ) beta => X ( 2 * n + 3 ) call get_z ( alpha , z ) ! ====================================================================== !  Output file ! ---------------------------------------------------------------------- env_number = env_number + 1 write ( fname_env , * ) env_number fname_env = \"env-3ph-PX\" // \"_\" // trim ( adjustl ( fname_env )) fname_env = trim ( adjustl ( ouput_path )) // trim ( fname_env ) // \".dat\" open ( newunit = funit_output , file = fname_env ) write ( funit_output , * ) \"#\" , T write ( funit_output , * ) \"STAT\" , \" iters\" , \" ns\" , \" alpha\" , \" P\" , & \" beta\" , ( \" lnKx\" // str ( i ), i = 1 , n ), ( \" lnKy\" // str ( i ), i = 1 , n ), ( \" z\" // str ( i ), i = 1 , n ) write ( funit_output , * ) \"X0\" , iters , ns , X ( 2 * n + 2 ), exp ( X ( 2 * n + 1 )), & X ( 2 * n + 3 ), X (: 2 * n ) ! ====================================================================== enveloop : do point = 1 , max_points call progress_bar ( point , max_points , advance = . false .) call full_newton ( F_injection_three_phases , iters , X , ns , S , max_iters , F , dF ) if ( iters >= max_iters ) then call progress_bar ( point , max_points , advance = . true .) print * , \"Breaking: Above max iterations\" exit enveloop end if call get_z ( alpha , z ) write ( funit_output , * ) \"SOL\" , iters , ns , alpha , & exp ( X ( 2 * n + 1 )), X ( 2 * n + 3 ), X (: 2 * n ), z XS ( point , :) = X call update_spec ( X , ns , del_S , dF , dXdS ) fix_step : block real ( pr ) :: Xnew ( size ( X0 )) real ( pr ) :: dP , dalpha del_S = sign ( del_S_multiplier_three_phase , del_S ) * minval ([ & max ( abs ( X ( ns ) / 10 ), 0.1_pr ), & abs ( del_S ) * 3 / iters & ] & ) if ( injection_case == \"dilution\" ) del_S = 50 * del_S Xnew = X + dXdS * del_S dP = exp ( Xnew ( 2 * n + 1 )) - exp ( X ( 2 * n + 1 )) dalpha = Xnew ( 2 * n + 2 ) - X ( 2 * n + 2 ) do while ( abs ( dP ) > max_dp . or . abs ( dalpha ) > max_dalpha ) dXdS = dXdS / 2.0_pr Xnew = X + dXdS * del_S dP = exp ( Xnew ( 2 * n + 1 )) - exp ( X ( 2 * n + 1 )) dalpha = Xnew ( 2 * n + 2 ) - X ( 2 * n + 2 ) end do end block fix_step detect_critical : block real ( pr ) :: K (( size ( X0 ) - 3 ) / 2 ), Knew (( size ( X0 ) - 3 ) / 2 ), & Xnew ( size ( X0 )), fact real ( pr ) :: pc , alpha_c , dS_c , dXdS_in ( size ( X0 )) integer :: max_changing , i fact = critical_fact loop : do i = 0 , 1 Xnew = X + fact * dXdS * del_S K = X ( i * n + 1 :( i + 1 ) * n ) Knew = Xnew ( i * n + 1 :( i + 1 ) * n ) max_changing = maxloc ( abs ( Knew - K ), dim = 1 ) if ( all ( K * Knew < 0 )) then dS_c = ( & - k ( max_changing ) * ( Xnew ( ns ) - X ( ns )) & / ( Knew ( max_changing ) - K ( max_changing )) & ) Xnew = X + dXdS * dS_c alpha_c = Xnew ( 2 * n + 2 ) pc = exp ( Xnew ( 2 * n + 1 )) cps = [ cps , critical_point ( t , pc , alpha_c )] ! del_S = dS_c + del_S ! * fact ! del_S = del_S * fact del_S = dS_c - sign ( 1.7_pr , dS_c ) * dS_c write ( funit_output , * ) \"\" write ( funit_output , * ) \"\" exit loop end if end do loop end block detect_critical if ( x ( 2 * n + 3 ) > 1 . or . ( x ( 2 * n + 3 ) < 0 )) then call progress_bar ( point , max_points , . true .) print * , \"Breaking: positive 𝜷\" exit enveloop end if X = X + dXdS * del_S S = X ( ns ) if ( any ( break_conditions_three_phases ( X , ns , S , del_S )) . and . point > 10 ) then call progress_bar ( point , max_points , . true .) print * , \"Breaking: \" , break_conditions_three_phases ( X , ns , S , del_S ) exit enveloop end if end do enveloop ! point = point - 1 write ( funit_output , * ) \"\" write ( funit_output , * ) \"\" write ( funit_output , * ) \"#critical\" if ( size ( cps ) > 0 ) then do i = 1 , size ( cps ) write ( funit_output , * ) cps ( i )% alpha , cps ( i )% p end do else write ( funit_output , * ) \"NaN NaN\" end if close ( funit_output ) envels % z = z_0 envels % z_inj = z_injection envels % logk = XS (: point , : n ) envels % alpha = XS (: point , n + 2 ) envels % p = exp ( XS (: point , n + 1 )) envels % critical_points = cps end subroutine function break_conditions_three_phases ( X , ns , S , del_S ) !! Set of conditions to break the tracing. real ( pr ) :: X (:) !! Variables vector integer :: ns !! Number of specification real ( pr ) :: S !! Value of specification real ( pr ) :: del_S integer :: n real ( pr ) :: p , alpha logical , allocatable :: break_conditions_three_phases (:) n = ( size ( X ) - 3 ) / 2 p = exp ( X ( 2 * n + 1 )) alpha = X ( 2 * n + 2 ) break_conditions_three_phases = [ & ! p < 0.001_pr .or. p > 5000, & abs ( del_S ) < 1e-5 & ] end function ! =========================================================================== subroutine get_z ( alpha , z , dzda ) !! Calculate the fluid composition based on an amount of addition !! of second fluid. !! !! The injection can be considered as two kinds of injection: !! - Displacement:  z = \\alpha z_i + (1-\\alpha) z_0  !! - Addition:   z = \\frac{\\alpha z_i + (1-\\alpha) z_0}{\\sum_{i=1}&#94;N \\alpha z_i + (1-\\alpha) z_0}  real ( pr ), intent ( in ) :: alpha !! Addition percentaje  \\alpha  real ( pr ), intent ( out ) :: z ( size ( z_0 )) !! New composition real ( pr ), optional , intent ( out ) :: dzda ( size ( z_0 )) !! Derivative wrt \\alpha select case ( injection_case ) case ( \"displace\" ) z = ( z_injection * alpha + ( 1.0_pr - alpha ) * z_0 ) if ( present ( dzda )) dzda = z_injection - z_0 case ( \"dilute\" ) z = ( z_injection * alpha + z_0 ) / sum ( z_injection * alpha + z_0 ) if ( present ( dzda )) dzda = - ( alpha * z_injection + z_0 ) & * sum ( z_injection ) / sum ( alpha * z_injection + z_0 ) ** 2 & + z_injection / sum ( alpha * z_injection + z_0 ) case default z = ( z_injection * alpha + ( 1.0_pr - alpha ) * z_0 ) if ( present ( dzda )) dzda = z_injection - z_0 end select end subroutine function get_case ( dew_envel , bub_envel ) result ( n_case ) type ( injelope ), intent ( in ) :: dew_envel type ( injelope ), intent ( in ) :: bub_envel integer :: n_case end function function remove_duplicates ( envels ) result ( clean_envels ) !! From a set of envelopes check if they are the same line class ( injelope ) :: envels (:) type ( injelope ), allocatable :: clean_envels (:) if ( size ( envels ) /= 1 ) then else clean_envels = envels end if end function function same_line ( env1 , env2 ) !! class ( injelope ), intent ( in ) :: env1 , env2 logical :: same_line end function ! =========================================================================== ! Initialization procedures ! --------------------------------------------------------------------------- function px_two_phase_from_pt ( t_inj , pt_env_2 , t_tol , del_S0 ) result ( envel ) !! Calculate two phase Px envelopes at a given injection temperature. !! !! Given an injection temperature `t_inj` and a base PT envelope !! `pt_env_2`, finds all the points on the PT envelope near `t_inj`, based !! on an absolute tolerance `t_tol`. These points are used as !! initialization for calculation of Px envelopes. use linalg , only : interpol use stdlib_optval , only : optval real ( pr ), intent ( in ) :: t_inj !! Injection temperature [K] type ( envelope ), intent ( in ) :: pt_env_2 !! Base PT envelope real ( pr ), intent ( in ) :: t_tol !! Absolute temperature tolerance real ( pr ), optional , intent ( in ) :: del_S0 !! First point \\Delta S type ( injelope ) :: envel !! Output Px envelope real ( pr ), allocatable :: ts_envel (:) !! Temperatures under tolerance real ( pr ), allocatable :: k (:) !! K values real ( pr ), allocatable :: X (:) !! Vector of variables real ( pr ) :: alpha !! Amount of injection real ( pr ) :: p !! Pressure of ocurrence real ( pr ) :: pold !! Old pressure, used to assure no repeats integer :: i , idx , ns real ( pr ) :: del_S del_S = optval ( del_S0 , 0.1_pr ) pold = 1e9 ts_envel = pack ( pt_env_2 % t , mask = abs ( pt_env_2 % t - t_inj ) < t_tol ) do i = 1 , size ( ts_envel ) idx = findloc ( pt_env_2 % t , value = ts_envel ( i ), dim = 1 ) p = interpol ( & pt_env_2 % t ( idx ), pt_env_2 % t ( idx + 1 ), & pt_env_2 % p ( idx ), pt_env_2 % p ( idx + 1 ), & t_inj ) if ( abs ( p - pold ) < 2 ) cycle pold = p k = exp ( interpol ( & pt_env_2 % t ( idx ), pt_env_2 % t ( idx + 1 ), & pt_env_2 % logk ( idx , :), pt_env_2 % logk ( idx + 1 , :), & t_inj )) alpha = 0 X = [ log ( K ), log ( P ), alpha ] ns = size ( X ) call injection_envelope ( X , ns , del_S , envel ) end do end function function px_three_phase_from_pt ( t_inj , pt_env_3 , t_tol , del_S0 ) result ( envel ) !! Calculate three phase Px envelopes at a given injection temperature. !! !! Given an injection temperature `t_inj` and a base PT envelope !! `pt_env_3`, finds all the points on the PT envelope near `t_inj`, based !! on an absolute tolerance `t_tol`. These points are used as !! initialization for calculation of Px envelopes. use linalg , only : interpol use stdlib_optval , only : optval use envelopes , only : PTEnvel3 real ( pr ), intent ( in ) :: t_inj !! Injection temperature [K] type ( PTEnvel3 ), intent ( in ) :: pt_env_3 (:) !! Base PT envelopes real ( pr ), intent ( in ) :: t_tol !! Absolute temperature tolerance real ( pr ), optional , intent ( in ) :: del_S0 !! First point \\Delta S type ( injelope ) :: envel !! Output Px envelope real ( pr ), allocatable :: ts_envel (:) !! Temperatures under tolerance real ( pr ), allocatable :: kx (:), ky (:) !! K values real ( pr ), allocatable :: X (:) !! Vector of variables real ( pr ) :: alpha !! Amount of injection real ( pr ) :: beta !! Main phases molar fraction real ( pr ) :: p !! Pressure of ocurrence real ( pr ) :: pold !! Old pressure, used to assure no repeats integer :: i , idx , ns , i_envel real ( pr ) :: del_S del_S = optval ( del_S0 , 0.05_pr ) pold = 0 do i_envel = 1 , size ( pt_env_3 ) print * , i_envel associate ( pt => pt_env_3 ( i_envel )) ts_envel = pack ( pt % t , mask = abs ( pt % t - t_inj ) < t_tol ) do i = 1 , size ( ts_envel ) idx = findloc ( pt % t , value = ts_envel ( i ), dim = 1 ) p = interpol ( & pt % t ( idx ), pt % t ( idx + 1 ), & pt % p ( idx ), pt % p ( idx + 1 ), & t_inj ) if ( abs ( p - pold ) < 5 ) cycle pold = p kx = exp ( interpol ( & pt % t ( idx ), pt % t ( idx + 1 ), & pt % lnkx ( idx , :), pt % lnkx ( idx + 1 , :), & t_inj )) ky = exp ( interpol ( & pt % t ( idx ), pt % t ( idx + 1 ), & pt % lnky ( idx , :), pt % lnky ( idx + 1 , :), & t_inj )) beta = interpol ( & pt % t ( idx ), pt % t ( idx + 1 ), & pt % beta ( idx ), pt % beta ( idx + 1 ), & t_inj ) alpha = 0 X = [ log ( Kx ), log ( Ky ), log ( P ), alpha , beta ] ns = size ( X ) - 1 print * , \"Running isolated PX\" call injection_envelope_three_phase ( X , ns , del_S , envel ) end do end associate end do end function function px_three_phase_from_inter (& inter , px_1 , px_2 , del_S0 , beta0 & ) result ( envels ) use legacy_ar_models , only : nc use stdlib_optval , only : optval use linalg , only : point , interpol type ( point ), intent ( in ) :: inter type ( injelope ), intent ( in ) :: px_1 , px_2 type ( injelope ) :: envels ( 2 ) real ( pr ), optional :: del_S0 real ( pr ), optional :: beta0 integer :: i , j real ( pr ) :: lnKx ( nc ), lnKy ( nc ), alpha , p , beta , X ( 2 * nc + 3 ) real ( pr ) :: phase_y ( nc ), phase_x ( nc ) real ( pr ) :: del_S real ( pr ) :: z ( nc ), dzda ( nc ) integer :: ns del_S = optval ( del_S0 , - 0.05_pr ) beta = optval ( beta0 , 0.99_pr ) i = inter % i j = inter % j alpha = inter % x p = inter % y lnKx = interpol ( & px_1 % alpha ( i ), px_1 % alpha ( i + 1 ), & px_1 % logk ( i , :), px_1 % logk ( i + 1 , :), & alpha & ) lnKy = interpol ( & px_2 % alpha ( j ), px_2 % alpha ( j + 1 ), & px_2 % logk ( j , :), px_2 % logk ( j + 1 , :), & alpha & ) call get_z ( alpha , z , dzda ) ! Bubble line composition phase_y = exp ( lnKy ) * z ! Dew line composition phase_x = exp ( lnKx ) * z ns = 2 * nc + 3 ! ================================================================== !  Line with incipient phase gas ! ------------------------------------------------------------------ print * , \"Three Phase: Gas\" lnKx = log ( phase_x / phase_y ) lnKy = log ( z / phase_y ) X = [ lnKx , lnKy , log ( p ), alpha , beta ] call injection_envelope_three_phase ( X , ns , del_S , envels ( 1 )) ! ================================================================== ! ================================================================== !  Line with incipient phase liquid ! ------------------------------------------------------------------ print * , \"Three Phase: Liquid\" lnKx = log ( phase_y / phase_x ) lnKy = log ( z / phase_x ) X = [ lnKx , lnKy , log ( p ), alpha , beta ] call injection_envelope_three_phase ( X , ns , del_S , envels ( 2 )) end function function px_hpl_line ( alpha_0 , p ) ! Find a HPLL PX line at a given pressure, starting from a given alpha use legacy_ar_models , only : nc , termo use linalg , only : solve_system real ( pr ), intent ( in ) :: alpha_0 !! Staring \\alpha to search real ( pr ), intent ( in ) :: p !! Pressure of HPLL type ( injelope ) :: px_hpl_line !! Resulting HPLL line real ( pr ) :: diff real ( pr ) :: lnfug_z ( nc ), lnfug_y ( nc ), & dlnphi_dz ( nc , nc ), dlnphi_dy ( nc , nc ), & dlnphi_dp_z ( nc ), dlnphi_dp_y ( nc ) real ( pr ) :: z ( nc ), y ( nc ), v , k ( nc ) real ( pr ) :: p_in , alpha_in real ( pr ), allocatable :: x (:) real ( pr ) :: del_S0 integer :: ns , ncomp find_hpl : do ncomp = nc , 1 , - 1 alpha_in = alpha_0 p_in = p y = 0 y ( ncomp ) = 1.0 diff = foo ([ alpha_in , p_in , y ]) return ! print *, ncomp, diff do while ( abs ( diff ) > 0.001 . and . p_in < 5000 ) p_in = p_in + 1 0.0_pr diff = foo ([ alpha_in , p_in , y ]) ! print *, diff end do if ( p_in >= 5000 ) then do while ( abs ( diff ) > 0.001 . and . alpha_in > 0 ) alpha_in = alpha_in - 0.01_pr diff = foo ([ alpha_in , p_in , y ]) end do end if p_in = 600 alpha_in = 0.9 if (. true .) then !(alpha_in > 0 .or. p_in < 5000) then ! call optim ! print *, alpha_in, p_in k = 1 / exp ( lnfug_y - lnfug_z ) X = [ log ( K ), log ( P_in ), alpha_in ] del_S0 = 0.1_pr ns = size ( X ) - 1 call injection_envelope ( X , ns , del_S0 , px_hpl_line ) exit find_hpl end if end do find_hpl contains function foo ( x ) result ( f ) real ( pr ) :: x (:) real ( pr ) :: f if ( x ( 1 ) > 1 ) x ( 1 ) = 0.97_pr ! alpha_in = x(1) p_in = x ( 2 ) y = abs ( x ( 3 :)) call get_z ( alpha_in , z ) call termo ( nc , 4 , 1 , t , p_in , z , v , philog = lnfug_z , dlphip = dlnphi_dp_z , fugn = dlnphi_dz ) call termo ( nc , 4 , 1 , t , p_in , y , v , philog = lnfug_y , dlphip = dlnphi_dp_y , fugn = dlnphi_dy ) f = abs (( log ( z ( ncomp )) + lnfug_z ( ncomp )) - ( log ( y ( ncomp )) + lnfug_y ( ncomp ))) end function subroutine optim use optimization , only : nm_opt real ( pr ) :: x0 ( size ( z ) + 2 ) integer :: stat real ( pr ) :: step ( size ( x0 )) x0 = [ alpha_in , p_in , y ] step = 0.1 step ( 1 ) = 0.1 step ( 2 ) = - 100 call nm_opt ( foo , x0 , stat , step ) end subroutine end function ! =========================================================================== end module","tags":"","loc":"sourcefile/mod_inj_envelopes.f90.html"},{"title":"constants.f90 – fenvelopes","text":"Files dependent on this one sourcefile~~constants.f90~~AfferentGraph sourcefile~constants.f90 constants.f90 sourcefile~mod_dsp_lines.f90 mod_dsp_lines.f90 sourcefile~mod_dsp_lines.f90->sourcefile~constants.f90 sourcefile~mod_inj_envelopes.f90 mod_inj_envelopes.f90 sourcefile~mod_dsp_lines.f90->sourcefile~mod_inj_envelopes.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~mod_dsp_lines.f90->sourcefile~linalg.f90 sourcefile~types.f90 types.f90 sourcefile~mod_dsp_lines.f90->sourcefile~types.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~constants.f90 sourcefile~main.f90->sourcefile~mod_dsp_lines.f90 sourcefile~main.f90->sourcefile~mod_inj_envelopes.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~main.f90->sourcefile~envelopes.f90 sourcefile~main.f90->sourcefile~linalg.f90 sourcefile~io_nml.f90 io_nml.f90 sourcefile~main.f90->sourcefile~io_nml.f90 sourcefile~main.f90->sourcefile~types.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~constants.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~envelopes.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~linalg.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~types.f90 sourcefile~envelopes.f90->sourcefile~constants.f90 sourcefile~envelopes.f90->sourcefile~linalg.f90 sourcefile~envelopes.f90->sourcefile~types.f90 sourcefile~flash.f90 Flash.f90 sourcefile~flash.f90->sourcefile~constants.f90 sourcefile~linalg.f90->sourcefile~constants.f90 sourcefile~io_nml.f90->sourcefile~constants.f90 sourcefile~types.f90->sourcefile~constants.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules constants Source Code constants.f90 Source Code module constants use iso_fortran_env , only : real32 , real64 , real128 implicit none integer , parameter :: pr = real64 real ( pr ), parameter :: R = 0.08314472 character ( len = 254 ) :: database_path = \"database/\" character ( len = 254 ) :: ouput_path = \"fenvelopes_output/\" character ( len = 1 ) :: path_sep = \"/\" end module constants","tags":"","loc":"sourcefile/constants.f90.html"},{"title":"mod_continuation.f90 – fenvelopes","text":"Contents Source Code mod_continuation.f90 Source Code ! module numerical_continuation_mod ! !! Module that implements a generic implementation of the continuation method ! !! to calculate phase envelopes. !     use yaeos_constants, only: pr !     implicit none ! !     integer, parameter :: max_points=1000 ! !     type, abstract :: continuation_method !         real(pr), allocatable :: x(:) !         integer :: ns !         real(pr) :: del_S !     contains !         procedure, deferred :: f !         procedure, deferred :: df !     end type ! !     abstract interface !         subroutine continuation_fun(X, ns, S, F, dF) !             import pr !             real(pr), intent(in) :: X !             integer, intent(in) :: ns !             real(pr), intent(in) :: S !             real(pr), intent(out) :: F(size(X)) !             real(pr), intent(out) :: dF(size(X), size(X)) !         end subroutine !     end interface ! ! contains ! !     subroutine numerical_continuation(& !         fun, & !         init_point, init_spec, init_del_spec, & !         XS & !     ) !         procedure(continuation_fun) :: fun !         real(pr), intent(in) :: init_point(:) !         integer,  intent(in) :: init_spec !         real(pr), intent(in) :: init_del_spec !         real(pr), intent(out) :: XS(max_points, size(init_point)) ! !         ! Inner variables !         real(pr) :: X(size(init_point)) !         integer :: ns !         real(pr) :: S !         real(pr) :: del_S !         real(pr) :: dXdS(size(init_point)) ! !         real(pr) :: F(size(init_point)), dF(size(init_point), size(init_point)) ! !         integer :: point !! Main loop ! !         ! Point solving variables !         integer :: solve_its ! !         ! Initialize variables !         X = init_point !         ns = init_spec !         S = X(ns) !         del_S = init_del_spec ! ! !         main_loop: do point = 1, max_points !             call solve_point(fun, solve_its, X, ns, S) !             XS(point, :) = X !             call update_specification(X, ns, del_S, dF, solve_its, dXdS) !             call fix_step(X, ns, S, solve_its, del_S, dXdS) !             call post_process(point, XS, ns, S, del_S, dXdS) !             if (any(break_conditions(X, ns, S, del_S))) exit main_loop !             X = X + dXdS * del_S !             S = X(ns) !         end do main_loop !     end subroutine ! end module","tags":"","loc":"sourcefile/mod_continuation.f90.html"},{"title":"main.f90 – fenvelopes","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~mod_dsp_lines.f90 mod_dsp_lines.f90 sourcefile~main.f90->sourcefile~mod_dsp_lines.f90 sourcefile~mod_inj_envelopes.f90 mod_inj_envelopes.f90 sourcefile~main.f90->sourcefile~mod_inj_envelopes.f90 sourcefile~constants.f90 constants.f90 sourcefile~main.f90->sourcefile~constants.f90 sourcefile~io_nml.f90 io_nml.f90 sourcefile~main.f90->sourcefile~io_nml.f90 sourcefile~types.f90 types.f90 sourcefile~main.f90->sourcefile~types.f90 sourcefile~linalg.f90 linalg.f90 sourcefile~main.f90->sourcefile~linalg.f90 sourcefile~envelopes.f90 envelopes.f90 sourcefile~main.f90->sourcefile~envelopes.f90 sourcefile~mod_dsp_lines.f90->sourcefile~mod_inj_envelopes.f90 sourcefile~mod_dsp_lines.f90->sourcefile~constants.f90 sourcefile~mod_dsp_lines.f90->sourcefile~types.f90 sourcefile~mod_dsp_lines.f90->sourcefile~linalg.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~constants.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~types.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~linalg.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~envelopes.f90 sourcefile~optim.f90 optim.f90 sourcefile~mod_inj_envelopes.f90->sourcefile~optim.f90 sourcefile~io_nml.f90->sourcefile~constants.f90 sourcefile~types.f90->sourcefile~constants.f90 sourcefile~linalg.f90->sourcefile~constants.f90 sourcefile~envelopes.f90->sourcefile~constants.f90 sourcefile~envelopes.f90->sourcefile~types.f90 sourcefile~envelopes.f90->sourcefile~linalg.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs main Source Code main.f90 Source Code program main use dtypes , only : envelope use envelopes , only : PTEnvel3 use inj_envelopes , only : injelope , get_z use constants , only : pr , ouput_path use legacy_ar_models , only : nc , z use flap , only : command_line_interface use stdlib_ansi , only : blue => fg_color_blue , red => fg_color_red , & operator ( // ), operator ( + ), & style_reset , style_blink_fast , style_bold , style_underline implicit none real ( pr ) :: et , st type ( command_line_interface ) :: cli integer :: cli_error character ( len = 99 ) :: cli_string type ( envelope ) :: pt_bub , pt_dew , pt_hpl !! Shared 2ph-PT envelopes type ( PTEnvel3 ), allocatable :: pt_bub_3 (:), pt_dew_3 (:) !! Shared 3ph-PT envelopes type ( injelope ) :: px_bub , px_dew , px_hpl !! Shared 2ph-Px envelopes real ( pr ) :: alpha = 0.0 ! Setup everything call setup call get_z ( alpha , z ) ! PT Envelopes call cpu_time ( st ) call pt_envelopes call cpu_time ( et ) print * , \"PT: \" , ( et - st ) * 1000 , \"cpu ms\" ! PX Envelopes call cpu_time ( st ) call px_envelopes call cpu_time ( et ) print * , \"PX: \" , ( et - st ) * 1000 , \"cpu ms\" contains subroutine setup_cli !! Setup CLI subroutine !! !! Setup the Command-Line-Interface processor call cli % init ( progname = \"envelopes\" , description = \"Phase Envelopes\" ) call cli % add ( & switch = \"--infile\" , & switch_ab = \"-i\" , & help = \"Input file\" , & error = cli_error , & required = . true .) call cli % parse ( error = cli_error ) if ( cli_error /= 0 ) stop end subroutine subroutine setup !! Setup system !! !! Make output folder (if necessary) and/or clean everyhing in an !! existing one. Then read input files to setup needed parameters. use io_nml , only : read_system , write_system use inj_envelopes , only : setup_inj => from_nml integer :: funit_system character ( len = 500 ) :: infile call system ( \"mkdir -p \" // trim ( ouput_path )) call system ( \"rm \" // trim ( ouput_path ) // \"*\" ) call setup_cli call cli % get ( val = infile , switch = \"--infile\" , error = cli_error ) call read_system ( trim ( infile )) call setup_inj ( trim ( infile )) open ( newunit = funit_system , file = \"systemdata.nml\" ) call write_system ( funit_system ) close ( funit_system ) end subroutine subroutine pt_envelopes use legacy_ar_models , only : z use envelopes , only : envelope2 , max_points , k_wilson_bubble , & max_points , p_wilson , k_wilson , find_hpl , get_case use linalg , only : point !! Calculation of PT envelopes of the main system. real ( pr ), allocatable :: tv (:) ! Temperatures [K] real ( pr ), allocatable :: pv (:) ! Pressures [bar] real ( pr ), allocatable :: dv (:) ! Densities [mol/L] real ( pr ) :: tcri ( 4 ) ! Critical points temperatures real ( pr ) :: pcri ( 4 ) ! Critical points pressures real ( pr ) :: dcri ( 4 ) ! Critical points densities real ( pr ) :: t , p ! Temperature and pressure real ( pr ), allocatable :: k (:) ! K factors integer :: n_points , icri ( 4 ), ncri , i type ( point ), allocatable :: intersections (:), self_intersections (:) character ( len = :), allocatable :: pt_case integer :: n allocate ( tv ( max_points ), pv ( max_points ), dv ( max_points )) allocate ( k ( size ( z ))) print * , style_underline // \"PT Regions\" // style_reset ! ======================================================================== !  Bubble envel ! ------------------------------------------------------------------------ call k_wilson_bubble ( z , t_0 = 23 0.0_pr , p_end = 0.5_pr , t = t , p = p , k = k ) call envelope2 ( & 1 , nc , z , T , P , k , & n_points , Tv , Pv , Dv , ncri , icri , Tcri , Pcri , Dcri , & pt_bub & ) ! ======================================================================== ! ======================================================================== !  Dew/AOP envelopes ! ------------------------------------------------------------------------ t = 300 p = p_wilson ( z , t ) do while ( p > 0.1 ) t = t - 5 p = p_wilson ( z , t ) end do k = 1 / k_wilson ( t , p ) call envelope2 ( & 2 , nc , z , T , P , k , & n_points , Tv , Pv , Dv , ncri , icri , Tcri , Pcri , Dcri , & pt_dew & ) ! ======================================================================== ! ======================================================================== !  HPLL Envelope ! ------------------------------------------------------------------------ t = 70 0.0_pr t = pt_bub % t ( maxloc ( pt_bub % p , dim = 1 )) p = maxval ([ pt_bub % p , pt_dew % p ]) * 1.5_pr p = 400 call find_hpl ( t , p , k ) k = 1 / k call envelope2 ( & 3 , nc , z , T , P , k , & n_points , Tv , Pv , Dv , ncri , icri , Tcri , Pcri , Dcri , & pt_hpl & ) ! ======================================================================== ! ======================================================================== !  Look for crossings ! ------------------------------------------------------------------------ call get_case (& pt_dew , pt_bub , pt_hpl , & intersections , self_intersections , pt_case & ) print * , style_bold // pt_case // style_reset ! ======================================================================== three_phase : block use envelopes , only : pt_three_phase_from_intersection allocate ( pt_bub_3 ( size ( intersections )), pt_dew_3 ( size ( intersections ))) select case ( pt_case ) case ( \"2_DEW_BUB\" ) dsp_line : block use dsp_lines , only : injelope , dsp_line_from_dsp type ( injelope ) :: dsps ( 2 ) integer :: i do i = 1 , size ( intersections ) dsps = dsp_line_from_dsp ( intersections ( i ), pt_dew , pt_bub ) end do end block dsp_line call pt_three_phase_from_intersection (& pt_dew , pt_bub , intersections , & pt_bub_3 , pt_dew_3 & ) case ( \"2_HPL_BUB_DEW_BUB\" ) call pt_three_phase_from_intersection (& pt_hpl , pt_bub , [ intersections ( 1 )], & pt_bub_3 , pt_dew_3 & ) call pt_three_phase_from_intersection (& pt_dew , pt_bub , [ intersections ( 2 )], & pt_bub_3 , pt_dew_3 & ) case ( \"2_HPL_BUB\" ) call pt_three_phase_from_intersection (& pt_hpl , pt_bub , [ intersections ( 1 )], & pt_bub_3 , pt_dew_3 & ) call pt_three_phase_from_intersection (& pt_hpl , pt_bub , [ intersections ( 2 )], & pt_bub_3 , pt_dew_3 & ) dsp_line_2hpl_bub : block use dsp_lines , only : injelope , dsp_line_from_dsp type ( injelope ) :: dsps ( 2 ) integer :: i do i = 1 , size ( intersections ) dsps = dsp_line_from_dsp ( intersections ( i ), pt_hpl , pt_bub , alpha0 = alpha ) end do end block dsp_line_2hpl_bub case ( \"1_HPL_DEW\" ) dsp_line_hpl : block use dsp_lines , only : injelope , dsp_line_from_dsp type ( injelope ) :: dsps ( 2 ) integer :: i do i = 1 , size ( intersections ) dsps = dsp_line_from_dsp ( intersections ( i ), pt_hpl , pt_dew , alpha0 = alpha ) end do end block dsp_line_hpl call pt_three_phase_from_intersection (& pt_hpl , pt_dew , intersections , & pt_bub_3 , pt_dew_3 & ) case ( \"1_HPL_BUB\" ) dsp_line_hpl_bub : block use dsp_lines , only : injelope , dsp_line_from_dsp type ( injelope ) :: dsps ( 2 ) integer :: i do i = 1 , size ( intersections ) dsps = dsp_line_from_dsp ( intersections ( i ), pt_hpl , pt_bub ) end do end block dsp_line_hpl_bub call pt_three_phase_from_intersection (& pt_hpl , pt_bub , intersections , & pt_dew_3 , pt_bub_3 & ) end select end block three_phase end subroutine subroutine px_envelopes !! Calculation of Px envelopes at selected temperature. use inj_envelopes , only : full_newton , z_injection , & T_inj => T , injection_envelope , z_0 , & injelope , injection_envelope_three_phase , get_z , & px_two_phase_from_pt , & px_three_phase_from_pt , & px_three_phase_from_inter , & px_hpl_line use envelopes , only : envelope , k_wilson , p_wilson use linalg , only : interpol , point , intersection type ( point ), allocatable :: inter (:), self_inter (:) real ( pr ) :: del_S0 integer :: ns , i real ( pr ) :: p real ( pr ) :: t_tol = 2 real ( pr ) :: dzda ( nc ) print * , style_underline // \"----------\" // style_reset print * , style_underline // \"Px Regions\" // style_reset print * , style_underline // \"----------\" // style_reset ! ======================================================================== !  Two phase envelopes ! ------------------------------------------------------------------------ print * , red // \"Running Bubble\" // style_reset px_bub = px_two_phase_from_pt ( t_inj , pt_bub , t_tol = 5.0_pr ) print * , blue // \"Running Dew\" // style_reset px_dew = px_two_phase_from_pt ( t_inj , pt_dew , t_tol = 5.0_pr ) print * , blue // \"Running HPLL\" // style_reset px_hpl = px_hpl_line ( 0.99_pr , maxval ( px_bub % p )) ! ======================================================================== ! ======================================================================== !  Look for crossings ! ------------------------------------------------------------------------ inter = intersection ( px_dew % alpha , px_dew % p , px_bub % alpha , px_bub % p ) self_inter = intersection ( px_bub % alpha , px_bub % p ) print * , style_bold // \"Px Intersections:      \" // style_reset , size ( inter ) print * , style_bold // \"Px Self-Intersections: \" // style_reset , size ( self_inter ) ! ======================================================================== ! ======================================================================== !  Three phase regions ! ------------------------------------------------------------------------ three_phase : block integer :: i type ( injelope ) :: px_bub_3 , px_dew_3 , px_branch_3 ( 2 ) if ( size ( inter ) == 0 ) then print * , \"Isolated Bub\" px_bub_3 = px_three_phase_from_pt ( t_inj , pt_bub_3 , t_tol ) print * , \"Isolated Dew\" px_dew_3 = px_three_phase_from_pt ( t_inj , pt_dew_3 , t_tol ) else do i = 1 , size ( inter ) print * , \"Intersection: \" , inter ( i ) px_branch_3 = px_three_phase_from_inter ( inter ( i ), px_dew , px_bub ) end do end if if ( size ( self_inter ) > 0 ) then do i = 1 , size ( self_inter ) !TODO: Add a check if one of the previous lines already !      in this DSP px_branch_3 = px_three_phase_from_inter (& self_inter ( i ), px_bub , px_bub & ) end do end if end block three_phase ! ======================================================================== end subroutine end program main","tags":"","loc":"sourcefile/main.f90.html"},{"title":"User Guide – fenvelopes","text":"","tags":"","loc":"page/index.html"},{"title":"User documentation – fenvelopes","text":"Fortran program to calculate phase envelopes.","tags":"","loc":"page/01_tutorial/index.html"},{"title":"Setting up the config file – fenvelopes","text":"The input files are based on the namelist format provided intrisicly in the\nFortran standard. An usual input file is structured like: ! input.nml ! ! Namelist based input file ! ========================= ! ! Units: !  - Pressure: bar !  - Temperature: K !  - Volume: L ! ========================= & nml_setup ! General settings nc = 5 , ! Number of components model = \"PR78\" , ! SRK PR76 PR78 mixrule = \"ClassicVdW\" ! only ClassicVdW for now / & nml_composition names = \"PC1\" \"PC2\" \"PC3\" \"PC4\" \"H2O\" spec = \"critical\" , ! critical or parameters specification z = 0.15 0.10 0.10 0.15 0.50 / & nml_classicvdw ! Classic VdW mixing rule parameters ! kij matrix kij ( 1 , :) = 0 0 0 0 0.7192 kij ( 2 , :) = 0 0 0 0 0.4598 kij ( 3 , :) = 0 0 0 0 0.2673 kij ( 4 , :) = 0 0 0 0 0.2417 kij ( 5 , :) = 0.7192 0.4598 0.2673 0.2417 0 ! lij matrix lij (:, :) = 0 / & nml_critical ! Critical constants ! Critical Temperature tc = 30 5.586 63 8.889 78 8.889 83 8.889 64 7.3 ! Critical Pressure pc = 4 8.82 1 9.65 1 0.2 7.72 22 0.89 ! Acentric Factor w = 0.098 0.535 0.891 1.085 0.344 / & nml_px ! Px envelopes relevant info ! Temperature T = 35 0.0 ! Initial composition, ussualy the same as the main fluid. z_0 = 0.15 0.10 0.10 0.15 0.50 ! Injection fluid composition z_injection = 1 0 0 0 0 ! Which kind of injection to realize injection_case = \"displace\" ! [dilute|displace] /","tags":"","loc":"page/01_tutorial/input.html"},{"title":"Theory behind this software – fenvelopes","text":"","tags":"","loc":"page/02_theory/index.html"},{"title":"Continuation method – fenvelopes","text":"All the phase envelopes in this software are calculated with the continuation\nmethod, as described by Allgower and Georg . It is used to calculate lines and hyper-lines defined by a system of equations.\nUsing information from the last calculated point, the next point is\ninitializated with a reasonable estimation of its solution, making convergence\nboth faster and easier in hard to converge problems. This method can be simplified in single steps Specify the value of a single variable. Solve a system of equations at the specification value. Determine how all variables change with respect that specified variable. Select a new specification with that information. The utilization of the contiuation method in phase-equilibria diagrams was \nshown by Michelsen with the calculation of multicomponent phase-envelopes.","tags":"","loc":"page/02_theory/continuation.html"}]}