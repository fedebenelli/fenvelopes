module saturation_points
   use constants, only: pr
   use legacy_ar_models, only: termo, nc
   use envelopes, only: k_wilson
   implicit none

   type :: EquilibriaState
      integer :: iters !! Iterations needed to reach the state
      real(pr), allocatable :: y(:) !! Vapour molar fractions
      real(pr), allocatable :: x(:) !! Liquid molar fractions
      real(pr) :: t !! Temperature [K]
      real(pr) :: p !! Pressure [bar]
   end type

   real(pr) :: tol = 1e-5_pr
   integer :: max_iterations = 100
   real(pr) :: step_tol = 0.1_pr
contains


   #: for inci in ["hpl", "bubble", "dew"]
      #: for val in ["pressure", "temperature"]
      #: if val=="pressure"
         #: set var="p"
         #: set spec="t"
      #: elif val=="temperature"
         #: set var="t"
         #: set spec="p"
      #: endif
      #: if inci=="bubble"
         #: set ROOTy=-1
         #: set ROOTz=1
      #: elif inci == "dew"
         #: set ROOTy=1
         #: set ROOTz=-1
      #: elif inci == "hpl"
         #: set ROOTy=1
         #: set ROOTz=1
      #: endif
   type(EquilibriaState) function ${inci}$_${val}$(n, ${spec}$, ${var}$0, y0, max_inner_its)
      !! ${inci.title()}$ ${val}$ calculation function.
      !!
      !! Calculates the ${inci}$ ${val}$ of a multicomponent mixture.
      use stdlib_optval, only: optval
      real(pr), intent(in) :: n(:) !! Composition vector [moles / molar fraction]
      real(pr), intent(in) :: ${spec}$ !! Temperature [K]
      real(pr), optional, intent(in) :: ${var}$0 !! Initial pressure [bar]
      real(pr), optional, intent(in) :: y0(:) !! Initial composition
      integer, optional, intent(in) :: max_inner_its(:) !! Inner iterations

      real(pr) :: ${var}$, vy, vz

      real(pr) :: k(size(n)), y(size(n)), z(size(n)), lnk(size(n))
      real(pr) :: lnfug_y(size(n)), dlnphi_d${var}$_y(size(n))
      real(pr) :: lnfug_z(size(n)), dlnphi_d${var}$_z(size(n))

      real(pr) :: f, step

      integer :: its, inner_its

      ! =======================================================================
      ! Handle arguments
      ! -----------------------------------------------------------------------
      z = n/sum(n)
      if (size(n) /= nc) call exit(1)
      if (present (${var}$0)) ${var}$ = ${var}$0
      inner_its = optval(inner_its, 50)

      ! Initiliaze with K-wilson factors
      if (present(y0)) then
         y = y0
         k = y/z
      else
         k = k_wilson(t, p)
         #:if inci == "bubble" or inci == "hpl"
            y = k * z
         #:else
            y = z / k
         #:endif
      end if
      ! =======================================================================

      ! =======================================================================
      !  Solve point
      ! -----------------------------------------------------------------------
      do its=1,max_iterations
         call termo(nc, ${ROOTy}$, 4, t, p, y, vy, philog=lnfug_y, dlphi${var}$=dlnphi_d${var}$_y)
         call termo(nc, ${ROOTz}$, 4, t, p, z, vz, philog=lnfug_z, dlphi${var}$=dlnphi_d${var}$_z)
         inner_its = 0
         
         do while (any(isnan(lnfug_y)) .and. t > 0)
             inner_its = inner_its + 1
            #:if var == "p"
            ${var}$ = ${var}$/2.0_pr
            #:elif var == "t"
            ${var}$ = ${var}$ - 5.0_pr
            #:endif
            call termo(nc, ${ROOTy}$, 4, t, p, y, vy, philog=lnfug_y, dlphi${var}$=dlnphi_d${var}$_y)
            call termo(nc, ${ROOTz}$, 4, t, p, z, vz, philog=lnfug_z, dlphi${var}$=dlnphi_d${var}$_z)
         end do
         lnk = lnfug_z - lnfug_y
         k = exp(lnk)
         f = sum(z*k) - 1
         step = f/sum(z * k * (dlnphi_d${var}$_z - dlnphi_d${var}$_y))
         do while (abs(step) > abs(step_tol * f))
            step = step/2
         end do
         ${var}$ = ${var}$ - step
         y = z*k
         if (abs(step) < tol) exit
      end do
      ${inci}$_${val}$ = EquilibriaState(its, y, z, t, p)
      ! =======================================================================
   end function
   #: endfor

   #: endfor
end module
